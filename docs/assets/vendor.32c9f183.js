function makeMap(str, expectsLowerCase) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map3[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map3[val.toLowerCase()] : (val) => !!map3[val];
}
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$c(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject$p(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$c(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$p(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a.length; i2++) {
    equal = looseEqual(a[i2], b[i2]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isArray$c(a);
  bValidType = isArray$c(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$p(a);
  bValidType = isObject$p(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray$c(val) || isObject$p(val) && (val.toString === objectToString$1 || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries3, [key, val2]) => {
        entries3[`${key} =>`] = val2;
        return entries3;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$p(val) && !isArray$c(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn$k = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$c = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol$4 = (val) => typeof val === "symbol";
const isObject$p = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$p(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function warn$2(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = this.parent;
      }
    } else {
      warn$2(`cannot run an inactive effect scope.`);
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else {
    warn$2(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent2 = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent2) {
      if (parent2 === this) {
        return;
      }
      parent2 = parent2.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
    }
  }
  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner2 = _effect.run.bind(_effect);
  runner2.effect = _effect;
  return runner2;
}
function stop(runner2) {
  runner2.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = { effect: activeEffect, target, type, key };
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({
        effect: activeEffect
      }, debuggerEventExtraInfo));
    }
  }
}
function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$c(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$c(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$c(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = { target, type, key, newValue, oldValue, oldTarget };
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0], eventInfo);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects), eventInfo);
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect2 of isArray$c(dep) ? dep : [...dep]) {
    if (effect2 !== activeEffect || effect2.allowRecurse) {
      if (effect2.onTrigger) {
        effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
      if (effect2.scheduler) {
        effect2.scheduler();
      } else {
        effect2.run();
      }
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol$4));
const get$9 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get3(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$c(target);
    if (!isReadonly2 && targetIsArray && hasOwn$k(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$4(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$p(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$6 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow$1(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$c(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$c(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$k(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn$k(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger$1(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$4(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$4(target) {
  track(target, "iterate", isArray$c(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$9,
  set: set$6,
  deleteProperty,
  has: has$1,
  ownKeys: ownKeys$4
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger$1(target, "add", value, value);
  }
  return this;
}
function set$1$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger$1(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger$1(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3 ? get3.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger$1(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear$2() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger$1(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method2, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
    const isKeyOnly = method2 === "keys" && targetIsMap;
    const innerIterator = target[method2](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear: clear$2,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear: clear$2,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method2) => {
    mutableInstrumentations2[method2] = createIterableMethod(method2, false, false);
    readonlyInstrumentations2[method2] = createIterableMethod(method2, true, false);
    shallowInstrumentations2[method2] = createIterableMethod(method2, false, true);
    shallowReadonlyInstrumentations2[method2] = createIterableMethod(method2, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn$k(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$p(target)) {
    {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow$1(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$p(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$p(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2, ref2.value);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get3, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get3;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (!isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = isArray$c(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      console.warn("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
Promise.resolve();
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn$1(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last2 = normalizedStack[0];
    if (last2 && last2.vnode === currentVNode) {
      last2.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix2 = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix2;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys4 = Object.keys(props);
  keys4.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys4.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values2 = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values2.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values2;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type];
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$2 = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue$2.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue$2[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue$2.length || !queue$2.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue$2.push(job);
    } else {
      queue$2.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue$2.indexOf(job);
  if (i2 > flushIndex) {
    queue$2.splice(i2, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!isArray$c(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  flushPreFlushCbs(seen);
  queue$2.sort((a, b) => getId(a) - getId(b));
  const check2 = (job) => checkRecursiveUpdates(seen, job);
  try {
    for (flushIndex = 0; flushIndex < queue$2.length; flushIndex++) {
      const job = queue$2[flushIndex];
      if (job && job.active !== false) {
        if (check2(job)) {
          continue;
        }
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$2.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$2.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn$1(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
{
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map$a = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id2 = instance.type.__hmrId;
  let record = map$a.get(id2);
  if (!record) {
    createRecord(id2, instance.type);
    record = map$a.get(id2);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map$a.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id2, initialDef) {
  if (map$a.has(id2)) {
    return false;
  }
  map$a.set(id2, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id2, newRender) {
  const record = map$a.get(id2);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id2, newComp) {
  const record = map$a.get(id2);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
      if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
        instance.parent.ceReload(newComp.styles);
      }
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id2, arg) => {
    try {
      return fn(id2, arg);
    } catch (e2) {
      console.error(e2);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit("app:unmount", app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
const devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit("component:emit", component.appContext.app, component, event, params);
}
function emit$1(instance, event, ...rawArgs) {
  const props = instance.vnode.props || EMPTY_OBJ;
  {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn$1(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => a.trim());
    } else if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  {
    devtoolsComponentEmit(instance, event, args);
  }
  {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn$1(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray$c(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$k(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$k(options, hyphenate(key)) || hasOwn$k(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit3, render: render2, renderCache, data: data2, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data2, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render3.length > 1 ? render3(props, true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit3
      } : { attrs, slots, emit: emit3 }) : render3(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys4 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys4.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys4.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (!accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i2 = 0, l = allAttrs.length; i2 < l; i2++) {
          const key = allAttrs[i2];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn$1(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (!isElementRoot(root)) {
      warn$1(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (!isElementRoot(root)) {
      warn$1(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root.transition = vnode.transition;
  }
  if (setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if ((prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent: parent2 }, el) {
  while (parent2 && parent2.subTree === vnode) {
    (vnode = parent2.vnode).el = el;
    parent2 = parent2.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch, o: { createElement: createElement2 } } = rendererInternals;
  const hiddenContainer = createElement2("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement2("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent2, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (!hasWarned) {
    hasWarned = true;
    console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
  }
  const { p: patch, m: move, um: unmount, n: next2, o: { parentNode, remove: remove2 } } = rendererInternals;
  const timeout = toNumber(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent: parent2,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(`suspense.resolve() is called without a pending branch.`);
        }
        if (suspense.isUnmounted) {
          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
        }
      }
      const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next2(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent3 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent3) {
        if (parent3.pendingBranch) {
          parent3.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent3 = parent3.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next2(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null, true);
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next2(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next2(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node2, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node2.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result = hydrateNode(node2, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$c(s)) {
    const singleChild = filterSingleRoot(s);
    if (!singleChild) {
      warn$1(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$c(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    {
      warn$1(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, Object.assign(options || {}, { flush: "post" }));
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, Object.assign(options || {}, { flush: "sync" }));
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (!isFunction(cb)) {
    warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush: flush2, onTrack, onTrigger } = EMPTY_OBJ) {
  if (!cb) {
    if (immediate !== void 0) {
      warn$1(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn$1(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow$1(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$c(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else {
        warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush2 === "sync") {
    scheduler = job;
  } else if (flush2 === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  {
    effect2.onTrack = onTrack;
    effect2.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush2 === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  return () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$p(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$c(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      if (children.length > 1) {
        warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn$1(`invalid <transition> mode: ${mode}`);
      }
      const child = children[0];
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        hook(el, done);
        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        onLeave(el, done);
        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } else if (keepComment || child.type !== Comment) {
      ret.push(child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve3, reject2) => {
          const userRetry = () => resolve3(retry());
          const userFail = () => reject2(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (!comp) {
        warn$1(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (comp && !isObject$p(comp) && !isFunction(comp)) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props, children } }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return slots.default;
    }
    const cache = /* @__PURE__ */ new Map();
    const keys4 = /* @__PURE__ */ new Set();
    let current = null;
    {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement: createElement2 } } } = sharedContext;
    const storageContainer = createElement2("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      {
        devtoolsComponentAdded(instance2);
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter4) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter4 || !filter4(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys4.delete(key);
    }
    watch(() => [props.include, props.exclude], ([include, exclude]) => {
      include && pruneCache((name) => matches(include, name));
      exclude && pruneCache((name) => !matches(exclude, name));
    }, { flush: "post", deep: true });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        {
          warn$1(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const { include, exclude, max: max2 } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys4.delete(key);
        keys4.add(key);
      } else {
        keys4.add(key);
        if (max2 && keys4.size > parseInt(max2, 10)) {
          pruneCacheEntry(keys4.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return rawVNode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$c(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn$1(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (!isFunction(dataOptions)) {
      warn$1(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data2 = dataOptions.call(publicThis, publicThis);
    if (isPromise$1(data2)) {
      warn$1(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject$p(data2)) {
      warn$1(`data() should return an object.`);
    } else {
      instance.data = reactive(data2);
      {
        for (const key in data2) {
          checkDuplicateProperties("Data", key);
          if (key[0] !== "$" && key[0] !== "_") {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data2[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get3 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get3 === NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
        warn$1(`Write operation failed: computed property "${key}" is readonly.`);
      };
      const c = computed({
        get: get3,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$c(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$c(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$c(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$p(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        {
          warn$1(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$c(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$p(raw)) {
    if (isArray$c(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions$1(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  cache.set(base, resolved);
  return resolved;
}
function mergeOptions$1(to, from4, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from4;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions$1(to, m, strats, true));
  }
  for (const key in from4) {
    if (asMixin && key === "expose") {
      warn$1(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from4[key]) : from4[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from4) {
  if (!from4) {
    return to;
  }
  if (!to) {
    return from4;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from4) ? from4.call(this, this) : from4);
  };
}
function mergeInject(to, from4) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from4));
}
function normalizeInject(raw) {
  if (isArray$c(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from4) {
  return to ? [...new Set([].concat(to, from4))] : from4;
}
function mergeObjectOptions(to, from4) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from4) : from4;
}
function mergeWatchOptions(to, from4) {
  if (!to)
    return from4;
  if (!from4)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from4) {
    merged[key] = mergeAsArray(to[key], from4[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        const value = rawProps[key];
        if (options) {
          if (hasOwn$k(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn$k(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$k(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$k(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$k(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$k(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$k(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys4] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys4)
        needCastKeys.push(...keys4);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$c(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      if (!isString(raw[i2])) {
        warn$1(`props must be strings when using array syntax.`, raw[i2]);
      }
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (!isObject$p(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$c(opt) || isFunction(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$k(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match2 ? match2[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$c(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn$k(rawProps, key) && !hasOwn$k(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray$c(type) ? type : [type];
    const expectedTypes = [];
    for (let i2 = 0; i2 < types.length && !isValid; i2++) {
      const { valid, expectedType } = assertType(value, types[i2]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$p(value);
  } else if (expectedType === "Array") {
    valid = isArray$c(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$c(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  const normalized = withCtx((...args) => {
    if (currentInstance) {
      warn$1(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      {
        warn$1(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (!isKeepAlive(instance.vnode) && true) {
    warn$1(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (isHmrUpdating) {
        extend(slots, children);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    warn$1(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (isFunction(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$5 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (rootProps != null && !isObject$p(rootProps)) {
      warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$5++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
        {
          warn$1(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
          warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else {
          warn$1(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else {
            warn$1("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app;
      },
      component(name, component) {
        {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (context.components[name]) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (context.directives[name]) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          {
            context.reload = () => {
              render2(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          {
            app._instance = vnode.component;
            devtoolsInitApp(app, version$1);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else {
          warn$1(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else {
          warn$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (key in context.provides) {
          warn$1(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$c(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$c(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (!owner) {
    warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$k(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$c(existing) && remove(existing, refValue);
          } else {
            if (!isArray$c(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$k(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (isRef(ref2)) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else {
          warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else {
      warn$1("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node2) => node2.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      warn$1(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
      patch(null, vnode, container);
      flushPostFlushCbs();
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node2) && node2.data === "[";
    const onMismatch = () => handleMismatch(node2, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type, ref: ref2, shapeFlag } = vnode;
    const domType = node2.nodeType;
    vnode.el = node2;
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          nextNode = onMismatch();
        } else {
          if (node2.data !== vnode.children) {
            hasMismatch = true;
            warn$1(`Hydration text mismatch:
- Client: ${JSON.stringify(node2.data)}
- Server: ${JSON.stringify(vnode.children)}`);
            node2.data = vnode.children;
          }
          nextNode = nextSibling(node2);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node2);
        }
        break;
      case Static:
        if (domType !== 1) {
          nextNode = onMismatch();
        } else {
          nextNode = node2;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.outerHTML;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node2.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node2);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node2) : nextSibling(node2);
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node2.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node2;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node2, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node2)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(el, key, null, props[key], false, void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp2(el, "onClick", null, props.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
        let next2 = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        let hasWarned2 = false;
        while (next2) {
          hasMismatch = true;
          if (!hasWarned2) {
            warn$1(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
            hasWarned2 = true;
          }
          const cur = next2;
          next2 = next2.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          warn$1(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node2, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned2 = false;
    for (let i2 = 0; i2 < l; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node2) {
        node2 = hydrateNode(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        if (!hasWarned2) {
          warn$1(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
          hasWarned2 = true;
        }
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node2;
  };
  const hydrateFragment = (node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node2);
    const next2 = hydrateChildren(nextSibling(node2), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next2 && isComment(next2) && next2.data === "]") {
      return nextSibling(vnode.anchor = next2);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next2);
      return next2;
    }
  };
  const handleMismatch = (node2, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    warn$1(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node2, node2.nodeType === 3 ? `(text)` : isComment(node2) && node2.data === "[" ? `(start of fragment)` : ``);
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node2);
      while (true) {
        const next3 = nextSibling(node2);
        if (next3 && next3 !== end) {
          remove2(next3);
        } else {
          break;
        }
      }
    }
    const next2 = nextSibling(node2);
    const container = parentNode(node2);
    remove2(node2);
    patch(null, vnode, container, next2, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next2;
  };
  const locateClosingAsyncAnchor = (node2) => {
    let match2 = 0;
    while (node2) {
      node2 = nextSibling(node2);
      if (node2 && isComment(node2)) {
        if (node2.data === "[")
          match2++;
        if (node2.data === "]") {
          if (match2 === 0) {
            return nextSibling(node2);
          } else {
            match2--;
          }
        }
      }
    }
    return node2;
  };
  return [hydrate2, hydrateNode];
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  {
    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  {
    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
function initFeatureFlags() {
  const needWarn = [];
  if (needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else {
          warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next2;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostRemove(el);
      el = next2;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next2 = newProps[key];
            if (next2 !== prev || key === "value") {
              hostPatchProp(el, key, prev, next2, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next2 = newProps[key];
        const prev = oldProps[key];
        if (next2 !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next2, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (instance.type.__hmrId) {
      registerHMR(instance);
    }
    {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent: parent2 } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent2, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          {
            startMeasure(instance, `patch`);
          }
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next: next2, bu, u: u2, parent: parent2, vnode } = instance;
        let originNext = next2;
        let vnodeHook;
        {
          pushWarningContext(next2 || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next2) {
          next2.el = vnode.el;
          updateComponentPreRender(instance, next2, optimized);
        } else {
          next2 = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent2, next2, vnode);
        }
        toggleRecurse(instance, true);
        {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        {
          startMeasure(instance, `patch`);
        }
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        {
          endMeasure(instance, `patch`);
        }
        next2.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, next2, vnode), parentSuspense);
        }
        {
          devtoolsComponentUpdated(instance);
        }
        {
          popWarningContext();
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
    const update4 = instance.update = effect2.run.bind(effect2);
    update4.id = instance.uid;
    toggleRecurse(instance, true);
    {
      effect2.onTrack = instance.rtc ? (e2) => invokeArrayFns(instance.rtc, e2) : void 0;
      effect2.onTrigger = instance.rtg ? (e2) => invokeArrayFns(instance.rtg, e2) : void 0;
      update4.ownerInstance = instance;
    }
    update4();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          if (keyToNewIndexMap.has(nextChild.key)) {
            warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next2;
    while (cur !== end) {
      next2 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next2;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, update: update4, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update4) {
      update4.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update: update4 }, allowed) {
  effect2.allowRecurse = update4.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$c(ch1) && isArray$c(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u2, v, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v = result.length - 1;
      while (u2 < v) {
        c = u2 + v >> 1;
        if (arr[result[c]] < arrI) {
          u2 = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      warn$1(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
      return null;
    } else {
      const target = select(targetSelector);
      if (!target) {
        warn$1(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
      }
      return target;
    }
  } else {
    if (!targetSelector && !isTeleportDisabled(props)) {
      warn$1(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el = createComment("teleport start");
      const mainAnchor = n2.anchor = createComment("teleport end");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      } else if (!disabled) {
        warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          } else {
            warn$1("Invalid Teleport target on update:", target, `(${typeof target})`);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node2), vnode, parentNode(node2), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node2);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else {
    warn$1(`resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`);
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const Fragment = Symbol("Fragment");
const Text = Symbol("Text");
const Comment = Symbol("Comment");
const Static = Symbol("Static");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (vnode.key !== vnode.key) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = createVNodeWithArgsTransform;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (!type) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$p(style)) {
      if (isProxy(style) && !isArray$c(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$p(type) ? 4 : isFunction(type) ? 2 : 0;
  if (shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn$1(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$c(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: patchFlag === -1 && isArray$c(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray$c(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$c(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$c(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$c(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray$c(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn$1(`The v-for range expect an integer value but got ${source}.`);
      return [];
    }
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$p(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys4 = Object.keys(source);
      ret = new Array(keys4.length);
      for (let i2 = 0, l = keys4.length; i2 < l; i2++) {
        const key = keys4[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$c(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot.length > 1) {
    warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj) {
  const ret = {};
  if (!isObject$p(obj)) {
    warn$1(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = extend(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => shallowReadonly(i2.props),
  $attrs: (i2) => shallowReadonly(i2.attrs),
  $slots: (i2) => shallowReadonly(i2.slots),
  $refs: (i2) => shallowReadonly(i2.refs),
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => () => queueJob(i2.update),
  $nextTick: (i2) => nextTick.bind(i2.proxy),
  $watch: (i2) => instanceWatch.bind(i2)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn$k(setupState, key)) {
      return setupState[key];
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data2[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn$k(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data2 !== EMPTY_OBJ && hasOwn$k(data2, key)) {
        accessCache[key] = 2;
        return data2[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$k(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$k(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
        markAttrsAccessed();
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$k(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$k(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
      if (data2 !== EMPTY_OBJ && (key[0] === "$" || key[0] === "_") && hasOwn$k(data2, key)) {
        warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn$1(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data: data2, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn$k(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data2 !== EMPTY_OBJ && hasOwn$k(data2, key)) {
      data2[key] = value;
      return true;
    } else if (hasOwn$k(instance.props, key)) {
      warn$1(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn$1(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn$k(data2, key) || setupState !== EMPTY_OBJ && hasOwn$k(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$k(normalizedProps, key) || hasOwn$k(ctx, key) || hasOwn$k(publicPropertiesMap, key) || hasOwn$k(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      this.set(target, key, descriptor.get(), null);
    } else if (descriptor.value != null) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
    if (!has2 && PublicInstanceProxyHandlers.has(_, key)) {
      warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
    }
    return has2;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (key[0] === "$" || key[0] === "_") {
        warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
const emptyAppContext = createAppContext();
let uid$1$1 = 0;
function createComponentInstance(vnode, parent2, suspense) {
  const type = vnode.type;
  const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$1++,
    vnode,
    type,
    parent: parent2,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent2 ? parent2.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent2 ? parent2.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config2) {
  const appIsNativeTag = config2.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn$1("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateComponentName(names[i2], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i2 = 0; i2 < names.length; i2++) {
        validateDirectiveName(names[i2]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [shallowReadonly(instance.props), setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$p(setupResult)) {
    if (isVNode(setupResult)) {
      warn$1(`setup() should not return VNodes directly - return a render function instead.`);
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn$1(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template;
      if (template) {
        {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
        {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (!Component.render && instance.render === NOOP && !isSSR) {
    if (!compile$1 && Component.template) {
      warn$1(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
    } else {
      warn$1(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      markAttrsAccessed();
      track(instance, "get", "$attrs");
      return target[key];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (instance.exposed) {
      warn$1(`expose() should be called only once per setup().`);
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match2) {
      name = match2[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const warnRuntimeUsage = (method2) => warn$1(`${method2}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
function defineProps() {
  {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
function defineEmits() {
  {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
function defineExpose(exposed) {
  {
    warnRuntimeUsage(`defineExpose`);
  }
}
function withDefaults(props, defaults) {
  {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i2 = getCurrentInstance();
  if (!i2) {
    warn$1(`useContext() called without active instance.`);
  }
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function mergeDefaults(raw, defaults) {
  const props = isArray$c(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
  for (const key in defaults) {
    const opt = props[key];
    if (opt) {
      if (isArray$c(opt) || isFunction(opt)) {
        props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      props[key] = { default: defaults[key] };
    } else {
      warn$1(`props default key "${key}" has no corresponding declaration.`);
    }
  }
  return props;
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (!ctx) {
    warn$1(`withAsyncContext called without active current instance. This is likely a bug.`);
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise$1(awaitable)) {
    awaitable = awaitable.catch((e2) => {
      setCurrentInstance(ctx);
      throw e2;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$p(propsOrChildren) && !isArray$c(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(`ssrContext`);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn$1(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function initCustomFormatter() {
  if (typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#0b1bc9" };
  const stringStyle = { style: "color:#b62e24" };
  const keywordStyle = { style: "color:#9d288c" };
  const formatter = {
    header(obj) {
      if (!isObject$p(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject$p(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray$c(opts) && opts.includes(key) || isObject$p(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
function withMemo(memo, render2, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev.length; i2++) {
    if (prev[i2] !== memo[i2]) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$1 = "3.2.31";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && doc.createElement("template");
const nodeOps = {
  insert: (child, parent2, anchor) => {
    parent2.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent2 = child.parentNode;
    if (parent2) {
      parent2.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node2, text) => {
    node2.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node2) => node2.parentNode,
  nextSibling: (node2) => node2.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent2, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent2.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent2.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper2 = template.firstChild;
        while (wrapper2.firstChild) {
          template.appendChild(wrapper2.firstChild);
        }
        template.removeChild(wrapper2);
      }
      parent2.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent2.firstChild,
      anchor ? anchor.previousSibling : parent2.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next2) {
  const style = el.style;
  const isCssString = isString(next2);
  if (next2 && !isCssString) {
    for (const key in next2) {
      setStyle(style, key, next2[key]);
    }
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next2[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next2) {
        style.cssText = next2;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$c(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      el[key] = includeBooleanAttr(value);
      return;
    } else if (value == null && type === "string") {
      el[key] = "";
      el.removeAttribute(key);
      return;
    } else if (type === "number") {
      try {
        el[key] = 0;
      } catch (_a) {
      }
      el.removeAttribute(key);
      return;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
    {
      warn$1(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e2);
    }
  }
}
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== "undefined") {
  if (_getNow() > document.createEvent("Event").timeStamp) {
    _getNow = () => performance.now();
  }
  const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$c(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn && fn(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydate) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydate);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      if (this.shadowRoot) {
        warn$1(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
      }
      this.attachShadow({ mode: "open" });
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      this._resolveDef();
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    if (this._resolved) {
      return;
    }
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve3 = (def2) => {
      const { props, styles } = def2;
      const hasOptions = !isArray$c(props);
      const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
      let numberProps;
      if (hasOptions) {
        for (const key in this._props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            this._props[key] = toNumber(this._props[key]);
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
          }
        }
      }
      this._numberProps = numberProps;
      for (const key of Object.keys(this)) {
        if (key[0] !== "_") {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of rawKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(resolve3);
    } else {
      resolve3(this._def);
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    if (this._numberProps && this._numberProps[key]) {
      value = toNumber(value);
    }
    this._setProp(camelize(key), value, false);
  }
  _getProp(key) {
    return this._props[key];
  }
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this.shadowRoot.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            if (!this._def.__asyncLoader) {
              this._instance = null;
              this._update();
            }
          };
        }
        instance.emit = (event, ...args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        let parent2 = this;
        while (parent2 = parent2 && (parent2.parentNode || parent2.host)) {
          if (parent2 instanceof VueElement) {
            instance.parent = parent2._instance;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
        {
          (this._styles || (this._styles = [])).push(s);
        }
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      warn$1(`useCssModule must be called inside setup()`);
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      warn$1(`Current instance does not have CSS modules injected.`);
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      warn$1(`Current instance does not have CSS module named "${name}".`);
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    warn$1(`useCssVars is called without current active component instance.`);
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$c(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$c(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve3 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve3]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve3);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      const resolve3 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve3);
        }
      });
      callHook(onLeave, [el, resolve3]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$p(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  validateDuration(res);
  return res;
}
function validateDuration(val) {
  if (typeof val !== "number") {
    warn$1(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
  }
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve3) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el._endId) {
      resolve3();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve3();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e2) => {
          if (e2 && e2.target !== el) {
            return;
          }
          if (!e2 || /transform$/.test(e2.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        } else {
          warn$1(`<TransitionGroup> children must be keyed.`);
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"];
  return isArray$c(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    trigger(target, "input");
  }
}
function trigger(el, type) {
  const e2 = document.createEvent("HTMLEvents");
  e2.initEvent(type, true, true);
  el.dispatchEvent(e2);
}
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = toNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim2) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el) {
      if (lazy) {
        return;
      }
      if (trim2 && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && toNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign3 = el._assign;
      if (isArray$c(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign3(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign3(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign3(cloned);
      } else {
        assign3(getCheckboxValue(el, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$c(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map((o2) => number ? toNumber(getValue(o2)) : getValue(o2));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$c(value) && !isSet(value)) {
    warn$1(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
    return;
  }
  for (let i2 = 0, l = el.options.length; i2 < l; i2++) {
    const option = el.options[i2];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$c(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i2)
          el.selectedIndex = i2;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
  let modelToUse;
  switch (el.tagName) {
    case "SELECT":
      modelToUse = vModelSelect;
      break;
    case "TEXTAREA":
      modelToUse = vModelText;
      break;
    default:
      switch (vnode.props && vnode.props.type) {
        case "checkbox":
          modelToUse = vModelCheckbox;
          break;
        case "radio":
          modelToUse = vModelRadio;
          break;
        default:
          modelToUse = vModelText;
      }
  }
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$c(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m) => e2[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if (isRuntimeOnly()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn$1(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn$1(msg);
        return compilerOptions;
      },
      set() {
        warn$1(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (!res) {
      warn$1(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn$1(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
function initDev() {
  {
    initCustomFormatter();
  }
}
{
  initDev();
}
const compile = () => {
  {
    warn$1(`Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
  }
};
var vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  compile,
  EffectScope,
  ReactiveEffect,
  customRef,
  effect,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow: isShallow$1,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  camelize,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString,
  toHandlerKey,
  BaseTransition,
  Comment,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs,
  useSSRContext,
  useSlots,
  useTransitionState,
  version: version$1,
  warn: warn$1,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId,
  Transition,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate,
  initDirectivesForSSR,
  render,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(interopRequireDefault);
var getOwnPropertyDescriptor$9 = { exports: {} };
var check = function(it) {
  return it && it.Math == Math && it;
};
var global$V = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || Function("return this")();
var fails$u = function(exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$t = fails$u;
var functionBindNative = !fails$t(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$4 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$7 = FunctionPrototype$3.apply;
var call$q = FunctionPrototype$3.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$4 ? call$q.bind(apply$7) : function() {
  return call$q.apply(apply$7, arguments);
});
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var bind$q = FunctionPrototype$2.bind;
var call$p = FunctionPrototype$2.call;
var uncurryThis$w = NATIVE_BIND$3 && bind$q.bind(call$p, call$p);
var functionUncurryThis = NATIVE_BIND$3 ? function(fn) {
  return fn && uncurryThis$w(fn);
} : function(fn) {
  return fn && function() {
    return call$p.apply(fn, arguments);
  };
};
var isCallable$l = function(argument) {
  return typeof argument == "function";
};
var objectGetOwnPropertyDescriptor = {};
var fails$s = fails$u;
var descriptors = !fails$s(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var NATIVE_BIND$2 = functionBindNative;
var call$o = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$o.bind(call$o) : function() {
  return call$o.apply(call$o, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$8 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$8 && !$propertyIsEnumerable$2.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$8(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$2;
var createPropertyDescriptor$7 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var uncurryThis$v = functionUncurryThis;
var toString$c = uncurryThis$v({}.toString);
var stringSlice$2 = uncurryThis$v("".slice);
var classofRaw$1 = function(it) {
  return stringSlice$2(toString$c(it), 8, -1);
};
var global$U = global$V;
var uncurryThis$u = functionUncurryThis;
var fails$r = fails$u;
var classof$f = classofRaw$1;
var Object$9 = global$U.Object;
var split = uncurryThis$u("".split);
var indexedObject = fails$r(function() {
  return !Object$9("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$f(it) == "String" ? split(it, "") : Object$9(it);
} : Object$9;
var global$T = global$V;
var TypeError$m = global$T.TypeError;
var requireObjectCoercible$6 = function(it) {
  if (it == void 0)
    throw TypeError$m("Can't call method on " + it);
  return it;
};
var IndexedObject$3 = indexedObject;
var requireObjectCoercible$5 = requireObjectCoercible$6;
var toIndexedObject$b = function(it) {
  return IndexedObject$3(requireObjectCoercible$5(it));
};
var isCallable$k = isCallable$l;
var isObject$o = function(it) {
  return typeof it == "object" ? it !== null : isCallable$k(it);
};
var path$u = {};
var path$t = path$u;
var global$S = global$V;
var isCallable$j = isCallable$l;
var aFunction = function(variable) {
  return isCallable$j(variable) ? variable : void 0;
};
var getBuiltIn$f = function(namespace, method2) {
  return arguments.length < 2 ? aFunction(path$t[namespace]) || aFunction(global$S[namespace]) : path$t[namespace] && path$t[namespace][method2] || global$S[namespace] && global$S[namespace][method2];
};
var uncurryThis$t = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$t({}.isPrototypeOf);
var getBuiltIn$e = getBuiltIn$f;
var engineUserAgent = getBuiltIn$e("navigator", "userAgent") || "";
var global$R = global$V;
var userAgent$6 = engineUserAgent;
var process$4 = global$R.process;
var Deno = global$R.Deno;
var versions = process$4 && process$4.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent$6) {
  match = userAgent$6.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$6.match(/Chrome\/(\d+)/);
    if (match)
      version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION$3 = engineV8Version;
var fails$q = fails$u;
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$q(function() {
  var symbol2 = Symbol();
  return !String(symbol2) || !(Object(symbol2) instanceof Symbol) || !Symbol.sham && V8_VERSION$3 && V8_VERSION$3 < 41;
});
var NATIVE_SYMBOL$2 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var global$Q = global$V;
var getBuiltIn$d = getBuiltIn$f;
var isCallable$i = isCallable$l;
var isPrototypeOf$m = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Object$8 = global$Q.Object;
var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol2 = getBuiltIn$d("Symbol");
  return isCallable$i($Symbol2) && isPrototypeOf$m($Symbol2.prototype, Object$8(it));
};
var global$P = global$V;
var String$5 = global$P.String;
var tryToString$4 = function(argument) {
  try {
    return String$5(argument);
  } catch (error) {
    return "Object";
  }
};
var global$O = global$V;
var isCallable$h = isCallable$l;
var tryToString$3 = tryToString$4;
var TypeError$l = global$O.TypeError;
var aCallable$m = function(argument) {
  if (isCallable$h(argument))
    return argument;
  throw TypeError$l(tryToString$3(argument) + " is not a function");
};
var aCallable$l = aCallable$m;
var getMethod$3 = function(V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable$l(func);
};
var global$N = global$V;
var call$n = functionCall;
var isCallable$g = isCallable$l;
var isObject$n = isObject$o;
var TypeError$k = global$N.TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$g(fn = input.toString) && !isObject$n(val = call$n(fn, input)))
    return val;
  if (isCallable$g(fn = input.valueOf) && !isObject$n(val = call$n(fn, input)))
    return val;
  if (pref !== "string" && isCallable$g(fn = input.toString) && !isObject$n(val = call$n(fn, input)))
    return val;
  throw TypeError$k("Can't convert object to primitive value");
};
var shared$4 = { exports: {} };
var isPure = true;
var global$M = global$V;
var defineProperty$f = Object.defineProperty;
var setGlobal$1 = function(key, value) {
  try {
    defineProperty$f(global$M, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$M[key] = value;
  }
  return value;
};
var global$L = global$V;
var setGlobal = setGlobal$1;
var SHARED = "__core-js_shared__";
var store$3 = global$L[SHARED] || setGlobal(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$4.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.21.1",
  mode: "pure",
  copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var global$K = global$V;
var requireObjectCoercible$4 = requireObjectCoercible$6;
var Object$7 = global$K.Object;
var toObject$c = function(argument) {
  return Object$7(requireObjectCoercible$4(argument));
};
var uncurryThis$s = functionUncurryThis;
var toObject$b = toObject$c;
var hasOwnProperty = uncurryThis$s({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$b(it), key);
};
var uncurryThis$r = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$b = uncurryThis$r(1 .toString);
var uid$4 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$b(++id$2 + postfix, 36);
};
var global$J = global$V;
var shared$3 = shared$4.exports;
var hasOwn$j = hasOwnProperty_1;
var uid$3 = uid$4;
var NATIVE_SYMBOL$1 = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore$1 = shared$3("wks");
var Symbol$2 = global$J.Symbol;
var symbolFor = Symbol$2 && Symbol$2["for"];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid$3;
var wellKnownSymbol$m = function(name) {
  if (!hasOwn$j(WellKnownSymbolsStore$1, name) || !(NATIVE_SYMBOL$1 || typeof WellKnownSymbolsStore$1[name] == "string")) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL$1 && hasOwn$j(Symbol$2, name)) {
      WellKnownSymbolsStore$1[name] = Symbol$2[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore$1[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore$1[name];
};
var global$I = global$V;
var call$m = functionCall;
var isObject$m = isObject$o;
var isSymbol$2 = isSymbol$3;
var getMethod$2 = getMethod$3;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$l = wellKnownSymbol$m;
var TypeError$j = global$I.TypeError;
var TO_PRIMITIVE$1 = wellKnownSymbol$l("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$m(input) || isSymbol$2(input))
    return input;
  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE$1);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$m(exoticToPrim, input, pref);
    if (!isObject$m(result) || isSymbol$2(result))
      return result;
    throw TypeError$j("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol$1 = isSymbol$3;
var toPropertyKey$4 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol$1(key) ? key : key + "";
};
var global$H = global$V;
var isObject$l = isObject$o;
var document$3 = global$H.document;
var EXISTS$1 = isObject$l(document$3) && isObject$l(document$3.createElement);
var documentCreateElement$1 = function(it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};
var DESCRIPTORS$h = descriptors;
var fails$p = fails$u;
var createElement$1 = documentCreateElement$1;
var ie8DomDefine = !DESCRIPTORS$h && !fails$p(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$g = descriptors;
var call$l = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$6 = createPropertyDescriptor$7;
var toIndexedObject$a = toIndexedObject$b;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$i = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$a(O);
  P = toPropertyKey$3(P);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$2(O, P);
    } catch (error) {
    }
  if (hasOwn$i(O, P))
    return createPropertyDescriptor$6(!call$l(propertyIsEnumerableModule$2.f, O, P), O[P]);
};
var fails$o = fails$u;
var isCallable$f = isCallable$l;
var replacement = /#|\.prototype\./;
var isForced$2 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$f(detection) ? fails$o(detection) : !!detection;
};
var normalize = isForced$2.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = "N";
var POLYFILL = isForced$2.POLYFILL = "P";
var isForced_1 = isForced$2;
var uncurryThis$q = functionUncurryThis;
var aCallable$k = aCallable$m;
var NATIVE_BIND$1 = functionBindNative;
var bind$p = uncurryThis$q(uncurryThis$q.bind);
var functionBindContext = function(fn, that) {
  aCallable$k(fn);
  return that === void 0 ? fn : NATIVE_BIND$1 ? bind$p(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var objectDefineProperty = {};
var DESCRIPTORS$f = descriptors;
var fails$n = fails$u;
var v8PrototypeDefineBug = DESCRIPTORS$f && fails$n(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var global$G = global$V;
var isObject$k = isObject$o;
var String$4 = global$G.String;
var TypeError$i = global$G.TypeError;
var anObject$u = function(argument) {
  if (isObject$k(argument))
    return argument;
  throw TypeError$i(String$4(argument) + " is not an object");
};
var global$F = global$V;
var DESCRIPTORS$e = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$t = anObject$u;
var toPropertyKey$2 = toPropertyKey$4;
var TypeError$h = global$F.TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$t(O);
  P = toPropertyKey$2(P);
  anObject$t(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty$1(O, P, Attributes);
} : $defineProperty$1 : function defineProperty2(O, P, Attributes) {
  anObject$t(O);
  P = toPropertyKey$2(P);
  anObject$t(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty$1(O, P, Attributes);
    } catch (error) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw TypeError$h("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$d = descriptors;
var definePropertyModule$5 = objectDefineProperty;
var createPropertyDescriptor$5 = createPropertyDescriptor$7;
var createNonEnumerableProperty$8 = DESCRIPTORS$d ? function(object, key, value) {
  return definePropertyModule$5.f(object, key, createPropertyDescriptor$5(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var global$E = global$V;
var apply$6 = functionApply;
var uncurryThis$p = functionUncurryThis;
var isCallable$e = isCallable$l;
var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
var isForced$1 = isForced_1;
var path$s = path$u;
var bind$o = functionBindContext;
var createNonEnumerableProperty$7 = createNonEnumerableProperty$8;
var hasOwn$h = hasOwnProperty_1;
var wrapConstructor = function(NativeConstructor) {
  var Wrapper = function(a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();
        case 1:
          return new NativeConstructor(a);
        case 2:
          return new NativeConstructor(a, b);
      }
      return new NativeConstructor(a, b, c);
    }
    return apply$6(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? global$E : STATIC ? global$E[TARGET] : (global$E[TARGET] || {}).prototype;
  var target = GLOBAL ? path$s : path$s[TARGET] || createNonEnumerableProperty$7(path$s, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED2, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
  for (key in source) {
    FORCED2 = isForced$1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    USE_NATIVE = !FORCED2 && nativeSource && hasOwn$h(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE)
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$7(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else
        nativeProperty = nativeSource[key];
    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)
      continue;
    if (options.bind && USE_NATIVE)
      resultProperty = bind$o(sourceProperty, global$E);
    else if (options.wrap && USE_NATIVE)
      resultProperty = wrapConstructor(sourceProperty);
    else if (PROTO && isCallable$e(sourceProperty))
      resultProperty = uncurryThis$p(sourceProperty);
    else
      resultProperty = sourceProperty;
    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$7(resultProperty, "sham", true);
    }
    createNonEnumerableProperty$7(target, key, resultProperty);
    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + "Prototype";
      if (!hasOwn$h(path$s, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty$7(path$s, VIRTUAL_PROTOTYPE, {});
      }
      createNonEnumerableProperty$7(path$s[VIRTUAL_PROTOTYPE], key, sourceProperty);
      if (options.real && targetPrototype && !targetPrototype[key]) {
        createNonEnumerableProperty$7(targetPrototype, key, sourceProperty);
      }
    }
  }
};
var $$10 = _export;
var fails$m = fails$u;
var toIndexedObject$9 = toIndexedObject$b;
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$c = descriptors;
var FAILS_ON_PRIMITIVES$4 = fails$m(function() {
  nativeGetOwnPropertyDescriptor$1(1);
});
var FORCED$6 = !DESCRIPTORS$c || FAILS_ON_PRIMITIVES$4;
$$10({ target: "Object", stat: true, forced: FORCED$6, sham: !DESCRIPTORS$c }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor2(it, key) {
    return nativeGetOwnPropertyDescriptor$1(toIndexedObject$9(it), key);
  }
});
var path$r = path$u;
var Object$6 = path$r.Object;
var getOwnPropertyDescriptor$6 = getOwnPropertyDescriptor$9.exports = function getOwnPropertyDescriptor3(it, key) {
  return Object$6.getOwnPropertyDescriptor(it, key);
};
if (Object$6.getOwnPropertyDescriptor.sham)
  getOwnPropertyDescriptor$6.sham = true;
var parent$1d = getOwnPropertyDescriptor$9.exports;
var getOwnPropertyDescriptor$5 = parent$1d;
var getOwnPropertyDescriptor$4 = getOwnPropertyDescriptor$5;
var defineProperty$e = { exports: {} };
var $$$ = _export;
var DESCRIPTORS$b = descriptors;
var defineProperty$d = objectDefineProperty.f;
$$$({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty$d, sham: !DESCRIPTORS$b }, {
  defineProperty: defineProperty$d
});
var path$q = path$u;
var Object$5 = path$q.Object;
var defineProperty$c = defineProperty$e.exports = function defineProperty3(it, key, desc) {
  return Object$5.defineProperty(it, key, desc);
};
if (Object$5.defineProperty.sham)
  defineProperty$c.sham = true;
var parent$1c = defineProperty$e.exports;
var defineProperty$b = parent$1c;
var defineProperty$a = defineProperty$b;
var _typeof$1 = { exports: {} };
var classof$e = classofRaw$1;
var isArray$b = Array.isArray || function isArray(argument) {
  return classof$e(argument) == "Array";
};
var ceil = Math.ceil;
var floor$2 = Math.floor;
var toIntegerOrInfinity$4 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : (number > 0 ? floor$2 : ceil)(number);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var min$3 = Math.min;
var toLength$2 = function(argument) {
  return argument > 0 ? min$3(toIntegerOrInfinity$3(argument), 9007199254740991) : 0;
};
var toLength$1 = toLength$2;
var lengthOfArrayLike$a = function(obj) {
  return toLength$1(obj.length);
};
var toPropertyKey$1 = toPropertyKey$4;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$4 = createPropertyDescriptor$7;
var createProperty$6 = function(object, key, value) {
  var propertyKey = toPropertyKey$1(key);
  if (propertyKey in object)
    definePropertyModule$4.f(object, propertyKey, createPropertyDescriptor$4(0, value));
  else
    object[propertyKey] = value;
};
var wellKnownSymbol$k = wellKnownSymbol$m;
var TO_STRING_TAG$4 = wellKnownSymbol$k("toStringTag");
var test$1 = {};
test$1[TO_STRING_TAG$4] = "z";
var toStringTagSupport = String(test$1) === "[object z]";
var global$D = global$V;
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$d = isCallable$l;
var classofRaw = classofRaw$1;
var wellKnownSymbol$j = wellKnownSymbol$m;
var TO_STRING_TAG$3 = wellKnownSymbol$j("toStringTag");
var Object$4 = global$D.Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error) {
  }
};
var classof$d = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object$4(it), TO_STRING_TAG$3)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable$d(O.callee) ? "Arguments" : result;
};
var uncurryThis$o = functionUncurryThis;
var isCallable$c = isCallable$l;
var store$1 = sharedStore;
var functionToString = uncurryThis$o(Function.toString);
if (!isCallable$c(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString(it);
  };
}
var inspectSource$3 = store$1.inspectSource;
var uncurryThis$n = functionUncurryThis;
var fails$l = fails$u;
var isCallable$b = isCallable$l;
var classof$c = classof$d;
var getBuiltIn$c = getBuiltIn$f;
var inspectSource$2 = inspectSource$3;
var noop$1 = function() {
};
var empty = [];
var construct$8 = getBuiltIn$c("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$n(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$b(argument))
    return false;
  try {
    construct$8(noop$1, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$b(argument))
    return false;
  switch (classof$c(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$2(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$4 = !construct$8 || fails$l(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var global$C = global$V;
var isArray$a = isArray$b;
var isConstructor$3 = isConstructor$4;
var isObject$j = isObject$o;
var wellKnownSymbol$i = wellKnownSymbol$m;
var SPECIES$5 = wellKnownSymbol$i("species");
var Array$5 = global$C.Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C;
  if (isArray$a(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor$3(C) && (C === Array$5 || isArray$a(C.prototype)))
      C = void 0;
    else if (isObject$j(C)) {
      C = C[SPECIES$5];
      if (C === null)
        C = void 0;
    }
  }
  return C === void 0 ? Array$5 : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$3 = function(originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};
var fails$k = fails$u;
var wellKnownSymbol$h = wellKnownSymbol$m;
var V8_VERSION$2 = engineV8Version;
var SPECIES$4 = wellKnownSymbol$h("species");
var arrayMethodHasSpeciesSupport$5 = function(METHOD_NAME) {
  return V8_VERSION$2 >= 51 || !fails$k(function() {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$4] = function() {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};
var $$_ = _export;
var global$B = global$V;
var fails$j = fails$u;
var isArray$9 = isArray$b;
var isObject$i = isObject$o;
var toObject$a = toObject$c;
var lengthOfArrayLike$9 = lengthOfArrayLike$a;
var createProperty$5 = createProperty$6;
var arraySpeciesCreate$2 = arraySpeciesCreate$3;
var arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;
var wellKnownSymbol$g = wellKnownSymbol$m;
var V8_VERSION$1 = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$g("isConcatSpreadable");
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
var TypeError$g = global$B.TypeError;
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$1 >= 51 || !fails$j(function() {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport$4("concat");
var isConcatSpreadable = function(O) {
  if (!isObject$i(O))
    return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray$9(O);
};
var FORCED$5 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
$$_({ target: "Array", proto: true, forced: FORCED$5 }, {
  concat: function concat(arg) {
    var O = toObject$a(this);
    var A = arraySpeciesCreate$2(O, 0);
    var n2 = 0;
    var i2, k, length, len, E;
    for (i2 = -1, length = arguments.length; i2 < length; i2++) {
      E = i2 === -1 ? O : arguments[i2];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$9(E);
        if (n2 + len > MAX_SAFE_INTEGER$1)
          throw TypeError$g(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n2++)
          if (k in E)
            createProperty$5(A, n2, E[k]);
      } else {
        if (n2 >= MAX_SAFE_INTEGER$1)
          throw TypeError$g(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty$5(A, n2++, E);
      }
    }
    A.length = n2;
    return A;
  }
});
var global$A = global$V;
var classof$b = classof$d;
var String$3 = global$A.String;
var toString$a = function(argument) {
  if (classof$b(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return String$3(argument);
};
var objectDefineProperties = {};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var max$3 = Math.max;
var min$2 = Math.min;
var toAbsoluteIndex$4 = function(index, length) {
  var integer = toIntegerOrInfinity$2(index);
  return integer < 0 ? max$3(integer + length, 0) : min$2(integer, length);
};
var toIndexedObject$8 = toIndexedObject$b;
var toAbsoluteIndex$3 = toAbsoluteIndex$4;
var lengthOfArrayLike$8 = lengthOfArrayLike$a;
var createMethod$5 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$8($this);
    var length = lengthOfArrayLike$8(O);
    var index = toAbsoluteIndex$3(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value)
          return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$5(true),
  indexOf: createMethod$5(false)
};
var hiddenKeys$6 = {};
var uncurryThis$m = functionUncurryThis;
var hasOwn$g = hasOwnProperty_1;
var toIndexedObject$7 = toIndexedObject$b;
var indexOf$7 = arrayIncludes.indexOf;
var hiddenKeys$5 = hiddenKeys$6;
var push$8 = uncurryThis$m([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject$7(object);
  var i2 = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$g(hiddenKeys$5, key) && hasOwn$g(O, key) && push$8(result, key);
  while (names.length > i2)
    if (hasOwn$g(O, key = names[i2++])) {
      ~indexOf$7(result, key) || push$8(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var objectKeys$4 = Object.keys || function keys(O) {
  return internalObjectKeys$1(O, enumBugKeys$2);
};
var DESCRIPTORS$a = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$3 = objectDefineProperty;
var anObject$s = anObject$u;
var toIndexedObject$6 = toIndexedObject$b;
var objectKeys$3 = objectKeys$4;
objectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$s(O);
  var props = toIndexedObject$6(Properties);
  var keys4 = objectKeys$3(Properties);
  var length = keys4.length;
  var index = 0;
  var key;
  while (length > index)
    definePropertyModule$3.f(O, key = keys4[index++], props[key]);
  return O;
};
var getBuiltIn$b = getBuiltIn$f;
var html$2 = getBuiltIn$b("document", "documentElement");
var shared$2 = shared$4.exports;
var uid$2 = uid$4;
var keys$8 = shared$2("keys");
var sharedKey$4 = function(key) {
  return keys$8[key] || (keys$8[key] = uid$2(key));
};
var anObject$r = anObject$u;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$4 = hiddenKeys$6;
var html$1 = html$2;
var documentCreateElement = documentCreateElement$1;
var sharedKey$3 = sharedKey$4;
var GT = ">";
var LT = "<";
var PROTOTYPE$1 = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$3("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html$1.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys$1.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];
  return NullProtoObject();
};
hiddenKeys$4[IE_PROTO$1] = true;
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE$1] = anObject$r(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE$1] = null;
    result[IE_PROTO$1] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule$1.f(result, Properties);
};
var objectGetOwnPropertyNames = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$3 = enumBugKeys.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys$3);
};
var objectGetOwnPropertyNamesExternal = {};
var global$z = global$V;
var toAbsoluteIndex$2 = toAbsoluteIndex$4;
var lengthOfArrayLike$7 = lengthOfArrayLike$a;
var createProperty$4 = createProperty$6;
var Array$4 = global$z.Array;
var max$2 = Math.max;
var arraySliceSimple = function(O, start, end) {
  var length = lengthOfArrayLike$7(O);
  var k = toAbsoluteIndex$2(start, length);
  var fin = toAbsoluteIndex$2(end === void 0 ? length : end, length);
  var result = Array$4(max$2(fin - k, 0));
  for (var n2 = 0; k < fin; k++, n2++)
    createProperty$4(result, n2, O[k]);
  result.length = n2;
  return result;
};
var classof$a = classofRaw$1;
var toIndexedObject$5 = toIndexedObject$b;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$7 = arraySliceSimple;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
  try {
    return $getOwnPropertyNames$1(it);
  } catch (error) {
    return arraySlice$7(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it) {
  return windowNames && classof$a(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames$1(toIndexedObject$5(it));
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var uncurryThis$l = functionUncurryThis;
var arraySlice$6 = uncurryThis$l([].slice);
var createNonEnumerableProperty$6 = createNonEnumerableProperty$8;
var redefine$4 = function(target, key, value, options) {
  if (options && options.enumerable)
    target[key] = value;
  else
    createNonEnumerableProperty$6(target, key, value);
};
var wellKnownSymbolWrapped = {};
var wellKnownSymbol$f = wellKnownSymbol$m;
wellKnownSymbolWrapped.f = wellKnownSymbol$f;
var path$p = path$u;
var hasOwn$f = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$9 = objectDefineProperty.f;
var defineWellKnownSymbol$l = function(NAME) {
  var Symbol2 = path$p.Symbol || (path$p.Symbol = {});
  if (!hasOwn$f(Symbol2, NAME))
    defineProperty$9(Symbol2, NAME, {
      value: wrappedWellKnownSymbolModule$1.f(NAME)
    });
};
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$9 = classof$d;
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
  return "[object " + classof$9(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineProperty$8 = objectDefineProperty.f;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$8;
var hasOwn$e = hasOwnProperty_1;
var toString$9 = objectToString;
var wellKnownSymbol$e = wellKnownSymbol$m;
var TO_STRING_TAG$2 = wellKnownSymbol$e("toStringTag");
var setToStringTag$6 = function(it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;
    if (!hasOwn$e(target, TO_STRING_TAG$2)) {
      defineProperty$8(target, TO_STRING_TAG$2, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty$5(target, "toString", toString$9);
    }
  }
};
var global$y = global$V;
var isCallable$a = isCallable$l;
var inspectSource$1 = inspectSource$3;
var WeakMap$2 = global$y.WeakMap;
var nativeWeakMap = isCallable$a(WeakMap$2) && /native code/.test(inspectSource$1(WeakMap$2));
var NATIVE_WEAK_MAP$1 = nativeWeakMap;
var global$x = global$V;
var uncurryThis$k = functionUncurryThis;
var isObject$h = isObject$o;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$8;
var hasOwn$d = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$4;
var hiddenKeys$2 = hiddenKeys$6;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$f = global$x.TypeError;
var WeakMap$1 = global$x.WeakMap;
var set$5, get$8, has;
var enforce = function(it) {
  return has(it) ? get$8(it) : set$5(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$h(it) || (state = get$8(it)).type !== TYPE) {
      throw TypeError$f("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP$1 || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap$1());
  var wmget = uncurryThis$k(store.get);
  var wmhas = uncurryThis$k(store.has);
  var wmset = uncurryThis$k(store.set);
  set$5 = function(it, metadata) {
    if (wmhas(store, it))
      throw new TypeError$f(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get$8 = function(it) {
    return wmget(store, it) || {};
  };
  has = function(it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$2("state");
  hiddenKeys$2[STATE] = true;
  set$5 = function(it, metadata) {
    if (hasOwn$d(it, STATE))
      throw new TypeError$f(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$4(it, STATE, metadata);
    return metadata;
  };
  get$8 = function(it) {
    return hasOwn$d(it, STATE) ? it[STATE] : {};
  };
  has = function(it) {
    return hasOwn$d(it, STATE);
  };
}
var internalState = {
  set: set$5,
  get: get$8,
  has,
  enforce,
  getterFor
};
var bind$n = functionBindContext;
var uncurryThis$j = functionUncurryThis;
var IndexedObject$2 = indexedObject;
var toObject$9 = toObject$c;
var lengthOfArrayLike$6 = lengthOfArrayLike$a;
var arraySpeciesCreate$1 = arraySpeciesCreate$3;
var push$7 = uncurryThis$j([].push);
var createMethod$4 = function(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O = toObject$9($this);
    var self2 = IndexedObject$2(O);
    var boundFunction = bind$n(callbackfn, that);
    var length = lengthOfArrayLike$6(self2);
    var index = 0;
    var create5 = specificCreate || arraySpeciesCreate$1;
    var target = IS_MAP ? create5($this, length) : IS_FILTER || IS_FILTER_REJECT ? create5($this, 0) : void 0;
    var value, result;
    for (; length > index; index++)
      if (NO_HOLES || index in self2) {
        value = self2[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP)
            target[index] = result;
          else if (result)
            switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index;
              case 2:
                push$7(target, value);
            }
          else
            switch (TYPE) {
              case 4:
                return false;
              case 7:
                push$7(target, value);
            }
        }
      }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  forEach: createMethod$4(0),
  map: createMethod$4(1),
  filter: createMethod$4(2),
  some: createMethod$4(3),
  every: createMethod$4(4),
  find: createMethod$4(5),
  findIndex: createMethod$4(6),
  filterReject: createMethod$4(7)
};
var $$Z = _export;
var global$w = global$V;
var getBuiltIn$a = getBuiltIn$f;
var apply$5 = functionApply;
var call$k = functionCall;
var uncurryThis$i = functionUncurryThis;
var DESCRIPTORS$9 = descriptors;
var NATIVE_SYMBOL = nativeSymbol;
var fails$i = fails$u;
var hasOwn$c = hasOwnProperty_1;
var isArray$8 = isArray$b;
var isCallable$9 = isCallable$l;
var isObject$g = isObject$o;
var isPrototypeOf$l = objectIsPrototypeOf;
var isSymbol = isSymbol$3;
var anObject$q = anObject$u;
var toObject$8 = toObject$c;
var toIndexedObject$4 = toIndexedObject$b;
var toPropertyKey = toPropertyKey$4;
var $toString = toString$a;
var createPropertyDescriptor$3 = createPropertyDescriptor$7;
var nativeObjectCreate = objectCreate;
var objectKeys$2 = objectKeys$4;
var getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$3 = objectGetOwnPropertyDescriptor;
var definePropertyModule$2 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var arraySlice$5 = arraySlice$6;
var redefine$3 = redefine$4;
var shared = shared$4.exports;
var sharedKey$1 = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$6;
var uid$1 = uid$4;
var wellKnownSymbol$d = wellKnownSymbol$m;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$k = defineWellKnownSymbol$l;
var setToStringTag$5 = setToStringTag$6;
var InternalStateModule$6 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey$1("hidden");
var SYMBOL = "Symbol";
var PROTOTYPE = "prototype";
var TO_PRIMITIVE = wellKnownSymbol$d("toPrimitive");
var setInternalState$6 = InternalStateModule$6.set;
var getInternalState$3 = InternalStateModule$6.getterFor(SYMBOL);
var ObjectPrototype$2 = Object[PROTOTYPE];
var $Symbol = global$w.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError$e = global$w.TypeError;
var QObject = global$w.QObject;
var $stringify$1 = getBuiltIn$a("JSON", "stringify");
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule$3.f;
var nativeDefineProperty = definePropertyModule$2.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
var push$6 = uncurryThis$i([].push);
var AllSymbols = shared("symbols");
var ObjectPrototypeSymbols = shared("op-symbols");
var StringToSymbolRegistry = shared("string-to-symbol-registry");
var SymbolToStringRegistry = shared("symbol-to-string-registry");
var WellKnownSymbolsStore = shared("wks");
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var setSymbolDescriptor = DESCRIPTORS$9 && fails$i(function() {
  return nativeObjectCreate(nativeDefineProperty({}, "a", {
    get: function() {
      return nativeDefineProperty(this, "a", { value: 7 }).a;
    }
  })).a != 7;
}) ? function(O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype$2, P);
  if (ObjectPrototypeDescriptor)
    delete ObjectPrototype$2[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$2) {
    nativeDefineProperty(ObjectPrototype$2, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;
var wrap$1 = function(tag, description) {
  var symbol2 = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState$6(symbol2, {
    type: SYMBOL,
    tag,
    description
  });
  if (!DESCRIPTORS$9)
    symbol2.description = description;
  return symbol2;
};
var $defineProperty = function defineProperty4(O, P, Attributes) {
  if (O === ObjectPrototype$2)
    $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject$q(O);
  var key = toPropertyKey(P);
  anObject$q(Attributes);
  if (hasOwn$c(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn$c(O, HIDDEN))
        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor$3(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn$c(O, HIDDEN) && O[HIDDEN][key])
        O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor$3(0, false) });
    }
    return setSymbolDescriptor(O, key, Attributes);
  }
  return nativeDefineProperty(O, key, Attributes);
};
var $defineProperties = function defineProperties2(O, Properties) {
  anObject$q(O);
  var properties = toIndexedObject$4(Properties);
  var keys4 = objectKeys$2(properties).concat($getOwnPropertySymbols(properties));
  $forEach$1(keys4, function(key) {
    if (!DESCRIPTORS$9 || call$k($propertyIsEnumerable$1, properties, key))
      $defineProperty(O, key, properties[key]);
  });
  return O;
};
var $create = function create2(O, Properties) {
  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};
var $propertyIsEnumerable$1 = function propertyIsEnumerable2(V) {
  var P = toPropertyKey(V);
  var enumerable = call$k(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype$2 && hasOwn$c(AllSymbols, P) && !hasOwn$c(ObjectPrototypeSymbols, P))
    return false;
  return enumerable || !hasOwn$c(this, P) || !hasOwn$c(AllSymbols, P) || hasOwn$c(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor4(O, P) {
  var it = toIndexedObject$4(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype$2 && hasOwn$c(AllSymbols, key) && !hasOwn$c(ObjectPrototypeSymbols, key))
    return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn$c(AllSymbols, key) && !(hasOwn$c(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};
var $getOwnPropertyNames = function getOwnPropertyNames3(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function(key) {
    if (!hasOwn$c(AllSymbols, key) && !hasOwn$c(hiddenKeys$1, key))
      push$6(result, key);
  });
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$2;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$4(O));
  var result = [];
  $forEach$1(names, function(key) {
    if (hasOwn$c(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$c(ObjectPrototype$2, key))) {
      push$6(result, AllSymbols[key]);
    }
  });
  return result;
};
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol2() {
    if (isPrototypeOf$l(SymbolPrototype, this))
      throw TypeError$e("Symbol is not a constructor");
    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
    var tag = uid$1(description);
    var setter = function(value) {
      if (this === ObjectPrototype$2)
        call$k(setter, ObjectPrototypeSymbols, value);
      if (hasOwn$c(this, HIDDEN) && hasOwn$c(this[HIDDEN], tag))
        this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor$3(1, value));
    };
    if (DESCRIPTORS$9 && USE_SETTER)
      setSymbolDescriptor(ObjectPrototype$2, tag, { configurable: true, set: setter });
    return wrap$1(tag, description);
  };
  SymbolPrototype = $Symbol[PROTOTYPE];
  redefine$3(SymbolPrototype, "toString", function toString3() {
    return getInternalState$3(this).tag;
  });
  redefine$3($Symbol, "withoutSetter", function(description) {
    return wrap$1(uid$1(description), description);
  });
  propertyIsEnumerableModule$1.f = $propertyIsEnumerable$1;
  definePropertyModule$2.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule$3.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;
  wrappedWellKnownSymbolModule.f = function(name) {
    return wrap$1(wellKnownSymbol$d(name), name);
  };
  if (DESCRIPTORS$9) {
    nativeDefineProperty(SymbolPrototype, "description", {
      configurable: true,
      get: function description() {
        return getInternalState$3(this).description;
      }
    });
  }
}
$$Z({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});
$forEach$1(objectKeys$2(WellKnownSymbolsStore), function(name) {
  defineWellKnownSymbol$k(name);
});
$$Z({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  "for": function(key) {
    var string = $toString(key);
    if (hasOwn$c(StringToSymbolRegistry, string))
      return StringToSymbolRegistry[string];
    var symbol2 = $Symbol(string);
    StringToSymbolRegistry[string] = symbol2;
    SymbolToStringRegistry[symbol2] = string;
    return symbol2;
  },
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym))
      throw TypeError$e(sym + " is not a symbol");
    if (hasOwn$c(SymbolToStringRegistry, sym))
      return SymbolToStringRegistry[sym];
  },
  useSetter: function() {
    USE_SETTER = true;
  },
  useSimple: function() {
    USE_SETTER = false;
  }
});
$$Z({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS$9 }, {
  create: $create,
  defineProperty: $defineProperty,
  defineProperties: $defineProperties,
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$$Z({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
  getOwnPropertyNames: $getOwnPropertyNames,
  getOwnPropertySymbols: $getOwnPropertySymbols
});
$$Z({ target: "Object", stat: true, forced: fails$i(function() {
  getOwnPropertySymbolsModule$2.f(1);
}) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols2(it) {
    return getOwnPropertySymbolsModule$2.f(toObject$8(it));
  }
});
if ($stringify$1) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails$i(function() {
    var symbol2 = $Symbol();
    return $stringify$1([symbol2]) != "[null]" || $stringify$1({ a: symbol2 }) != "{}" || $stringify$1(Object(symbol2)) != "{}";
  });
  $$Z({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
    stringify: function stringify3(it, replacer2, space) {
      var args = arraySlice$5(arguments);
      var $replacer = replacer2;
      if (!isObject$g(replacer2) && it === void 0 || isSymbol(it))
        return;
      if (!isArray$8(replacer2))
        replacer2 = function(key, value) {
          if (isCallable$9($replacer))
            value = call$k($replacer, this, key, value);
          if (!isSymbol(value))
            return value;
        };
      args[1] = replacer2;
      return apply$5($stringify$1, null, args);
    }
  });
}
if (!SymbolPrototype[TO_PRIMITIVE]) {
  var valueOf = SymbolPrototype.valueOf;
  redefine$3(SymbolPrototype, TO_PRIMITIVE, function(hint) {
    return call$k(valueOf, this);
  });
}
setToStringTag$5($Symbol, SYMBOL);
hiddenKeys$1[HIDDEN] = true;
var defineWellKnownSymbol$j = defineWellKnownSymbol$l;
defineWellKnownSymbol$j("asyncIterator");
var defineWellKnownSymbol$i = defineWellKnownSymbol$l;
defineWellKnownSymbol$i("hasInstance");
var defineWellKnownSymbol$h = defineWellKnownSymbol$l;
defineWellKnownSymbol$h("isConcatSpreadable");
var defineWellKnownSymbol$g = defineWellKnownSymbol$l;
defineWellKnownSymbol$g("iterator");
var defineWellKnownSymbol$f = defineWellKnownSymbol$l;
defineWellKnownSymbol$f("match");
var defineWellKnownSymbol$e = defineWellKnownSymbol$l;
defineWellKnownSymbol$e("matchAll");
var defineWellKnownSymbol$d = defineWellKnownSymbol$l;
defineWellKnownSymbol$d("replace");
var defineWellKnownSymbol$c = defineWellKnownSymbol$l;
defineWellKnownSymbol$c("search");
var defineWellKnownSymbol$b = defineWellKnownSymbol$l;
defineWellKnownSymbol$b("species");
var defineWellKnownSymbol$a = defineWellKnownSymbol$l;
defineWellKnownSymbol$a("split");
var defineWellKnownSymbol$9 = defineWellKnownSymbol$l;
defineWellKnownSymbol$9("toPrimitive");
var defineWellKnownSymbol$8 = defineWellKnownSymbol$l;
defineWellKnownSymbol$8("toStringTag");
var defineWellKnownSymbol$7 = defineWellKnownSymbol$l;
defineWellKnownSymbol$7("unscopables");
var global$v = global$V;
var setToStringTag$4 = setToStringTag$6;
setToStringTag$4(global$v.JSON, "JSON", true);
var path$o = path$u;
var symbol$5 = path$o.Symbol;
var iterators = {};
var DESCRIPTORS$8 = descriptors;
var hasOwn$b = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
var getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$b(FunctionPrototype$1, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || DESCRIPTORS$8 && getDescriptor(FunctionPrototype$1, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var fails$h = fails$u;
var correctPrototypeGetter = !fails$h(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var global$u = global$V;
var hasOwn$a = hasOwnProperty_1;
var isCallable$8 = isCallable$l;
var toObject$7 = toObject$c;
var sharedKey = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var Object$3 = global$u.Object;
var ObjectPrototype$1 = Object$3.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? Object$3.getPrototypeOf : function(O) {
  var object = toObject$7(O);
  if (hasOwn$a(object, IE_PROTO))
    return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$8(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof Object$3 ? ObjectPrototype$1 : null;
};
var fails$g = fails$u;
var isCallable$7 = isCallable$l;
var create$b = objectCreate;
var getPrototypeOf$a = objectGetPrototypeOf;
var redefine$2 = redefine$4;
var wellKnownSymbol$c = wellKnownSymbol$m;
var ITERATOR$5 = wellKnownSymbol$c("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$a(getPrototypeOf$a(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == void 0 || fails$g(function() {
  var test2 = {};
  return IteratorPrototype$1[ITERATOR$5].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$1 = {};
else
  IteratorPrototype$1 = create$b(IteratorPrototype$1);
if (!isCallable$7(IteratorPrototype$1[ITERATOR$5])) {
  redefine$2(IteratorPrototype$1, ITERATOR$5, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$1,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$a = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$7;
var setToStringTag$3 = setToStringTag$6;
var Iterators$5 = iterators;
var returnThis$1 = function() {
  return this;
};
var createIteratorConstructor$1 = function(IteratorConstructor, NAME, next2, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create$a(IteratorPrototype, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next2) });
  setToStringTag$3(IteratorConstructor, TO_STRING_TAG2, false, true);
  Iterators$5[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var global$t = global$V;
var isCallable$6 = isCallable$l;
var String$2 = global$t.String;
var TypeError$d = global$t.TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$6(argument))
    return argument;
  throw TypeError$d("Can't set " + String$2(argument) + " as a prototype");
};
var uncurryThis$h = functionUncurryThis;
var anObject$p = anObject$u;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThis$h(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O, proto) {
    anObject$p(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O, proto);
    else
      O.__proto__ = proto;
    return O;
  };
}() : void 0);
var $$Y = _export;
var call$j = functionCall;
var FunctionName = functionName;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$9 = objectGetPrototypeOf;
var setToStringTag$2 = setToStringTag$6;
var redefine$1 = redefine$4;
var wellKnownSymbol$b = wellKnownSymbol$m;
var Iterators$4 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4 = wellKnownSymbol$b("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var defineIterator$3 = function(Iterable, NAME, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME, next2);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys4() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries3() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf$9(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      setToStringTag$2(CurrentIteratorPrototype, TO_STRING_TAG2, true, true);
      Iterators$4[TO_STRING_TAG2] = returnThis;
    }
  }
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$j(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$Y({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (FORCED2 && IterablePrototype[ITERATOR$4] !== defaultIterator) {
    redefine$1(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });
  }
  Iterators$4[NAME] = defaultIterator;
  return methods;
};
var toIndexedObject$3 = toIndexedObject$b;
var Iterators$3 = iterators;
var InternalStateModule$5 = internalState;
objectDefineProperty.f;
var defineIterator$2 = defineIterator$3;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(ARRAY_ITERATOR);
defineIterator$2(Array, "Array", function(iterated, kind) {
  setInternalState$5(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$3(iterated),
    index: 0,
    kind
  });
}, function() {
  var state = getInternalState$2(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = void 0;
    return { value: void 0, done: true };
  }
  if (kind == "keys")
    return { value: index, done: false };
  if (kind == "values")
    return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, "values");
Iterators$3.Arguments = Iterators$3.Array;
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var DOMIterables$4 = domIterables;
var global$s = global$V;
var classof$8 = classof$d;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$8;
var Iterators$2 = iterators;
var wellKnownSymbol$a = wellKnownSymbol$m;
var TO_STRING_TAG$1 = wellKnownSymbol$a("toStringTag");
for (var COLLECTION_NAME in DOMIterables$4) {
  var Collection = global$s[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype && classof$8(CollectionPrototype) !== TO_STRING_TAG$1) {
    createNonEnumerableProperty$3(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);
  }
  Iterators$2[COLLECTION_NAME] = Iterators$2.Array;
}
var parent$1b = symbol$5;
var symbol$4 = parent$1b;
var parent$1a = symbol$4;
var symbol$3 = parent$1a;
var defineWellKnownSymbol$6 = defineWellKnownSymbol$l;
defineWellKnownSymbol$6("asyncDispose");
var defineWellKnownSymbol$5 = defineWellKnownSymbol$l;
defineWellKnownSymbol$5("dispose");
var defineWellKnownSymbol$4 = defineWellKnownSymbol$l;
defineWellKnownSymbol$4("matcher");
var defineWellKnownSymbol$3 = defineWellKnownSymbol$l;
defineWellKnownSymbol$3("metadata");
var defineWellKnownSymbol$2 = defineWellKnownSymbol$l;
defineWellKnownSymbol$2("observable");
var defineWellKnownSymbol$1 = defineWellKnownSymbol$l;
defineWellKnownSymbol$1("patternMatch");
var defineWellKnownSymbol = defineWellKnownSymbol$l;
defineWellKnownSymbol("replaceAll");
var parent$19 = symbol$3;
var symbol$2 = parent$19;
var symbol$1 = symbol$2;
var uncurryThis$g = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$8 = toString$a;
var requireObjectCoercible$3 = requireObjectCoercible$6;
var charAt$2 = uncurryThis$g("".charAt);
var charCodeAt$1 = uncurryThis$g("".charCodeAt);
var stringSlice$1 = uncurryThis$g("".slice);
var createMethod$3 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S = toString$8(requireObjectCoercible$3($this));
    var position = toIntegerOrInfinity$1(pos);
    var size2 = S.length;
    var first, second;
    if (position < 0 || position >= size2)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt$1(S, position);
    return first < 55296 || first > 56319 || position + 1 === size2 || (second = charCodeAt$1(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S, position) : first : CONVERT_TO_STRING ? stringSlice$1(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  codeAt: createMethod$3(false),
  charAt: createMethod$3(true)
};
var charAt$1 = stringMultibyte.charAt;
var toString$7 = toString$a;
var InternalStateModule$4 = internalState;
var defineIterator$1 = defineIterator$3;
var STRING_ITERATOR = "String Iterator";
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$1 = InternalStateModule$4.getterFor(STRING_ITERATOR);
defineIterator$1(String, "String", function(iterated) {
  setInternalState$4(this, {
    type: STRING_ITERATOR,
    string: toString$7(iterated),
    index: 0
  });
}, function next() {
  var state = getInternalState$1(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length)
    return { value: void 0, done: true };
  point = charAt$1(string, index);
  state.index += point.length;
  return { value: point, done: false };
});
var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var iterator$4 = WrappedWellKnownSymbolModule.f("iterator");
var parent$18 = iterator$4;
var iterator$3 = parent$18;
var parent$17 = iterator$3;
var iterator$2 = parent$17;
var parent$16 = iterator$2;
var iterator$1 = parent$16;
var iterator = iterator$1;
(function(module) {
  var _Symbol2 = symbol$1;
  var _Symbol$iterator = iterator;
  function _typeof3(obj) {
    "@babel/helpers - typeof";
    if (typeof _Symbol2 === "function" && typeof _Symbol$iterator === "symbol") {
      module.exports = _typeof3 = function _typeof4(obj2) {
        return typeof obj2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _typeof3 = function _typeof4(obj2) {
        return obj2 && typeof _Symbol2 === "function" && obj2.constructor === _Symbol2 && obj2 !== _Symbol2.prototype ? "symbol" : typeof obj2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }
    return _typeof3(obj);
  }
  module.exports = _typeof3;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(_typeof$1);
var redefine = redefine$4;
var redefineAll$4 = function(target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key])
      target[key] = src[key];
    else
      redefine(target, key, src[key], options);
  }
  return target;
};
var internalMetadata = { exports: {} };
var fails$f = fails$u;
var arrayBufferNonExtensible = fails$f(function() {
  if (typeof ArrayBuffer == "function") {
    var buffer2 = new ArrayBuffer(8);
    if (Object.isExtensible(buffer2))
      Object.defineProperty(buffer2, "a", { value: 8 });
  }
});
var fails$e = fails$u;
var isObject$f = isObject$o;
var classof$7 = classofRaw$1;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$3 = fails$e(function() {
  $isExtensible(1);
});
var objectIsExtensible = FAILS_ON_PRIMITIVES$3 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$f(it))
    return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$7(it) == "ArrayBuffer")
    return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;
var fails$d = fails$u;
var freezing = !fails$d(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var $$X = _export;
var uncurryThis$f = functionUncurryThis;
var hiddenKeys = hiddenKeys$6;
var isObject$e = isObject$o;
var hasOwn$9 = hasOwnProperty_1;
var defineProperty$7 = objectDefineProperty.f;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible$1 = objectIsExtensible;
var uid = uid$4;
var FREEZING$1 = freezing;
var REQUIRED = false;
var METADATA = uid("meta");
var id$1 = 0;
var setMetadata = function(it) {
  defineProperty$7(it, METADATA, { value: {
    objectID: "O" + id$1++,
    weakData: {}
  } });
};
var fastKey$1 = function(it, create5) {
  if (!isObject$e(it))
    return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
  if (!hasOwn$9(it, METADATA)) {
    if (!isExtensible$1(it))
      return "F";
    if (!create5)
      return "E";
    setMetadata(it);
  }
  return it[METADATA].objectID;
};
var getWeakData$1 = function(it, create5) {
  if (!hasOwn$9(it, METADATA)) {
    if (!isExtensible$1(it))
      return true;
    if (!create5)
      return false;
    setMetadata(it);
  }
  return it[METADATA].weakData;
};
var onFreeze$1 = function(it) {
  if (FREEZING$1 && REQUIRED && isExtensible$1(it) && !hasOwn$9(it, METADATA))
    setMetadata(it);
  return it;
};
var enable = function() {
  meta.enable = function() {
  };
  REQUIRED = true;
  var getOwnPropertyNames4 = getOwnPropertyNamesModule$1.f;
  var splice3 = uncurryThis$f([].splice);
  var test2 = {};
  test2[METADATA] = 1;
  if (getOwnPropertyNames4(test2).length) {
    getOwnPropertyNamesModule$1.f = function(it) {
      var result = getOwnPropertyNames4(it);
      for (var i2 = 0, length = result.length; i2 < length; i2++) {
        if (result[i2] === METADATA) {
          splice3(result, i2, 1);
          break;
        }
      }
      return result;
    };
    $$X({ target: "Object", stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze: onFreeze$1
};
hiddenKeys[METADATA] = true;
var wellKnownSymbol$9 = wellKnownSymbol$m;
var Iterators$1 = iterators;
var ITERATOR$3 = wellKnownSymbol$9("iterator");
var ArrayPrototype$g = Array.prototype;
var isArrayIteratorMethod$2 = function(it) {
  return it !== void 0 && (Iterators$1.Array === it || ArrayPrototype$g[ITERATOR$3] === it);
};
var classof$6 = classof$d;
var getMethod$1 = getMethod$3;
var Iterators = iterators;
var wellKnownSymbol$8 = wellKnownSymbol$m;
var ITERATOR$2 = wellKnownSymbol$8("iterator");
var getIteratorMethod$8 = function(it) {
  if (it != void 0)
    return getMethod$1(it, ITERATOR$2) || getMethod$1(it, "@@iterator") || Iterators[classof$6(it)];
};
var global$r = global$V;
var call$i = functionCall;
var aCallable$j = aCallable$m;
var anObject$o = anObject$u;
var tryToString$2 = tryToString$4;
var getIteratorMethod$7 = getIteratorMethod$8;
var TypeError$c = global$r.TypeError;
var getIterator$4 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$7(argument) : usingIterator;
  if (aCallable$j(iteratorMethod))
    return anObject$o(call$i(iteratorMethod, argument));
  throw TypeError$c(tryToString$2(argument) + " is not iterable");
};
var call$h = functionCall;
var anObject$n = anObject$u;
var getMethod = getMethod$3;
var iteratorClose$2 = function(iterator2, kind, value) {
  var innerResult, innerError;
  anObject$n(iterator2);
  try {
    innerResult = getMethod(iterator2, "return");
    if (!innerResult) {
      if (kind === "throw")
        throw value;
      return value;
    }
    innerResult = call$h(innerResult, iterator2);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw")
    throw value;
  if (innerError)
    throw innerResult;
  anObject$n(innerResult);
  return value;
};
var global$q = global$V;
var bind$m = functionBindContext;
var call$g = functionCall;
var anObject$m = anObject$u;
var tryToString$1 = tryToString$4;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var lengthOfArrayLike$5 = lengthOfArrayLike$a;
var isPrototypeOf$k = objectIsPrototypeOf;
var getIterator$3 = getIterator$4;
var getIteratorMethod$6 = getIteratorMethod$8;
var iteratorClose$1 = iteratorClose$2;
var TypeError$b = global$q.TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$l = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$m(unboundFunction, that);
  var iterator2, iterFn, index, length, result, next2, step;
  var stop2 = function(condition) {
    if (iterator2)
      iteratorClose$1(iterator2, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$m(value);
      return INTERRUPTED ? fn(value[0], value[1], stop2) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop2) : fn(value);
  };
  if (IS_ITERATOR) {
    iterator2 = iterable;
  } else {
    iterFn = getIteratorMethod$6(iterable);
    if (!iterFn)
      throw TypeError$b(tryToString$1(iterable) + " is not iterable");
    if (isArrayIteratorMethod$1(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$5(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$k(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    }
    iterator2 = getIterator$3(iterable, iterFn);
  }
  next2 = iterator2.next;
  while (!(step = call$g(next2, iterator2)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose$1(iterator2, "throw", error);
    }
    if (typeof result == "object" && result && isPrototypeOf$k(ResultPrototype, result))
      return result;
  }
  return new Result(false);
};
var global$p = global$V;
var isPrototypeOf$j = objectIsPrototypeOf;
var TypeError$a = global$p.TypeError;
var anInstance$4 = function(it, Prototype) {
  if (isPrototypeOf$j(Prototype, it))
    return it;
  throw TypeError$a("Incorrect invocation");
};
var $$W = _export;
var global$o = global$V;
var InternalMetadataModule$1 = internalMetadata.exports;
var fails$c = fails$u;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$8;
var iterate$k = iterate$l;
var anInstance$3 = anInstance$4;
var isCallable$5 = isCallable$l;
var isObject$d = isObject$o;
var setToStringTag$1 = setToStringTag$6;
var defineProperty$6 = objectDefineProperty.f;
var forEach$5 = arrayIteration.forEach;
var DESCRIPTORS$7 = descriptors;
var InternalStateModule$3 = internalState;
var setInternalState$3 = InternalStateModule$3.set;
var internalStateGetterFor$2 = InternalStateModule$3.getterFor;
var collection$3 = function(CONSTRUCTOR_NAME, wrapper2, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
  var ADDER = IS_MAP ? "set" : "add";
  var NativeConstructor = global$o[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var exported = {};
  var Constructor;
  if (!DESCRIPTORS$7 || !isCallable$5(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$c(function() {
    new NativeConstructor().entries().next();
  }))) {
    Constructor = common.getConstructor(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule$1.enable();
  } else {
    Constructor = wrapper2(function(target, iterable) {
      setInternalState$3(anInstance$3(target, Prototype), {
        type: CONSTRUCTOR_NAME,
        collection: new NativeConstructor()
      });
      if (iterable != void 0)
        iterate$k(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor$2(CONSTRUCTOR_NAME);
    forEach$5(["add", "clear", "delete", "forEach", "get", "has", "set", "keys", "values", "entries"], function(KEY) {
      var IS_ADDER = KEY == "add" || KEY == "set";
      if (KEY in NativePrototype && !(IS_WEAK && KEY == "clear")) {
        createNonEnumerableProperty$2(Prototype, KEY, function(a, b) {
          var collection2 = getInternalState2(this).collection;
          if (!IS_ADDER && IS_WEAK && !isObject$d(a))
            return KEY == "get" ? void 0 : false;
          var result = collection2[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      }
    });
    IS_WEAK || defineProperty$6(Prototype, "size", {
      configurable: true,
      get: function() {
        return getInternalState2(this).collection.size;
      }
    });
  }
  setToStringTag$1(Constructor, CONSTRUCTOR_NAME, false, true);
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$W({ global: true, forced: true }, exported);
  if (!IS_WEAK)
    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};
var uncurryThis$e = functionUncurryThis;
var redefineAll$3 = redefineAll$4;
var getWeakData = internalMetadata.exports.getWeakData;
var anObject$l = anObject$u;
var isObject$c = isObject$o;
var anInstance$2 = anInstance$4;
var iterate$j = iterate$l;
var ArrayIterationModule = arrayIteration;
var hasOwn$8 = hasOwnProperty_1;
var InternalStateModule$2 = internalState;
var setInternalState$2 = InternalStateModule$2.set;
var internalStateGetterFor$1 = InternalStateModule$2.getterFor;
var find$4 = ArrayIterationModule.find;
var findIndex$4 = ArrayIterationModule.findIndex;
var splice$4 = uncurryThis$e([].splice);
var id = 0;
var uncaughtFrozenStore = function(store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
  this.entries = [];
};
var findUncaughtFrozen = function(store, key) {
  return find$4(store.entries, function(it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry)
      return entry[1];
  },
  has: function(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry)
      entry[1] = value;
    else
      this.entries.push([key, value]);
  },
  "delete": function(key) {
    var index = findIndex$4(this.entries, function(it) {
      return it[0] === key;
    });
    if (~index)
      splice$4(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$1 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper2(function(that, iterable) {
      anInstance$2(that, Prototype);
      setInternalState$2(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: void 0
      });
      if (iterable != void 0)
        iterate$j(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var data2 = getWeakData(anObject$l(key), true);
      if (data2 === true)
        uncaughtFrozenStore(state).set(key, value);
      else
        data2[state.id] = value;
      return that;
    };
    redefineAll$3(Prototype, {
      "delete": function(key) {
        var state = getInternalState2(this);
        if (!isObject$c(key))
          return false;
        var data2 = getWeakData(key);
        if (data2 === true)
          return uncaughtFrozenStore(state)["delete"](key);
        return data2 && hasOwn$8(data2, state.id) && delete data2[state.id];
      },
      has: function has2(key) {
        var state = getInternalState2(this);
        if (!isObject$c(key))
          return false;
        var data2 = getWeakData(key);
        if (data2 === true)
          return uncaughtFrozenStore(state).has(key);
        return data2 && hasOwn$8(data2, state.id);
      }
    });
    redefineAll$3(Prototype, IS_MAP ? {
      get: function get3(key) {
        var state = getInternalState2(this);
        if (isObject$c(key)) {
          var data2 = getWeakData(key);
          if (data2 === true)
            return uncaughtFrozenStore(state).get(key);
          return data2 ? data2[state.id] : void 0;
        }
      },
      set: function set2(key, value) {
        return define(this, key, value);
      }
    } : {
      add: function add2(value) {
        return define(this, value, true);
      }
    });
    return Constructor;
  }
};
var global$n = global$V;
var uncurryThis$d = functionUncurryThis;
var redefineAll$2 = redefineAll$4;
var InternalMetadataModule = internalMetadata.exports;
var collection$2 = collection$3;
var collectionWeak = collectionWeak$1;
var isObject$b = isObject$o;
var isExtensible2 = objectIsExtensible;
var enforceInternalState = internalState.enforce;
var NATIVE_WEAK_MAP = nativeWeakMap;
var IS_IE11 = !global$n.ActiveXObject && "ActiveXObject" in global$n;
var InternalWeakMap;
var wrapper = function(init) {
  return function WeakMap2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
};
var $WeakMap = collection$2("WeakMap", wrapper, collectionWeak);
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
  InternalMetadataModule.enable();
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = uncurryThis$d(WeakMapPrototype["delete"]);
  var nativeHas = uncurryThis$d(WeakMapPrototype.has);
  var nativeGet = uncurryThis$d(WeakMapPrototype.get);
  var nativeSet = uncurryThis$d(WeakMapPrototype.set);
  redefineAll$2(WeakMapPrototype, {
    "delete": function(key) {
      if (isObject$b(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen["delete"](key);
      }
      return nativeDelete(this, key);
    },
    has: function has2(key) {
      if (isObject$b(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      }
      return nativeHas(this, key);
    },
    get: function get3(key) {
      if (isObject$b(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      }
      return nativeGet(this, key);
    },
    set: function set2(key, value) {
      if (isObject$b(key) && !isExtensible2(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen)
          state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else
        nativeSet(this, key, value);
      return this;
    }
  });
}
var path$n = path$u;
var weakMap$2 = path$n.WeakMap;
var parent$15 = weakMap$2;
var weakMap$1 = parent$15;
var weakMap = weakMap$1;
var getBuiltIn$9 = getBuiltIn$f;
var uncurryThis$c = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$k = anObject$u;
var concat$6 = uncurryThis$c([].concat);
var ownKeys$3 = getBuiltIn$9("Reflect", "ownKeys") || function ownKeys(it) {
  var keys4 = getOwnPropertyNamesModule.f(anObject$k(it));
  var getOwnPropertySymbols4 = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols4 ? concat$6(keys4, getOwnPropertySymbols4(it)) : keys4;
};
var hasOwn$7 = hasOwnProperty_1;
var ownKeys$2 = ownKeys$3;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys4 = ownKeys$2(source);
  var defineProperty6 = definePropertyModule$1.f;
  var getOwnPropertyDescriptor6 = getOwnPropertyDescriptorModule$2.f;
  for (var i2 = 0; i2 < keys4.length; i2++) {
    var key = keys4[i2];
    if (!hasOwn$7(target, key) && !(exceptions && hasOwn$7(exceptions, key))) {
      defineProperty6(target, key, getOwnPropertyDescriptor6(source, key));
    }
  }
};
var uncurryThis$b = functionUncurryThis;
var replace$2 = uncurryThis$b("".replace);
var TEST = function(arg) {
  return String(Error(arg).stack);
}("zxcasd");
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var clearErrorStack$1 = function(stack2, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack2 == "string") {
    while (dropEntries--)
      stack2 = replace$2(stack2, V8_OR_CHAKRA_STACK_ENTRY, "");
  }
  return stack2;
};
var isObject$a = isObject$o;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$8;
var installErrorCause$1 = function(O, options) {
  if (isObject$a(options) && "cause" in options) {
    createNonEnumerableProperty$1(O, "cause", options.cause);
  }
};
var toString$6 = toString$a;
var normalizeStringArgument$1 = function(argument, $default) {
  return argument === void 0 ? arguments.length < 2 ? "" : $default : toString$6(argument);
};
var fails$b = fails$u;
var createPropertyDescriptor$1 = createPropertyDescriptor$7;
var errorStackInstallable = !fails$b(function() {
  var error = Error("a");
  if (!("stack" in error))
    return true;
  Object.defineProperty(error, "stack", createPropertyDescriptor$1(1, 7));
  return error.stack !== 7;
});
var $$V = _export;
var global$m = global$V;
var isPrototypeOf$i = objectIsPrototypeOf;
var getPrototypeOf$8 = objectGetPrototypeOf;
var setPrototypeOf$7 = objectSetPrototypeOf;
var copyConstructorProperties = copyConstructorProperties$1;
var create$9 = objectCreate;
var createNonEnumerableProperty = createNonEnumerableProperty$8;
var createPropertyDescriptor = createPropertyDescriptor$7;
var clearErrorStack = clearErrorStack$1;
var installErrorCause = installErrorCause$1;
var iterate$i = iterate$l;
var normalizeStringArgument = normalizeStringArgument$1;
var wellKnownSymbol$7 = wellKnownSymbol$m;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var TO_STRING_TAG = wellKnownSymbol$7("toStringTag");
var Error$1 = global$m.Error;
var push$5 = [].push;
var $AggregateError = function AggregateError(errors, message) {
  var options = arguments.length > 2 ? arguments[2] : void 0;
  var isInstance = isPrototypeOf$i(AggregateErrorPrototype, this);
  var that;
  if (setPrototypeOf$7) {
    that = setPrototypeOf$7(new Error$1(), isInstance ? getPrototypeOf$8(this) : AggregateErrorPrototype);
  } else {
    that = isInstance ? this : create$9(AggregateErrorPrototype);
    createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
  }
  if (message !== void 0)
    createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
  if (ERROR_STACK_INSTALLABLE)
    createNonEnumerableProperty(that, "stack", clearErrorStack(that.stack, 1));
  installErrorCause(that, options);
  var errorsArray = [];
  iterate$i(errors, push$5, { that: errorsArray });
  createNonEnumerableProperty(that, "errors", errorsArray);
  return that;
};
if (setPrototypeOf$7)
  setPrototypeOf$7($AggregateError, Error$1);
else
  copyConstructorProperties($AggregateError, Error$1, { name: true });
var AggregateErrorPrototype = $AggregateError.prototype = create$9(Error$1.prototype, {
  constructor: createPropertyDescriptor(1, $AggregateError),
  message: createPropertyDescriptor(1, ""),
  name: createPropertyDescriptor(1, "AggregateError")
});
$$V({ global: true }, {
  AggregateError: $AggregateError
});
var global$l = global$V;
var nativePromiseConstructor = global$l.Promise;
var getBuiltIn$8 = getBuiltIn$f;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol$6 = wellKnownSymbol$m;
var DESCRIPTORS$6 = descriptors;
var SPECIES$3 = wellKnownSymbol$6("species");
var setSpecies$2 = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$8(CONSTRUCTOR_NAME);
  var defineProperty6 = definePropertyModule.f;
  if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$3]) {
    defineProperty6(Constructor, SPECIES$3, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var wellKnownSymbol$5 = wellKnownSymbol$m;
var ITERATOR$1 = wellKnownSymbol$5("iterator");
var SAFE_CLOSING = false;
try {
  var called = 0;
  var iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$1] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error) {
}
var checkCorrectnessOfIteration$2 = function(exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING)
    return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$1] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error) {
  }
  return ITERATION_SUPPORT;
};
var global$k = global$V;
var isConstructor$2 = isConstructor$4;
var tryToString = tryToString$4;
var TypeError$9 = global$k.TypeError;
var aConstructor$3 = function(argument) {
  if (isConstructor$2(argument))
    return argument;
  throw TypeError$9(tryToString(argument) + " is not a constructor");
};
var anObject$j = anObject$u;
var aConstructor$2 = aConstructor$3;
var wellKnownSymbol$4 = wellKnownSymbol$m;
var SPECIES$2 = wellKnownSymbol$4("species");
var speciesConstructor$5 = function(O, defaultConstructor) {
  var C = anObject$j(O).constructor;
  var S;
  return C === void 0 || (S = anObject$j(C)[SPECIES$2]) == void 0 ? defaultConstructor : aConstructor$2(S);
};
var global$j = global$V;
var TypeError$8 = global$j.TypeError;
var validateArgumentsLength$2 = function(passed, required) {
  if (passed < required)
    throw TypeError$8("Not enough arguments");
  return passed;
};
var userAgent$5 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$5);
var classof$5 = classofRaw$1;
var global$i = global$V;
var engineIsNode = classof$5(global$i.process) == "process";
var global$h = global$V;
var apply$4 = functionApply;
var bind$l = functionBindContext;
var isCallable$4 = isCallable$l;
var hasOwn$6 = hasOwnProperty_1;
var fails$a = fails$u;
var html = html$2;
var arraySlice$4 = arraySlice$6;
var createElement = documentCreateElement$1;
var validateArgumentsLength$1 = validateArgumentsLength$2;
var IS_IOS$1 = engineIsIos;
var IS_NODE$3 = engineIsNode;
var set$4 = global$h.setImmediate;
var clear$1 = global$h.clearImmediate;
var process$3 = global$h.process;
var Dispatch = global$h.Dispatch;
var Function$3 = global$h.Function;
var MessageChannel = global$h.MessageChannel;
var String$1 = global$h.String;
var counter = 0;
var queue$1 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var location$1, defer, channel, port;
try {
  location$1 = global$h.location;
} catch (error) {
}
var run = function(id2) {
  if (hasOwn$6(queue$1, id2)) {
    var fn = queue$1[id2];
    delete queue$1[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var listener = function(event) {
  run(event.data);
};
var post = function(id2) {
  global$h.postMessage(String$1(id2), location$1.protocol + "//" + location$1.host);
};
if (!set$4 || !clear$1) {
  set$4 = function setImmediate(handler) {
    validateArgumentsLength$1(arguments.length, 1);
    var fn = isCallable$4(handler) ? handler : Function$3(handler);
    var args = arraySlice$4(arguments, 1);
    queue$1[++counter] = function() {
      apply$4(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear$1 = function clearImmediate(id2) {
    delete queue$1[id2];
  };
  if (IS_NODE$3) {
    defer = function(id2) {
      process$3.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind$l(port.postMessage, port);
  } else if (global$h.addEventListener && isCallable$4(global$h.postMessage) && !global$h.importScripts && location$1 && location$1.protocol !== "file:" && !fails$a(post)) {
    defer = post;
    global$h.addEventListener("message", listener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id2) {
      html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task$1 = {
  set: set$4,
  clear: clear$1
};
var userAgent$4 = engineUserAgent;
var global$g = global$V;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$4) && global$g.Pebble !== void 0;
var userAgent$3 = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$3);
var global$f = global$V;
var bind$k = functionBindContext;
var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$2 = engineIsNode;
var MutationObserver$1 = global$f.MutationObserver || global$f.WebKitMutationObserver;
var document$2 = global$f.document;
var process$2 = global$f.process;
var Promise$1 = global$f.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global$f, "queueMicrotask");
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify$1, toggle, node, promise$6, then;
if (!queueMicrotask) {
  flush = function() {
    var parent2, fn;
    if (IS_NODE$2 && (parent2 = process$2.domain))
      parent2.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head)
          notify$1();
        else
          last = void 0;
        throw error;
      }
    }
    last = void 0;
    if (parent2)
      parent2.enter();
  };
  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver$1 && document$2) {
    toggle = true;
    node = document$2.createTextNode("");
    new MutationObserver$1(flush).observe(node, { characterData: true });
    notify$1 = function() {
      node.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
    promise$6 = Promise$1.resolve(void 0);
    promise$6.constructor = Promise$1;
    then = bind$k(promise$6.then, promise$6);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$2) {
    notify$1 = function() {
      process$2.nextTick(flush);
    };
  } else {
    macrotask = bind$k(macrotask, global$f);
    notify$1 = function() {
      macrotask(flush);
    };
  }
}
var microtask$1 = queueMicrotask || function(fn) {
  var task2 = { fn, next: void 0 };
  if (last)
    last.next = task2;
  if (!head) {
    head = task2;
    notify$1();
  }
  last = task2;
};
var newPromiseCapability$2 = {};
var aCallable$i = aCallable$m;
var PromiseCapability = function(C) {
  var resolve3, reject2;
  this.promise = new C(function($$resolve, $$reject) {
    if (resolve3 !== void 0 || reject2 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve3 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$i(resolve3);
  this.reject = aCallable$i(reject2);
};
newPromiseCapability$2.f = function(C) {
  return new PromiseCapability(C);
};
var anObject$i = anObject$u;
var isObject$9 = isObject$o;
var newPromiseCapability$1 = newPromiseCapability$2;
var promiseResolve$2 = function(C, x) {
  anObject$i(C);
  if (isObject$9(x) && x.constructor === C)
    return x;
  var promiseCapability = newPromiseCapability$1.f(C);
  var resolve3 = promiseCapability.resolve;
  resolve3(x);
  return promiseCapability.promise;
};
var global$e = global$V;
var hostReportErrors$1 = function(a, b) {
  var console2 = global$e.console;
  if (console2 && console2.error) {
    arguments.length == 1 ? console2.error(a) : console2.error(a, b);
  }
};
var perform$4 = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var Queue$1 = function() {
  this.head = null;
  this.tail = null;
};
Queue$1.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    if (this.head)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry)
        this.tail = null;
      return entry.item;
    }
  }
};
var queue = Queue$1;
var engineIsBrowser = typeof window == "object";
var $$U = _export;
var IS_PURE = isPure;
var global$d = global$V;
var getBuiltIn$7 = getBuiltIn$f;
var call$f = functionCall;
var NativePromise$1 = nativePromiseConstructor;
var redefineAll$1 = redefineAll$4;
var setToStringTag = setToStringTag$6;
var setSpecies$1 = setSpecies$2;
var aCallable$h = aCallable$m;
var isCallable$3 = isCallable$l;
var isObject$8 = isObject$o;
var anInstance$1 = anInstance$4;
var inspectSource = inspectSource$3;
var iterate$h = iterate$l;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;
var speciesConstructor$4 = speciesConstructor$5;
var task = task$1.set;
var microtask = microtask$1;
var promiseResolve$1 = promiseResolve$2;
var hostReportErrors = hostReportErrors$1;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$3 = perform$4;
var Queue = queue;
var InternalStateModule$1 = internalState;
var isForced = isForced_1;
var wellKnownSymbol$3 = wellKnownSymbol$m;
var IS_BROWSER = engineIsBrowser;
var IS_NODE$1 = engineIsNode;
var V8_VERSION = engineV8Version;
var SPECIES$1 = wellKnownSymbol$3("species");
var PROMISE = "Promise";
var getInternalState = InternalStateModule$1.getterFor(PROMISE);
var setInternalState$1 = InternalStateModule$1.set;
var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
var NativePromisePrototype = NativePromise$1 && NativePromise$1.prototype;
var PromiseConstructor = NativePromise$1;
var PromisePrototype = NativePromisePrototype;
var TypeError$7 = global$d.TypeError;
var document$1 = global$d.document;
var process$1 = global$d.process;
var newPromiseCapability = newPromiseCapabilityModule$3.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$d.dispatchEvent);
var NATIVE_REJECTION_EVENT = isCallable$3(global$d.PromiseRejectionEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var SUBCLASSING = false;
var Internal, OwnPromiseCapability, PromiseWrapper;
var FORCED$4 = isForced(PROMISE, function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
    return true;
  if (!PromisePrototype["finally"])
    return true;
  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
    return false;
  var promise2 = new PromiseConstructor(function(resolve3) {
    resolve3(1);
  });
  var FakePromise = function(exec2) {
    exec2(function() {
    }, function() {
    });
  };
  var constructor = promise2.constructor = {};
  constructor[SPECIES$1] = FakePromise;
  SUBCLASSING = promise2.then(function() {
  }) instanceof FakePromise;
  if (!SUBCLASSING)
    return true;
  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
});
var INCORRECT_ITERATION$1 = FORCED$4 || !checkCorrectnessOfIteration$1(function(iterable) {
  PromiseConstructor.all(iterable)["catch"](function() {
  });
});
var isThenable = function(it) {
  var then2;
  return isObject$8(it) && isCallable$3(then2 = it.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve3 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED)
          onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true)
        result = value;
      else {
        if (domain)
          domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(TypeError$7("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        call$f(then2, result, resolve3, reject2);
      } else
        resolve3(result);
    } else
      reject2(value);
  } catch (error) {
    if (domain && !exited)
      domain.exit();
    reject2(error);
  }
};
var notify = function(state, isReject) {
  if (state.notified)
    return;
  state.notified = true;
  microtask(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection)
      onUnhandled(state);
  });
};
var dispatchEvent = function(name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$d.dispatchEvent(event);
  } else
    event = { promise: promise2, reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global$d["on" + name]))
    handler(event);
  else if (name === UNHANDLED_REJECTION)
    hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$f(task, global$d, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$3(function() {
        if (IS_NODE$1) {
          process$1.emit("unhandledRejection", value, promise2);
        } else
          dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error)
        throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$f(task, global$d, function() {
    var promise2 = state.facade;
    if (IS_NODE$1) {
      process$1.emit("rejectionHandled", promise2);
    } else
      dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind$j = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$7("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask(function() {
        var wrapper2 = { done: false };
        try {
          call$f(then2, value, bind$j(internalResolve, wrapper2, state), bind$j(internalReject, wrapper2, state));
        } catch (error) {
          internalReject(wrapper2, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};
if (FORCED$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance$1(this, PromisePrototype);
    aCallable$h(executor);
    call$f(Internal, this);
    var state = getInternalState(this);
    try {
      executor(bind$j(internalResolve, state), bind$j(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: void 0
    });
  };
  Internal.prototype = redefineAll$1(PromisePrototype, {
    then: function then2(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor$4(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable$3(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable$3(onRejected) && onRejected;
      reaction.domain = IS_NODE$1 ? process$1.domain : void 0;
      if (state.state == PENDING)
        state.reactions.add(reaction);
      else
        microtask(function() {
          callReaction(reaction, state);
        });
      return reaction.promise;
    },
    "catch": function(onRejected) {
      return this.then(void 0, onRejected);
    }
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalState(promise2);
    this.promise = promise2;
    this.resolve = bind$j(internalResolve, state);
    this.reject = bind$j(internalReject, state);
  };
  newPromiseCapabilityModule$3.f = newPromiseCapability = function(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}
$$U({ global: true, wrap: true, forced: FORCED$4 }, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies$1(PROMISE);
PromiseWrapper = getBuiltIn$7(PROMISE);
$$U({ target: PROMISE, stat: true, forced: FORCED$4 }, {
  reject: function reject(r2) {
    var capability = newPromiseCapability(this);
    call$f(capability.reject, void 0, r2);
    return capability.promise;
  }
});
$$U({ target: PROMISE, stat: true, forced: IS_PURE }, {
  resolve: function resolve2(x) {
    return promiseResolve$1(this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});
$$U({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION$1 }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve3 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$3(function() {
      var $promiseResolve = aCallable$h(C.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$h(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$f($promiseResolve, C, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index] = value;
          --remaining || resolve3(values2);
        }, reject2);
      });
      --remaining || resolve3(values2);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  },
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject2 = capability.reject;
    var result = perform$3(function() {
      var $promiseResolve = aCallable$h(C.resolve);
      iterate$h(iterable, function(promise2) {
        call$f($promiseResolve, C, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$T = _export;
var call$e = functionCall;
var aCallable$g = aCallable$m;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$2 = perform$4;
var iterate$g = iterate$l;
$$T({ target: "Promise", stat: true }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$2.f(C);
    var resolve3 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$2(function() {
      var promiseResolve2 = aCallable$g(C.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$g(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$e(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index] = { status: "fulfilled", value };
          --remaining || resolve3(values2);
        }, function(error) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values2[index] = { status: "rejected", reason: error };
          --remaining || resolve3(values2);
        });
      });
      --remaining || resolve3(values2);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$S = _export;
var aCallable$f = aCallable$m;
var getBuiltIn$6 = getBuiltIn$f;
var call$d = functionCall;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var perform$1 = perform$4;
var iterate$f = iterate$l;
var PROMISE_ANY_ERROR = "No one promise resolved";
$$S({ target: "Promise", stat: true }, {
  any: function any(iterable) {
    var C = this;
    var AggregateError2 = getBuiltIn$6("AggregateError");
    var capability = newPromiseCapabilityModule$1.f(C);
    var resolve3 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$1(function() {
      var promiseResolve2 = aCallable$f(C.resolve);
      var errors = [];
      var counter2 = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate$f(iterable, function(promise2) {
        var index = counter2++;
        var alreadyRejected = false;
        remaining++;
        call$d(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyRejected || alreadyResolved)
            return;
          alreadyResolved = true;
          resolve3(value);
        }, function(error) {
          if (alreadyRejected || alreadyResolved)
            return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject2(new AggregateError2(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject2(new AggregateError2(errors, PROMISE_ANY_ERROR));
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var $$R = _export;
var NativePromise = nativePromiseConstructor;
var fails$9 = fails$u;
var getBuiltIn$5 = getBuiltIn$f;
var isCallable$2 = isCallable$l;
var speciesConstructor$3 = speciesConstructor$5;
var promiseResolve = promiseResolve$2;
var NON_GENERIC = !!NativePromise && fails$9(function() {
  NativePromise.prototype["finally"].call({ then: function() {
  } }, function() {
  });
});
$$R({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
  "finally": function(onFinally) {
    var C = speciesConstructor$3(this, getBuiltIn$5("Promise"));
    var isFunction2 = isCallable$2(onFinally);
    return this.then(isFunction2 ? function(x) {
      return promiseResolve(C, onFinally()).then(function() {
        return x;
      });
    } : onFinally, isFunction2 ? function(e2) {
      return promiseResolve(C, onFinally()).then(function() {
        throw e2;
      });
    } : onFinally);
  }
});
var path$m = path$u;
var promise$5 = path$m.Promise;
var parent$14 = promise$5;
var promise$4 = parent$14;
var promise$3 = promise$4;
var decode$2 = {};
var fails$8 = fails$u;
var arrayMethodIsStrict$5 = function(METHOD_NAME, argument) {
  var method2 = [][METHOD_NAME];
  return !!method2 && fails$8(function() {
    method2.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$4 = arrayMethodIsStrict$5;
var STRICT_METHOD$4 = arrayMethodIsStrict$4("forEach");
var arrayForEach = !STRICT_METHOD$4 ? function forEach(callbackfn) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var $$Q = _export;
var forEach$4 = arrayForEach;
$$Q({ target: "Array", proto: true, forced: [].forEach != forEach$4 }, {
  forEach: forEach$4
});
var path$l = path$u;
var entryVirtual$j = function(CONSTRUCTOR) {
  return path$l[CONSTRUCTOR + "Prototype"];
};
var entryVirtual$i = entryVirtual$j;
var forEach$3 = entryVirtual$i("Array").forEach;
var parent$13 = forEach$3;
var forEach$2 = parent$13;
var classof$4 = classof$d;
var hasOwn$5 = hasOwnProperty_1;
var isPrototypeOf$h = objectIsPrototypeOf;
var method$g = forEach$2;
var ArrayPrototype$f = Array.prototype;
var DOMIterables$3 = {
  DOMTokenList: true,
  NodeList: true
};
var forEach$1 = function(it) {
  var own = it.forEach;
  return it === ArrayPrototype$f || isPrototypeOf$h(ArrayPrototype$f, it) && own === ArrayPrototype$f.forEach || hasOwn$5(DOMIterables$3, classof$4(it)) ? method$g : own;
};
var forEach2 = forEach$1;
var $$P = _export;
var isArray$7 = isArray$b;
$$P({ target: "Array", stat: true }, {
  isArray: isArray$7
});
var path$k = path$u;
var isArray$6 = path$k.Array.isArray;
var parent$12 = isArray$6;
var isArray$5 = parent$12;
var isArray$4 = isArray$5;
var ParseACL = {};
var $$O = _export;
var toObject$6 = toObject$c;
var nativeKeys = objectKeys$4;
var fails$7 = fails$u;
var FAILS_ON_PRIMITIVES$2 = fails$7(function() {
  nativeKeys(1);
});
$$O({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
  keys: function keys2(it) {
    return nativeKeys(toObject$6(it));
  }
});
var path$j = path$u;
var keys$7 = path$j.Object.keys;
var parent$11 = keys$7;
var keys$6 = parent$11;
var keys$5 = keys$6;
var classCallCheck = { exports: {} };
(function(module) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  module.exports = _classCallCheck;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(classCallCheck);
var createClass = { exports: {} };
var parent$10 = defineProperty$b;
var defineProperty$5 = parent$10;
var parent$$ = defineProperty$5;
var defineProperty$4 = parent$$;
var defineProperty$3 = defineProperty$4;
(function(module) {
  var _Object$defineProperty2 = defineProperty$3;
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      _Object$defineProperty2(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  module.exports = _createClass;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(createClass);
var defineProperty$2 = { exports: {} };
(function(module) {
  var _Object$defineProperty2 = defineProperty$3;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      _Object$defineProperty2(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  module.exports = _defineProperty;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(defineProperty$2);
var ParseRole = {};
var global$c = global$V;
var uncurryThis$a = functionUncurryThis;
var aCallable$e = aCallable$m;
var isObject$7 = isObject$o;
var hasOwn$4 = hasOwnProperty_1;
var arraySlice$3 = arraySlice$6;
var NATIVE_BIND = functionBindNative;
var Function$2 = global$c.Function;
var concat$5 = uncurryThis$a([].concat);
var join = uncurryThis$a([].join);
var factories = {};
var construct$7 = function(C, argsLength, args) {
  if (!hasOwn$4(factories, argsLength)) {
    for (var list = [], i2 = 0; i2 < argsLength; i2++)
      list[i2] = "a[" + i2 + "]";
    factories[argsLength] = Function$2("C,a", "return new C(" + join(list, ",") + ")");
  }
  return factories[argsLength](C, args);
};
var functionBind = NATIVE_BIND ? Function$2.bind : function bind(that) {
  var F = aCallable$e(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice$3(arguments, 1);
  var boundFunction = function bound() {
    var args = concat$5(partArgs, arraySlice$3(arguments));
    return this instanceof boundFunction ? construct$7(F, args.length, args) : F.apply(that, args);
  };
  if (isObject$7(Prototype))
    boundFunction.prototype = Prototype;
  return boundFunction;
};
var $$N = _export;
var getBuiltIn$4 = getBuiltIn$f;
var apply$3 = functionApply;
var bind$i = functionBind;
var aConstructor$1 = aConstructor$3;
var anObject$h = anObject$u;
var isObject$6 = isObject$o;
var create$8 = objectCreate;
var fails$6 = fails$u;
var nativeConstruct = getBuiltIn$4("Reflect", "construct");
var ObjectPrototype = Object.prototype;
var push$4 = [].push;
var NEW_TARGET_BUG = fails$6(function() {
  function F() {
  }
  return !(nativeConstruct(function() {
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails$6(function() {
  nativeConstruct(function() {
  });
});
var FORCED$3 = NEW_TARGET_BUG || ARGS_BUG;
$$N({ target: "Reflect", stat: true, forced: FORCED$3, sham: FORCED$3 }, {
  construct: function construct(Target, args) {
    aConstructor$1(Target);
    anObject$h(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor$1(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG)
      return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      switch (args.length) {
        case 0:
          return new Target();
        case 1:
          return new Target(args[0]);
        case 2:
          return new Target(args[0], args[1]);
        case 3:
          return new Target(args[0], args[1], args[2]);
        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      }
      var $args = [null];
      apply$3(push$4, $args, args);
      return new (apply$3(bind$i, Target, $args))();
    }
    var proto = newTarget.prototype;
    var instance = create$8(isObject$6(proto) ? proto : ObjectPrototype);
    var result = apply$3(Target, instance, args);
    return isObject$6(result) ? result : instance;
  }
});
var path$i = path$u;
var construct$6 = path$i.Reflect.construct;
var parent$_ = construct$6;
var construct$5 = parent$_;
var construct$4 = construct$5;
var get$7 = { exports: {} };
var hasOwn$3 = hasOwnProperty_1;
var isDataDescriptor$1 = function(descriptor) {
  return descriptor !== void 0 && (hasOwn$3(descriptor, "value") || hasOwn$3(descriptor, "writable"));
};
var $$M = _export;
var call$c = functionCall;
var isObject$5 = isObject$o;
var anObject$g = anObject$u;
var isDataDescriptor = isDataDescriptor$1;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var getPrototypeOf$7 = objectGetPrototypeOf;
function get$6(target, propertyKey) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject$g(target) === receiver)
    return target[propertyKey];
  descriptor = getOwnPropertyDescriptorModule$1.f(target, propertyKey);
  if (descriptor)
    return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call$c(descriptor.get, receiver);
  if (isObject$5(prototype = getPrototypeOf$7(target)))
    return get$6(prototype, propertyKey, receiver);
}
$$M({ target: "Reflect", stat: true }, {
  get: get$6
});
var path$h = path$u;
var get$5 = path$h.Reflect.get;
var parent$Z = get$5;
var get$4 = parent$Z;
var parent$Y = get$4;
var get$3 = parent$Y;
var parent$X = get$3;
var get$2 = parent$X;
var get$1 = get$2;
var parent$W = getOwnPropertyDescriptor$5;
var getOwnPropertyDescriptor$2 = parent$W;
var parent$V = getOwnPropertyDescriptor$2;
var getOwnPropertyDescriptor$1 = parent$V;
var getOwnPropertyDescriptor5 = getOwnPropertyDescriptor$1;
var superPropBase = { exports: {} };
var getPrototypeOf$6 = { exports: {} };
var $$L = _export;
var setPrototypeOf$6 = objectSetPrototypeOf;
$$L({ target: "Object", stat: true }, {
  setPrototypeOf: setPrototypeOf$6
});
var path$g = path$u;
var setPrototypeOf$5 = path$g.Object.setPrototypeOf;
var parent$U = setPrototypeOf$5;
var setPrototypeOf$4 = parent$U;
var parent$T = setPrototypeOf$4;
var setPrototypeOf$3 = parent$T;
var parent$S = setPrototypeOf$3;
var setPrototypeOf$2 = parent$S;
var setPrototypeOf$1 = setPrototypeOf$2;
var $$K = _export;
var fails$5 = fails$u;
var toObject$5 = toObject$c;
var nativeGetPrototypeOf = objectGetPrototypeOf;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var FAILS_ON_PRIMITIVES$1 = fails$5(function() {
  nativeGetPrototypeOf(1);
});
$$K({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES$1, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject$5(it));
  }
});
var path$f = path$u;
var getPrototypeOf$5 = path$f.Object.getPrototypeOf;
var parent$R = getPrototypeOf$5;
var getPrototypeOf$4 = parent$R;
var parent$Q = getPrototypeOf$4;
var getPrototypeOf$3 = parent$Q;
var parent$P = getPrototypeOf$3;
var getPrototypeOf$2 = parent$P;
var getPrototypeOf$1 = getPrototypeOf$2;
(function(module) {
  var _Object$setPrototypeOf = setPrototypeOf$1;
  var _Object$getPrototypeOf = getPrototypeOf$1;
  function _getPrototypeOf(o2) {
    module.exports = _getPrototypeOf = _Object$setPrototypeOf ? _Object$getPrototypeOf : function _getPrototypeOf2(o3) {
      return o3.__proto__ || _Object$getPrototypeOf(o3);
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _getPrototypeOf(o2);
  }
  module.exports = _getPrototypeOf;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(getPrototypeOf$6);
(function(module) {
  var getPrototypeOf3 = getPrototypeOf$6.exports;
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf3(object);
      if (object === null)
        break;
    }
    return object;
  }
  module.exports = _superPropBase;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(superPropBase);
(function(module) {
  var _Reflect$get = get$1;
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor5;
  var superPropBase$1 = superPropBase.exports;
  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && _Reflect$get) {
      module.exports = _get = _Reflect$get;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _get = function _get2(target2, property2, receiver2) {
        var base = superPropBase$1(target2, property2);
        if (!base)
          return;
        var desc = _Object$getOwnPropertyDescriptor2(base, property2);
        if (desc.get) {
          return desc.get.call(receiver2);
        }
        return desc.value;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }
    return _get(target, property, receiver || target);
  }
  module.exports = _get;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(get$7);
var inherits = { exports: {} };
var $$J = _export;
var DESCRIPTORS$5 = descriptors;
var create$7 = objectCreate;
$$J({ target: "Object", stat: true, sham: !DESCRIPTORS$5 }, {
  create: create$7
});
var path$e = path$u;
var Object$2 = path$e.Object;
var create$6 = function create3(P, D) {
  return Object$2.create(P, D);
};
var parent$O = create$6;
var create$5 = parent$O;
var parent$N = create$5;
var create$4 = parent$N;
var parent$M = create$4;
var create$3 = parent$M;
var create$2 = create$3;
var setPrototypeOf = { exports: {} };
(function(module) {
  var _Object$setPrototypeOf = setPrototypeOf$1;
  function _setPrototypeOf(o2, p2) {
    module.exports = _setPrototypeOf = _Object$setPrototypeOf || function _setPrototypeOf2(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _setPrototypeOf(o2, p2);
  }
  module.exports = _setPrototypeOf;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(setPrototypeOf);
(function(module) {
  var _Object$create = create$2;
  var setPrototypeOf$12 = setPrototypeOf.exports;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      setPrototypeOf$12(subClass, superClass);
  }
  module.exports = _inherits;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(inherits);
var possibleConstructorReturn = { exports: {} };
var assertThisInitialized = { exports: {} };
(function(module) {
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  module.exports = _assertThisInitialized;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(assertThisInitialized);
(function(module) {
  var _typeof3 = _typeof$1.exports["default"];
  var assertThisInitialized$1 = assertThisInitialized.exports;
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof3(call2) === "object" || typeof call2 === "function")) {
      return call2;
    }
    return assertThisInitialized$1(self2);
  }
  module.exports = _possibleConstructorReturn;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(possibleConstructorReturn);
var ParseError$1 = {};
var wrapNativeSuper = { exports: {} };
var defineProperty$1 = objectDefineProperty.f;
var create$1 = objectCreate;
var redefineAll = redefineAll$4;
var bind$h = functionBindContext;
var anInstance = anInstance$4;
var iterate$e = iterate$l;
var defineIterator = defineIterator$3;
var setSpecies = setSpecies$2;
var DESCRIPTORS$4 = descriptors;
var fastKey = internalMetadata.exports.fastKey;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var collectionStrong$2 = {
  getConstructor: function(wrapper2, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper2(function(that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create$1(null),
        first: void 0,
        last: void 0,
        size: 0
      });
      if (!DESCRIPTORS$4)
        that.size = 0;
      if (iterable != void 0)
        iterate$e(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var entry = getEntry(that, key);
      var previous, index;
      if (entry) {
        entry.value = value;
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key,
          value,
          previous: previous = state.last,
          next: void 0,
          removed: false
        };
        if (!state.first)
          state.first = entry;
        if (previous)
          previous.next = entry;
        if (DESCRIPTORS$4)
          state.size++;
        else
          that.size++;
        if (index !== "F")
          state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function(that, key) {
      var state = getInternalState2(that);
      var index = fastKey(key);
      var entry;
      if (index !== "F")
        return state.index[index];
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key)
          return entry;
      }
    };
    redefineAll(Prototype, {
      clear: function clear2() {
        var that = this;
        var state = getInternalState2(that);
        var data2 = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous)
            entry.previous = entry.previous.next = void 0;
          delete data2[entry.index];
          entry = entry.next;
        }
        state.first = state.last = void 0;
        if (DESCRIPTORS$4)
          state.size = 0;
        else
          that.size = 0;
      },
      "delete": function(key) {
        var that = this;
        var state = getInternalState2(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next2 = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev)
            prev.next = next2;
          if (next2)
            next2.previous = prev;
          if (state.first == entry)
            state.first = next2;
          if (state.last == entry)
            state.last = prev;
          if (DESCRIPTORS$4)
            state.size--;
          else
            that.size--;
        }
        return !!entry;
      },
      forEach: function forEach3(callbackfn) {
        var state = getInternalState2(this);
        var boundFunction = bind$h(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          while (entry && entry.removed)
            entry = entry.previous;
        }
      },
      has: function has2(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(Prototype, IS_MAP ? {
      get: function get3(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      set: function set2(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      add: function add2(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$4)
      defineProperty$1(Prototype, "size", {
        get: function() {
          return getInternalState2(this).size;
        }
      });
    return Constructor;
  },
  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind,
        last: void 0
      });
    }, function() {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      while (entry && entry.removed)
        entry = entry.previous;
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        state.target = void 0;
        return { value: void 0, done: true };
      }
      if (kind == "keys")
        return { value: entry.key, done: false };
      if (kind == "values")
        return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
    setSpecies(CONSTRUCTOR_NAME);
  }
};
var collection$1 = collection$3;
var collectionStrong$1 = collectionStrong$2;
collection$1("Map", function(init) {
  return function Map2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong$1);
var path$d = path$u;
var map$9 = path$d.Map;
var parent$L = map$9;
var map$8 = parent$L;
var parent$K = map$8;
var map$7 = parent$K;
var bind$g = functionBindContext;
var call$b = functionCall;
var aCallable$d = aCallable$m;
var aConstructor = aConstructor$3;
var iterate$d = iterate$l;
var push$3 = [].push;
var collectionFrom = function from(source) {
  var length = arguments.length;
  var mapFn = length > 1 ? arguments[1] : void 0;
  var mapping, array, n2, boundFunction;
  aConstructor(this);
  mapping = mapFn !== void 0;
  if (mapping)
    aCallable$d(mapFn);
  if (source == void 0)
    return new this();
  array = [];
  if (mapping) {
    n2 = 0;
    boundFunction = bind$g(mapFn, length > 2 ? arguments[2] : void 0);
    iterate$d(source, function(nextItem) {
      call$b(push$3, array, boundFunction(nextItem, n2++));
    });
  } else {
    iterate$d(source, push$3, { that: array });
  }
  return new this(array);
};
var $$I = _export;
var from$7 = collectionFrom;
$$I({ target: "Map", stat: true, forced: true }, {
  from: from$7
});
var arraySlice$2 = arraySlice$6;
var collectionOf = function of() {
  return new this(arraySlice$2(arguments));
};
var $$H = _export;
var of2 = collectionOf;
$$H({ target: "Map", stat: true, forced: true }, {
  of: of2
});
var call$a = functionCall;
var aCallable$c = aCallable$m;
var anObject$f = anObject$u;
var collectionDeleteAll = function deleteAll() {
  var collection2 = anObject$f(this);
  var remover = aCallable$c(collection2["delete"]);
  var allDeleted = true;
  var wasDeleted;
  for (var k = 0, len = arguments.length; k < len; k++) {
    wasDeleted = call$a(remover, collection2, arguments[k]);
    allDeleted = allDeleted && wasDeleted;
  }
  return !!allDeleted;
};
var $$G = _export;
var deleteAll2 = collectionDeleteAll;
$$G({ target: "Map", proto: true, real: true, forced: true }, {
  deleteAll: deleteAll2
});
var call$9 = functionCall;
var aCallable$b = aCallable$m;
var anObject$e = anObject$u;
var mapEmplace = function emplace(key, handler) {
  var map3 = anObject$e(this);
  var get3 = aCallable$b(map3.get);
  var has2 = aCallable$b(map3.has);
  var set2 = aCallable$b(map3.set);
  var value = call$9(has2, map3, key) && "update" in handler ? handler.update(call$9(get3, map3, key), key, map3) : handler.insert(key, map3);
  call$9(set2, map3, key, value);
  return value;
};
var $$F = _export;
var emplace2 = mapEmplace;
$$F({ target: "Map", proto: true, real: true, forced: true }, {
  emplace: emplace2
});
var getIterator$2 = getIterator$4;
var getMapIterator$a = getIterator$2;
var $$E = _export;
var anObject$d = anObject$u;
var bind$f = functionBindContext;
var getMapIterator$9 = getMapIterator$a;
var iterate$c = iterate$l;
$$E({ target: "Map", proto: true, real: true, forced: true }, {
  every: function every(callbackfn) {
    var map3 = anObject$d(this);
    var iterator2 = getMapIterator$9(map3);
    var boundFunction = bind$f(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return !iterate$c(iterator2, function(key, value, stop2) {
      if (!boundFunction(value, key, map3))
        return stop2();
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});
var $$D = _export;
var getBuiltIn$3 = getBuiltIn$f;
var bind$e = functionBindContext;
var call$8 = functionCall;
var aCallable$a = aCallable$m;
var anObject$c = anObject$u;
var speciesConstructor$2 = speciesConstructor$5;
var getMapIterator$8 = getMapIterator$a;
var iterate$b = iterate$l;
$$D({ target: "Map", proto: true, real: true, forced: true }, {
  filter: function filter(callbackfn) {
    var map3 = anObject$c(this);
    var iterator2 = getMapIterator$8(map3);
    var boundFunction = bind$e(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new (speciesConstructor$2(map3, getBuiltIn$3("Map")))();
    var setter = aCallable$a(newMap.set);
    iterate$b(iterator2, function(key, value) {
      if (boundFunction(value, key, map3))
        call$8(setter, newMap, key, value);
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    return newMap;
  }
});
var $$C = _export;
var anObject$b = anObject$u;
var bind$d = functionBindContext;
var getMapIterator$7 = getMapIterator$a;
var iterate$a = iterate$l;
$$C({ target: "Map", proto: true, real: true, forced: true }, {
  find: function find(callbackfn) {
    var map3 = anObject$b(this);
    var iterator2 = getMapIterator$7(map3);
    var boundFunction = bind$d(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$a(iterator2, function(key, value, stop2) {
      if (boundFunction(value, key, map3))
        return stop2(value);
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});
var $$B = _export;
var anObject$a = anObject$u;
var bind$c = functionBindContext;
var getMapIterator$6 = getMapIterator$a;
var iterate$9 = iterate$l;
$$B({ target: "Map", proto: true, real: true, forced: true }, {
  findKey: function findKey(callbackfn) {
    var map3 = anObject$a(this);
    var iterator2 = getMapIterator$6(map3);
    var boundFunction = bind$c(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate$9(iterator2, function(key, value, stop2) {
      if (boundFunction(value, key, map3))
        return stop2(key);
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});
var $$A = _export;
var call$7 = functionCall;
var uncurryThis$9 = functionUncurryThis;
var aCallable$9 = aCallable$m;
var getIterator$1 = getIterator$4;
var iterate$8 = iterate$l;
var push$2 = uncurryThis$9([].push);
$$A({ target: "Map", stat: true, forced: true }, {
  groupBy: function groupBy(iterable, keyDerivative) {
    aCallable$9(keyDerivative);
    var iterator2 = getIterator$1(iterable);
    var newMap = new this();
    var has2 = aCallable$9(newMap.has);
    var get3 = aCallable$9(newMap.get);
    var set2 = aCallable$9(newMap.set);
    iterate$8(iterator2, function(element) {
      var derivedKey = keyDerivative(element);
      if (!call$7(has2, newMap, derivedKey))
        call$7(set2, newMap, derivedKey, [element]);
      else
        push$2(call$7(get3, newMap, derivedKey), element);
    }, { IS_ITERATOR: true });
    return newMap;
  }
});
var sameValueZero$1 = function(x, y) {
  return x === y || x != x && y != y;
};
var $$z = _export;
var anObject$9 = anObject$u;
var getMapIterator$5 = getMapIterator$a;
var sameValueZero = sameValueZero$1;
var iterate$7 = iterate$l;
$$z({ target: "Map", proto: true, real: true, forced: true }, {
  includes: function includes(searchElement) {
    return iterate$7(getMapIterator$5(anObject$9(this)), function(key, value, stop2) {
      if (sameValueZero(value, searchElement))
        return stop2();
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});
var $$y = _export;
var call$6 = functionCall;
var iterate$6 = iterate$l;
var aCallable$8 = aCallable$m;
$$y({ target: "Map", stat: true, forced: true }, {
  keyBy: function keyBy(iterable, keyDerivative) {
    var newMap = new this();
    aCallable$8(keyDerivative);
    var setter = aCallable$8(newMap.set);
    iterate$6(iterable, function(element) {
      call$6(setter, newMap, keyDerivative(element), element);
    });
    return newMap;
  }
});
var $$x = _export;
var anObject$8 = anObject$u;
var getMapIterator$4 = getMapIterator$a;
var iterate$5 = iterate$l;
$$x({ target: "Map", proto: true, real: true, forced: true }, {
  keyOf: function keyOf(searchElement) {
    return iterate$5(getMapIterator$4(anObject$8(this)), function(key, value, stop2) {
      if (value === searchElement)
        return stop2(key);
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
  }
});
var $$w = _export;
var getBuiltIn$2 = getBuiltIn$f;
var bind$b = functionBindContext;
var call$5 = functionCall;
var aCallable$7 = aCallable$m;
var anObject$7 = anObject$u;
var speciesConstructor$1 = speciesConstructor$5;
var getMapIterator$3 = getMapIterator$a;
var iterate$4 = iterate$l;
$$w({ target: "Map", proto: true, real: true, forced: true }, {
  mapKeys: function mapKeys(callbackfn) {
    var map3 = anObject$7(this);
    var iterator2 = getMapIterator$3(map3);
    var boundFunction = bind$b(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new (speciesConstructor$1(map3, getBuiltIn$2("Map")))();
    var setter = aCallable$7(newMap.set);
    iterate$4(iterator2, function(key, value) {
      call$5(setter, newMap, boundFunction(value, key, map3), value);
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    return newMap;
  }
});
var $$v = _export;
var getBuiltIn$1 = getBuiltIn$f;
var bind$a = functionBindContext;
var call$4 = functionCall;
var aCallable$6 = aCallable$m;
var anObject$6 = anObject$u;
var speciesConstructor = speciesConstructor$5;
var getMapIterator$2 = getMapIterator$a;
var iterate$3 = iterate$l;
$$v({ target: "Map", proto: true, real: true, forced: true }, {
  mapValues: function mapValues(callbackfn) {
    var map3 = anObject$6(this);
    var iterator2 = getMapIterator$2(map3);
    var boundFunction = bind$a(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    var newMap = new (speciesConstructor(map3, getBuiltIn$1("Map")))();
    var setter = aCallable$6(newMap.set);
    iterate$3(iterator2, function(key, value) {
      call$4(setter, newMap, key, boundFunction(value, key, map3));
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    return newMap;
  }
});
var $$u = _export;
var aCallable$5 = aCallable$m;
var anObject$5 = anObject$u;
var iterate$2 = iterate$l;
$$u({ target: "Map", proto: true, real: true, forced: true }, {
  merge: function merge(iterable) {
    var map3 = anObject$5(this);
    var setter = aCallable$5(map3.set);
    var argumentsLength = arguments.length;
    var i2 = 0;
    while (i2 < argumentsLength) {
      iterate$2(arguments[i2++], setter, { that: map3, AS_ENTRIES: true });
    }
    return map3;
  }
});
var $$t = _export;
var global$b = global$V;
var anObject$4 = anObject$u;
var aCallable$4 = aCallable$m;
var getMapIterator$1 = getMapIterator$a;
var iterate$1 = iterate$l;
var TypeError$6 = global$b.TypeError;
$$t({ target: "Map", proto: true, real: true, forced: true }, {
  reduce: function reduce(callbackfn) {
    var map3 = anObject$4(this);
    var iterator2 = getMapIterator$1(map3);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? void 0 : arguments[1];
    aCallable$4(callbackfn);
    iterate$1(iterator2, function(key, value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = callbackfn(accumulator, value, key, map3);
      }
    }, { AS_ENTRIES: true, IS_ITERATOR: true });
    if (noInitial)
      throw TypeError$6("Reduce of empty map with no initial value");
    return accumulator;
  }
});
var $$s = _export;
var anObject$3 = anObject$u;
var bind$9 = functionBindContext;
var getMapIterator = getMapIterator$a;
var iterate = iterate$l;
$$s({ target: "Map", proto: true, real: true, forced: true }, {
  some: function some(callbackfn) {
    var map3 = anObject$3(this);
    var iterator2 = getMapIterator(map3);
    var boundFunction = bind$9(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return iterate(iterator2, function(key, value, stop2) {
      if (boundFunction(value, key, map3))
        return stop2();
    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
  }
});
var $$r = _export;
var global$a = global$V;
var call$3 = functionCall;
var anObject$2 = anObject$u;
var aCallable$3 = aCallable$m;
var TypeError$5 = global$a.TypeError;
$$r({ target: "Map", proto: true, real: true, forced: true }, {
  update: function update(key, callback) {
    var map3 = anObject$2(this);
    var get3 = aCallable$3(map3.get);
    var has2 = aCallable$3(map3.has);
    var set2 = aCallable$3(map3.set);
    var length = arguments.length;
    aCallable$3(callback);
    var isPresentInMap = call$3(has2, map3, key);
    if (!isPresentInMap && length < 3) {
      throw TypeError$5("Updating absent value");
    }
    var value = isPresentInMap ? call$3(get3, map3, key) : aCallable$3(length > 2 ? arguments[2] : void 0)(key, map3);
    call$3(set2, map3, key, callback(value, key, map3));
    return map3;
  }
});
var global$9 = global$V;
var call$2 = functionCall;
var aCallable$2 = aCallable$m;
var isCallable$1 = isCallable$l;
var anObject$1 = anObject$u;
var TypeError$4 = global$9.TypeError;
var mapUpsert = function upsert(key, updateFn) {
  var map3 = anObject$1(this);
  var get3 = aCallable$2(map3.get);
  var has2 = aCallable$2(map3.has);
  var set2 = aCallable$2(map3.set);
  var insertFn = arguments.length > 2 ? arguments[2] : void 0;
  var value;
  if (!isCallable$1(updateFn) && !isCallable$1(insertFn)) {
    throw TypeError$4("At least one callback required");
  }
  if (call$2(has2, map3, key)) {
    value = call$2(get3, map3, key);
    if (isCallable$1(updateFn)) {
      value = updateFn(value);
      call$2(set2, map3, key, value);
    }
  } else if (isCallable$1(insertFn)) {
    value = insertFn();
    call$2(set2, map3, key, value);
  }
  return value;
};
var $$q = _export;
var upsert$1 = mapUpsert;
$$q({ target: "Map", proto: true, real: true, forced: true }, {
  upsert: upsert$1
});
var $$p = _export;
var upsert2 = mapUpsert;
$$p({ target: "Map", proto: true, real: true, name: "upsert", forced: true }, {
  updateOrInsert: upsert2
});
var parent$J = map$7;
var map$6 = parent$J;
var map$5 = map$6;
var isNativeFunction = { exports: {} };
var $$o = _export;
var uncurryThis$8 = functionUncurryThis;
var $IndexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict$3 = arrayMethodIsStrict$5;
var un$IndexOf = uncurryThis$8([].indexOf);
var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
var STRICT_METHOD$3 = arrayMethodIsStrict$3("indexOf");
$$o({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$3 }, {
  indexOf: function indexOf(searchElement) {
    var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
    return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
  }
});
var entryVirtual$h = entryVirtual$j;
var indexOf$6 = entryVirtual$h("Array").indexOf;
var isPrototypeOf$g = objectIsPrototypeOf;
var method$f = indexOf$6;
var ArrayPrototype$e = Array.prototype;
var indexOf$5 = function(it) {
  var own = it.indexOf;
  return it === ArrayPrototype$e || isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.indexOf ? method$f : own;
};
var parent$I = indexOf$5;
var indexOf$4 = parent$I;
var parent$H = indexOf$4;
var indexOf$3 = parent$H;
var parent$G = indexOf$3;
var indexOf$2 = parent$G;
var indexOf$1 = indexOf$2;
(function(module) {
  var _indexOfInstanceProperty = indexOf$1;
  function _isNativeFunction(fn) {
    var _context;
    return _indexOfInstanceProperty(_context = Function.toString.call(fn)).call(_context, "[native code]") !== -1;
  }
  module.exports = _isNativeFunction;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(isNativeFunction);
var construct$3 = { exports: {} };
var parent$F = construct$5;
var construct$2 = parent$F;
var parent$E = construct$2;
var construct$1 = parent$E;
var construct2 = construct$1;
var $$n = _export;
var bind$8 = functionBind;
$$n({ target: "Function", proto: true, forced: Function.bind !== bind$8 }, {
  bind: bind$8
});
var entryVirtual$g = entryVirtual$j;
var bind$7 = entryVirtual$g("Function").bind;
var isPrototypeOf$f = objectIsPrototypeOf;
var method$e = bind$7;
var FunctionPrototype = Function.prototype;
var bind$6 = function(it) {
  var own = it.bind;
  return it === FunctionPrototype || isPrototypeOf$f(FunctionPrototype, it) && own === FunctionPrototype.bind ? method$e : own;
};
var parent$D = bind$6;
var bind$5 = parent$D;
var parent$C = bind$5;
var bind$4 = parent$C;
var parent$B = bind$4;
var bind$3 = parent$B;
var bind$2 = bind$3;
var isNativeReflectConstruct = { exports: {} };
(function(module) {
  var _Reflect$construct = construct2;
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  module.exports = _isNativeReflectConstruct;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(isNativeReflectConstruct);
(function(module) {
  var _Reflect$construct = construct2;
  var _bindInstanceProperty = bind$2;
  var setPrototypeOf$12 = setPrototypeOf.exports;
  var isNativeReflectConstruct$1 = isNativeReflectConstruct.exports;
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct$1()) {
      module.exports = _construct = _Reflect$construct;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = _bindInstanceProperty(Function).apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          setPrototypeOf$12(instance, Class2.prototype);
        return instance;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }
    return _construct.apply(null, arguments);
  }
  module.exports = _construct;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(construct$3);
(function(module) {
  var _Map = map$5;
  var _Object$create = create$2;
  var getPrototypeOf3 = getPrototypeOf$6.exports;
  var setPrototypeOf$12 = setPrototypeOf.exports;
  var isNativeFunction$1 = isNativeFunction.exports;
  var construct3 = construct$3.exports;
  function _wrapNativeSuper(Class) {
    var _cache = typeof _Map === "function" ? new _Map() : void 0;
    module.exports = _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !isNativeFunction$1(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return construct3(Class2, arguments, getPrototypeOf3(this).constructor);
      }
      Wrapper.prototype = _Object$create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return setPrototypeOf$12(Wrapper, Class2);
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _wrapNativeSuper(Class);
  }
  module.exports = _wrapNativeSuper;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(wrapNativeSuper);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _defineProperty = _interopRequireDefault2(defineProperty$a);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _assertThisInitialized2 = _interopRequireDefault2(assertThisInitialized.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _wrapNativeSuper2 = _interopRequireDefault2(wrapNativeSuper.exports);
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var ParseError2 = /* @__PURE__ */ function(_Error) {
    (0, _inherits2.default)(ParseError3, _Error);
    var _super = _createSuper(ParseError3);
    function ParseError3(code, message) {
      var _this;
      (0, _classCallCheck22.default)(this, ParseError3);
      _this = _super.call(this, message);
      _this.code = code;
      (0, _defineProperty.default)((0, _assertThisInitialized2.default)(_this), "message", {
        enumerable: true,
        value: message
      });
      return _this;
    }
    (0, _createClass22.default)(ParseError3, [{
      key: "toString",
      value: function() {
        return "ParseError: " + this.code + " " + this.message;
      }
    }]);
    return ParseError3;
  }(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(Error));
  ParseError2.OTHER_CAUSE = -1;
  ParseError2.INTERNAL_SERVER_ERROR = 1;
  ParseError2.CONNECTION_FAILED = 100;
  ParseError2.OBJECT_NOT_FOUND = 101;
  ParseError2.INVALID_QUERY = 102;
  ParseError2.INVALID_CLASS_NAME = 103;
  ParseError2.MISSING_OBJECT_ID = 104;
  ParseError2.INVALID_KEY_NAME = 105;
  ParseError2.INVALID_POINTER = 106;
  ParseError2.INVALID_JSON = 107;
  ParseError2.COMMAND_UNAVAILABLE = 108;
  ParseError2.NOT_INITIALIZED = 109;
  ParseError2.INCORRECT_TYPE = 111;
  ParseError2.INVALID_CHANNEL_NAME = 112;
  ParseError2.PUSH_MISCONFIGURED = 115;
  ParseError2.OBJECT_TOO_LARGE = 116;
  ParseError2.OPERATION_FORBIDDEN = 119;
  ParseError2.CACHE_MISS = 120;
  ParseError2.INVALID_NESTED_KEY = 121;
  ParseError2.INVALID_FILE_NAME = 122;
  ParseError2.INVALID_ACL = 123;
  ParseError2.TIMEOUT = 124;
  ParseError2.INVALID_EMAIL_ADDRESS = 125;
  ParseError2.MISSING_CONTENT_TYPE = 126;
  ParseError2.MISSING_CONTENT_LENGTH = 127;
  ParseError2.INVALID_CONTENT_LENGTH = 128;
  ParseError2.FILE_TOO_LARGE = 129;
  ParseError2.FILE_SAVE_ERROR = 130;
  ParseError2.DUPLICATE_VALUE = 137;
  ParseError2.INVALID_ROLE_NAME = 139;
  ParseError2.EXCEEDED_QUOTA = 140;
  ParseError2.SCRIPT_FAILED = 141;
  ParseError2.VALIDATION_ERROR = 142;
  ParseError2.INVALID_IMAGE_DATA = 143;
  ParseError2.UNSAVED_FILE_ERROR = 151;
  ParseError2.INVALID_PUSH_TIME_ERROR = 152;
  ParseError2.FILE_DELETE_ERROR = 153;
  ParseError2.FILE_DELETE_UNNAMED_ERROR = 161;
  ParseError2.REQUEST_LIMIT_EXCEEDED = 155;
  ParseError2.DUPLICATE_REQUEST = 159;
  ParseError2.INVALID_EVENT_NAME = 160;
  ParseError2.INVALID_VALUE = 162;
  ParseError2.USERNAME_MISSING = 200;
  ParseError2.PASSWORD_MISSING = 201;
  ParseError2.USERNAME_TAKEN = 202;
  ParseError2.EMAIL_TAKEN = 203;
  ParseError2.EMAIL_MISSING = 204;
  ParseError2.EMAIL_NOT_FOUND = 205;
  ParseError2.SESSION_MISSING = 206;
  ParseError2.MUST_CREATE_USER_THROUGH_SIGNUP = 207;
  ParseError2.ACCOUNT_ALREADY_LINKED = 208;
  ParseError2.INVALID_SESSION_TOKEN = 209;
  ParseError2.MFA_ERROR = 210;
  ParseError2.MFA_TOKEN_REQUIRED = 211;
  ParseError2.LINKED_ID_MISSING = 250;
  ParseError2.INVALID_LINKED_SESSION = 251;
  ParseError2.UNSUPPORTED_SERVICE = 252;
  ParseError2.INVALID_SCHEMA_OPERATION = 255;
  ParseError2.AGGREGATE_ERROR = 600;
  ParseError2.FILE_READ_ERROR = 601;
  ParseError2.X_DOMAIN_REQUEST = 602;
  var _default = ParseError2;
  exports.default = _default;
})(ParseError$1);
var ParseObject = {};
var getIteratorMethod$5 = getIteratorMethod$8;
var getIteratorMethod_1 = getIteratorMethod$5;
var parent$A = getIteratorMethod_1;
var getIteratorMethod$4 = parent$A;
var parent$z = getIteratorMethod$4;
var getIteratorMethod$3 = parent$z;
var parent$y = getIteratorMethod$3;
var getIteratorMethod$2 = parent$y;
var getIteratorMethod$1 = getIteratorMethod$2;
var symbol = symbol$4;
var anObject = anObject$u;
var iteratorClose = iteratorClose$2;
var callWithSafeIterationClosing$1 = function(iterator2, fn, value, ENTRIES2) {
  try {
    return ENTRIES2 ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator2, "throw", error);
  }
};
var global$8 = global$V;
var bind$1 = functionBindContext;
var call$1 = functionCall;
var toObject$4 = toObject$c;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var isConstructor$1 = isConstructor$4;
var lengthOfArrayLike$4 = lengthOfArrayLike$a;
var createProperty$3 = createProperty$6;
var getIterator = getIterator$4;
var getIteratorMethod = getIteratorMethod$8;
var Array$3 = global$8.Array;
var arrayFrom = function from2(arrayLike) {
  var O = toObject$4(arrayLike);
  var IS_CONSTRUCTOR = isConstructor$1(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  if (mapping)
    mapfn = bind$1(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator2, next2, value;
  if (iteratorMethod && !(this == Array$3 && isArrayIteratorMethod(iteratorMethod))) {
    iterator2 = getIterator(O, iteratorMethod);
    next2 = iterator2.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (; !(step = call$1(next2, iterator2)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator2, mapfn, [step.value, index], true) : step.value;
      createProperty$3(result, index, value);
    }
  } else {
    length = lengthOfArrayLike$4(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array$3(length);
    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty$3(result, index, value);
    }
  }
  result.length = index;
  return result;
};
var $$m = _export;
var from$6 = arrayFrom;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
  Array.from(iterable);
});
$$m({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
  from: from$6
});
var path$c = path$u;
var from$5 = path$c.Array.from;
var parent$x = from$5;
var from$4 = parent$x;
var from$3 = from$4;
var $$l = _export;
var global$7 = global$V;
var isArray$3 = isArray$b;
var isConstructor3 = isConstructor$4;
var isObject$4 = isObject$o;
var toAbsoluteIndex$1 = toAbsoluteIndex$4;
var lengthOfArrayLike$3 = lengthOfArrayLike$a;
var toIndexedObject$2 = toIndexedObject$b;
var createProperty$2 = createProperty$6;
var wellKnownSymbol$2 = wellKnownSymbol$m;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;
var un$Slice = arraySlice$6;
var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3("slice");
var SPECIES = wellKnownSymbol$2("species");
var Array$2 = global$7.Array;
var max$1 = Math.max;
$$l({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
  slice: function slice(start, end) {
    var O = toIndexedObject$2(this);
    var length = lengthOfArrayLike$3(O);
    var k = toAbsoluteIndex$1(start, length);
    var fin = toAbsoluteIndex$1(end === void 0 ? length : end, length);
    var Constructor, result, n2;
    if (isArray$3(O)) {
      Constructor = O.constructor;
      if (isConstructor3(Constructor) && (Constructor === Array$2 || isArray$3(Constructor.prototype))) {
        Constructor = void 0;
      } else if (isObject$4(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null)
          Constructor = void 0;
      }
      if (Constructor === Array$2 || Constructor === void 0) {
        return un$Slice(O, k, fin);
      }
    }
    result = new (Constructor === void 0 ? Array$2 : Constructor)(max$1(fin - k, 0));
    for (n2 = 0; k < fin; k++, n2++)
      if (k in O)
        createProperty$2(result, n2, O[k]);
    result.length = n2;
    return result;
  }
});
var entryVirtual$f = entryVirtual$j;
var slice$6 = entryVirtual$f("Array").slice;
var isPrototypeOf$e = objectIsPrototypeOf;
var method$d = slice$6;
var ArrayPrototype$d = Array.prototype;
var slice$5 = function(it) {
  var own = it.slice;
  return it === ArrayPrototype$d || isPrototypeOf$e(ArrayPrototype$d, it) && own === ArrayPrototype$d.slice ? method$d : own;
};
var parent$w = slice$5;
var slice$4 = parent$w;
var slice$3 = slice$4;
var defineProperties$4 = { exports: {} };
var $$k = _export;
var DESCRIPTORS$3 = descriptors;
var defineProperties$3 = objectDefineProperties.f;
$$k({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties$3, sham: !DESCRIPTORS$3 }, {
  defineProperties: defineProperties$3
});
var path$b = path$u;
var Object$1 = path$b.Object;
var defineProperties$2 = defineProperties$4.exports = function defineProperties3(T, D) {
  return Object$1.defineProperties(T, D);
};
if (Object$1.defineProperties.sham)
  defineProperties$2.sham = true;
var parent$v = defineProperties$4.exports;
var defineProperties$1 = parent$v;
var defineProperties4 = defineProperties$1;
var $$j = _export;
var DESCRIPTORS$2 = descriptors;
var ownKeys$1 = ownKeys$3;
var toIndexedObject$1 = toIndexedObject$b;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var createProperty$1 = createProperty$6;
$$j({ target: "Object", stat: true, sham: !DESCRIPTORS$2 }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject$1(object);
    var getOwnPropertyDescriptor6 = getOwnPropertyDescriptorModule.f;
    var keys4 = ownKeys$1(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys4.length > index) {
      descriptor = getOwnPropertyDescriptor6(O, key = keys4[index++]);
      if (descriptor !== void 0)
        createProperty$1(result, key, descriptor);
    }
    return result;
  }
});
var path$a = path$u;
var getOwnPropertyDescriptors$2 = path$a.Object.getOwnPropertyDescriptors;
var parent$u = getOwnPropertyDescriptors$2;
var getOwnPropertyDescriptors$1 = parent$u;
var getOwnPropertyDescriptors2 = getOwnPropertyDescriptors$1;
var $$i = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2("filter");
$$i({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
  filter: function filter2(callbackfn) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$e = entryVirtual$j;
var filter$3 = entryVirtual$e("Array").filter;
var isPrototypeOf$d = objectIsPrototypeOf;
var method$c = filter$3;
var ArrayPrototype$c = Array.prototype;
var filter$2 = function(it) {
  var own = it.filter;
  return it === ArrayPrototype$c || isPrototypeOf$d(ArrayPrototype$c, it) && own === ArrayPrototype$c.filter ? method$c : own;
};
var parent$t = filter$2;
var filter$1 = parent$t;
var filter3 = filter$1;
var path$9 = path$u;
var getOwnPropertySymbols$2 = path$9.Object.getOwnPropertySymbols;
var parent$s = getOwnPropertySymbols$2;
var getOwnPropertySymbols$1 = parent$s;
var getOwnPropertySymbols3 = getOwnPropertySymbols$1;
var $$h = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1("map");
$$h({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
  map: function map(callbackfn) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$d = entryVirtual$j;
var map$4 = entryVirtual$d("Array").map;
var isPrototypeOf$c = objectIsPrototypeOf;
var method$b = map$4;
var ArrayPrototype$b = Array.prototype;
var map$3 = function(it) {
  var own = it.map;
  return it === ArrayPrototype$b || isPrototypeOf$c(ArrayPrototype$b, it) && own === ArrayPrototype$b.map ? method$b : own;
};
var parent$r = map$3;
var map$2 = parent$r;
var map$1 = map$2;
var $$g = _export;
var $find = arrayIteration.find;
var FIND = "find";
var SKIPS_HOLES$1 = true;
if (FIND in [])
  Array(1)[FIND](function() {
    SKIPS_HOLES$1 = false;
  });
$$g({ target: "Array", proto: true, forced: SKIPS_HOLES$1 }, {
  find: function find2(callbackfn) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$c = entryVirtual$j;
var find$3 = entryVirtual$c("Array").find;
var isPrototypeOf$b = objectIsPrototypeOf;
var method$a = find$3;
var ArrayPrototype$a = Array.prototype;
var find$2 = function(it) {
  var own = it.find;
  return it === ArrayPrototype$a || isPrototypeOf$b(ArrayPrototype$a, it) && own === ArrayPrototype$a.find ? method$a : own;
};
var parent$q = find$2;
var find$1 = parent$q;
var find3 = find$1;
var create4 = create$5;
var runtime = { exports: {} };
(function(module) {
  var runtime2 = function(exports) {
    var Op = Object.prototype;
    var hasOwn3 = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol2 = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol2.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol2.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol2.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap2(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self2, context);
      return generator;
    }
    exports.wrap = wrap2;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype2 = {};
    define(IteratorPrototype2, iteratorSymbol, function() {
      return this;
    });
    var getProto2 = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto2 && getProto2(getProto2(values2([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype2 = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype2);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method2) {
        define(prototype, method2, function(arg) {
          return this._invoke(method2, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method2, arg, resolve3, reject2) {
        var record = tryCatch(generator[method2], generator, arg);
        if (record.type === "throw") {
          reject2(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn3.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve3, reject2);
            }, function(err) {
              invoke("throw", err, resolve3, reject2);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve3(result);
          }, function(error) {
            return invoke("throw", error, resolve3, reject2);
          });
        }
      }
      var previousPromise;
      function enqueue(method2, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve3, reject2) {
            invoke(method2, arg, resolve3, reject2);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method2, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method2 === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method2;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method2 = delegate.iterator[context.method];
      if (method2 === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method2, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys4 = [];
      for (var key in object) {
        keys4.push(key);
      }
      keys4.reverse();
      return function next2() {
        while (keys4.length) {
          var key2 = keys4.pop();
          if (key2 in object) {
            next2.value = key2;
            next2.done = false;
            return next2;
          }
        }
        next2.done = true;
        return next2;
      };
    };
    function values2(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i2 = -1, next2 = function next3() {
            while (++i2 < iterable.length) {
              if (hasOwn3.call(iterable, i2)) {
                next3.value = iterable[i2];
                next3.done = false;
                return next3;
              }
            }
            next3.value = undefined$1;
            next3.done = true;
            return next3;
          };
          return next2.next = next2;
        }
      }
      return { next: doneResult };
    }
    exports.values = values2;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn3.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn3.call(entry, "catchLoc");
            var hasFinally = hasOwn3.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values2(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(module.exports);
  try {
    regeneratorRuntime = runtime2;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime2;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime2);
    }
  }
})(runtime);
var regenerator = runtime.exports;
var asyncToGenerator = { exports: {} };
var parent$p = promise$4;
var promise$2 = parent$p;
var $$f = _export;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$4;
$$f({ target: "Promise", stat: true, forced: true }, {
  "try": function(callbackfn) {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    var result = perform(callbackfn);
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});
var parent$o = promise$2;
var promise$1 = parent$o;
var promise = promise$1;
(function(module) {
  var _Promise = promise;
  function asyncGeneratorStep(gen, resolve3, reject2, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject2(error);
      return;
    }
    if (info.done) {
      resolve3(value);
    } else {
      _Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new _Promise(function(resolve3, reject2) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve3, reject2, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve3, reject2, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  module.exports = _asyncToGenerator;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(asyncToGenerator);
var entryVirtual$b = entryVirtual$j;
var concat$4 = entryVirtual$b("Array").concat;
var isPrototypeOf$a = objectIsPrototypeOf;
var method$9 = concat$4;
var ArrayPrototype$9 = Array.prototype;
var concat$3 = function(it) {
  var own = it.concat;
  return it === ArrayPrototype$9 || isPrototypeOf$a(ArrayPrototype$9, it) && own === ArrayPrototype$9.concat ? method$9 : own;
};
var parent$n = concat$3;
var concat$2 = parent$n;
var concat$1 = concat$2;
var getPrototypeOf2 = getPrototypeOf$4;
var $$e = _export;
var $includes = arrayIncludes.includes;
$$e({ target: "Array", proto: true }, {
  includes: function includes2(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$a = entryVirtual$j;
var includes$4 = entryVirtual$a("Array").includes;
var isObject$3 = isObject$o;
var classof$3 = classofRaw$1;
var wellKnownSymbol$1 = wellKnownSymbol$m;
var MATCH$1 = wellKnownSymbol$1("match");
var isRegexp = function(it) {
  var isRegExp2;
  return isObject$3(it) && ((isRegExp2 = it[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$3(it) == "RegExp");
};
var global$6 = global$V;
var isRegExp = isRegexp;
var TypeError$3 = global$6.TypeError;
var notARegexp = function(it) {
  if (isRegExp(it)) {
    throw TypeError$3("The method doesn't accept regular expressions");
  }
  return it;
};
var wellKnownSymbol = wellKnownSymbol$m;
var MATCH = wellKnownSymbol("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$d = _export;
var uncurryThis$7 = functionUncurryThis;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$2 = requireObjectCoercible$6;
var toString$5 = toString$a;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$7("".indexOf);
$$d({ target: "String", proto: true, forced: !correctIsRegExpLogic$1("includes") }, {
  includes: function includes3(searchString) {
    return !!~stringIndexOf(toString$5(requireObjectCoercible$2(this)), toString$5(notARegExp$1(searchString)), arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$9 = entryVirtual$j;
var includes$3 = entryVirtual$9("String").includes;
var isPrototypeOf$9 = objectIsPrototypeOf;
var arrayMethod = includes$4;
var stringMethod = includes$3;
var ArrayPrototype$8 = Array.prototype;
var StringPrototype$1 = String.prototype;
var includes$2 = function(it) {
  var own = it.includes;
  if (it === ArrayPrototype$8 || isPrototypeOf$9(ArrayPrototype$8, it) && own === ArrayPrototype$8.includes)
    return arrayMethod;
  if (typeof it == "string" || it === StringPrototype$1 || isPrototypeOf$9(StringPrototype$1, it) && own === StringPrototype$1.includes) {
    return stringMethod;
  }
  return own;
};
var parent$m = includes$2;
var includes$1 = parent$m;
var includes4 = includes$1;
var $$c = _export;
var global$5 = global$V;
var getBuiltIn = getBuiltIn$f;
var apply$2 = functionApply;
var uncurryThis$6 = functionUncurryThis;
var fails$4 = fails$u;
var Array$1 = global$5.Array;
var $stringify = getBuiltIn("JSON", "stringify");
var exec$1 = uncurryThis$6(/./.exec);
var charAt = uncurryThis$6("".charAt);
var charCodeAt = uncurryThis$6("".charCodeAt);
var replace$1 = uncurryThis$6("".replace);
var numberToString = uncurryThis$6(1 .toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var fix = function(match2, offset, string) {
  var prev = charAt(string, offset - 1);
  var next2 = charAt(string, offset + 1);
  if (exec$1(low, match2) && !exec$1(hi, next2) || exec$1(hi, match2) && !exec$1(low, prev)) {
    return "\\u" + numberToString(charCodeAt(match2, 0), 16);
  }
  return match2;
};
var FORCED$2 = fails$4(function() {
  return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
});
if ($stringify) {
  $$c({ target: "JSON", stat: true, forced: FORCED$2 }, {
    stringify: function stringify3(it, replacer2, space) {
      for (var i2 = 0, l = arguments.length, args = Array$1(l); i2 < l; i2++)
        args[i2] = arguments[i2];
      var result = apply$2($stringify, null, args);
      return typeof result == "string" ? replace$1(result, tester, fix) : result;
    }
  });
}
var path$8 = path$u;
var apply$1 = functionApply;
if (!path$8.JSON)
  path$8.JSON = { stringify: JSON.stringify };
var stringify$2 = function stringify(it, replacer2, space) {
  return apply$1(path$8.JSON.stringify, null, arguments);
};
var parent$l = stringify$2;
var stringify$1 = parent$l;
var stringify2 = stringify$1;
var $$b = _export;
var FREEZING = freezing;
var fails$3 = fails$u;
var isObject$2 = isObject$o;
var onFreeze = internalMetadata.exports.onFreeze;
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails$3(function() {
  $freeze(1);
});
$$b({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return $freeze && isObject$2(it) ? $freeze(onFreeze(it)) : it;
  }
});
var path$7 = path$u;
var freeze$2 = path$7.Object.freeze;
var parent$k = freeze$2;
var freeze$1 = parent$k;
var freeze2 = freeze$1;
var indexOf2 = indexOf$4;
var _interopRequireDefault$a = interopRequireDefault.exports;
var _concat$2 = _interopRequireDefault$a(concat$1);
var _forEach$1 = _interopRequireDefault$a(forEach2);
var config = {
  IS_NODE: typeof process !== "undefined" && !!process.versions && !!process.versions.node && !process.versions.electron,
  REQUEST_ATTEMPT_LIMIT: 5,
  REQUEST_BATCH_SIZE: 20,
  REQUEST_HEADERS: {},
  SERVER_URL: "https://api.parse.com/1",
  SERVER_AUTH_TYPE: null,
  SERVER_AUTH_TOKEN: null,
  LIVEQUERY_SERVER_URL: null,
  ENCRYPTED_KEY: null,
  VERSION: "js3.4.1",
  APPLICATION_ID: null,
  JAVASCRIPT_KEY: null,
  MASTER_KEY: null,
  USE_MASTER_KEY: false,
  PERFORM_USER_REWRITE: true,
  FORCE_REVOCABLE_SESSION: false,
  ENCRYPTED_USER: false,
  IDEMPOTENCY: false,
  ALLOW_CUSTOM_OBJECT_ID: false
};
function requireMethods(name, methods, controller) {
  (0, _forEach$1.default)(methods).call(methods, function(func) {
    if (typeof controller[func] !== "function") {
      var _context;
      throw new Error((0, _concat$2.default)(_context = "".concat(name, " must implement ")).call(_context, func, "()"));
    }
  });
}
var CoreManager = {
  get: function(key) {
    if (config.hasOwnProperty(key)) {
      return config[key];
    }
    throw new Error("Configuration key not found: " + key);
  },
  set: function(key, value) {
    config[key] = value;
  },
  setAnalyticsController: function(controller) {
    requireMethods("AnalyticsController", ["track"], controller);
    config["AnalyticsController"] = controller;
  },
  getAnalyticsController: function() {
    return config["AnalyticsController"];
  },
  setCloudController: function(controller) {
    requireMethods("CloudController", ["run", "getJobsData", "startJob"], controller);
    config["CloudController"] = controller;
  },
  getCloudController: function() {
    return config["CloudController"];
  },
  setConfigController: function(controller) {
    requireMethods("ConfigController", ["current", "get", "save"], controller);
    config["ConfigController"] = controller;
  },
  getConfigController: function() {
    return config["ConfigController"];
  },
  setCryptoController: function(controller) {
    requireMethods("CryptoController", ["encrypt", "decrypt"], controller);
    config["CryptoController"] = controller;
  },
  getCryptoController: function() {
    return config["CryptoController"];
  },
  setFileController: function(controller) {
    requireMethods("FileController", ["saveFile", "saveBase64"], controller);
    config["FileController"] = controller;
  },
  getFileController: function() {
    return config["FileController"];
  },
  setInstallationController: function(controller) {
    requireMethods("InstallationController", ["currentInstallationId"], controller);
    config["InstallationController"] = controller;
  },
  getInstallationController: function() {
    return config["InstallationController"];
  },
  setObjectController: function(controller) {
    requireMethods("ObjectController", ["save", "fetch", "destroy"], controller);
    config["ObjectController"] = controller;
  },
  getObjectController: function() {
    return config["ObjectController"];
  },
  setObjectStateController: function(controller) {
    requireMethods("ObjectStateController", ["getState", "initializeState", "removeState", "getServerData", "setServerData", "getPendingOps", "setPendingOp", "pushPendingState", "popPendingState", "mergeFirstPendingState", "getObjectCache", "estimateAttribute", "estimateAttributes", "commitServerChanges", "enqueueTask", "clearAllState"], controller);
    config["ObjectStateController"] = controller;
  },
  getObjectStateController: function() {
    return config["ObjectStateController"];
  },
  setPushController: function(controller) {
    requireMethods("PushController", ["send"], controller);
    config["PushController"] = controller;
  },
  getPushController: function() {
    return config["PushController"];
  },
  setQueryController: function(controller) {
    requireMethods("QueryController", ["find", "aggregate"], controller);
    config["QueryController"] = controller;
  },
  getQueryController: function() {
    return config["QueryController"];
  },
  setRESTController: function(controller) {
    requireMethods("RESTController", ["request", "ajax"], controller);
    config["RESTController"] = controller;
  },
  getRESTController: function() {
    return config["RESTController"];
  },
  setSchemaController: function(controller) {
    requireMethods("SchemaController", ["get", "create", "update", "delete", "send", "purge"], controller);
    config["SchemaController"] = controller;
  },
  getSchemaController: function() {
    return config["SchemaController"];
  },
  setSessionController: function(controller) {
    requireMethods("SessionController", ["getSession"], controller);
    config["SessionController"] = controller;
  },
  getSessionController: function() {
    return config["SessionController"];
  },
  setStorageController: function(controller) {
    if (controller.async) {
      requireMethods("An async StorageController", ["getItemAsync", "setItemAsync", "removeItemAsync", "getAllKeysAsync"], controller);
    } else {
      requireMethods("A synchronous StorageController", ["getItem", "setItem", "removeItem", "getAllKeys"], controller);
    }
    config["StorageController"] = controller;
  },
  setLocalDatastoreController: function(controller) {
    requireMethods("LocalDatastoreController", ["pinWithName", "fromPinWithName", "unPinWithName", "getAllContents", "clear"], controller);
    config["LocalDatastoreController"] = controller;
  },
  getLocalDatastoreController: function() {
    return config["LocalDatastoreController"];
  },
  setLocalDatastore: function(store) {
    config["LocalDatastore"] = store;
  },
  getLocalDatastore: function() {
    return config["LocalDatastore"];
  },
  getStorageController: function() {
    return config["StorageController"];
  },
  setAsyncStorage: function(storage) {
    config["AsyncStorage"] = storage;
  },
  getAsyncStorage: function() {
    return config["AsyncStorage"];
  },
  setWebSocketController: function(controller) {
    config["WebSocketController"] = controller;
  },
  getWebSocketController: function() {
    return config["WebSocketController"];
  },
  setUserController: function(controller) {
    requireMethods("UserController", ["setCurrentUser", "currentUser", "currentUserAsync", "signUp", "logIn", "become", "logOut", "me", "requestPasswordReset", "upgradeToRevocableSession", "requestEmailVerification", "verifyPassword", "linkWith"], controller);
    config["UserController"] = controller;
  },
  getUserController: function() {
    return config["UserController"];
  },
  setLiveQueryController: function(controller) {
    requireMethods("LiveQueryController", ["setDefaultLiveQueryClient", "getDefaultLiveQueryClient", "_clearCachedDefaultClient"], controller);
    config["LiveQueryController"] = controller;
  },
  getLiveQueryController: function() {
    return config["LiveQueryController"];
  },
  setHooksController: function(controller) {
    requireMethods("HooksController", ["create", "get", "update", "remove"], controller);
    config["HooksController"] = controller;
  },
  getHooksController: function() {
    return config["HooksController"];
  }
};
var canBeSerialized = {};
var ParseFile = {};
var slicedToArray = { exports: {} };
var arrayWithHoles = { exports: {} };
var parent$j = isArray$5;
var isArray$2 = parent$j;
var parent$i = isArray$2;
var isArray$1 = parent$i;
var isArray2 = isArray$1;
(function(module) {
  var _Array$isArray3 = isArray2;
  function _arrayWithHoles(arr) {
    if (_Array$isArray3(arr))
      return arr;
  }
  module.exports = _arrayWithHoles;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(arrayWithHoles);
var iterableToArrayLimit = { exports: {} };
(function(module) {
  var _Symbol2 = symbol$1;
  var _getIteratorMethod2 = getIteratorMethod$1;
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof _Symbol2 !== "undefined" && _getIteratorMethod2(arr) || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  module.exports = _iterableToArrayLimit;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(iterableToArrayLimit);
var unsupportedIterableToArray = { exports: {} };
var parent$h = slice$4;
var slice$2 = parent$h;
var parent$g = slice$2;
var slice$1 = parent$g;
var slice2 = slice$1;
var parent$f = from$4;
var from$2 = parent$f;
var parent$e = from$2;
var from$1 = parent$e;
var from3 = from$1;
var arrayLikeToArray = { exports: {} };
(function(module) {
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  module.exports = _arrayLikeToArray2;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(arrayLikeToArray);
(function(module) {
  var _sliceInstanceProperty3 = slice2;
  var _Array$from3 = from3;
  var arrayLikeToArray$1 = arrayLikeToArray.exports;
  function _unsupportedIterableToArray2(o2, minLen) {
    var _context;
    if (!o2)
      return;
    if (typeof o2 === "string")
      return arrayLikeToArray$1(o2, minLen);
    var n2 = _sliceInstanceProperty3(_context = Object.prototype.toString.call(o2)).call(_context, 8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return _Array$from3(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return arrayLikeToArray$1(o2, minLen);
  }
  module.exports = _unsupportedIterableToArray2;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(unsupportedIterableToArray);
var nonIterableRest = { exports: {} };
(function(module) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableRest;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(nonIterableRest);
(function(module) {
  var arrayWithHoles$1 = arrayWithHoles.exports;
  var iterableToArrayLimit$1 = iterableToArrayLimit.exports;
  var unsupportedIterableToArray$1 = unsupportedIterableToArray.exports;
  var nonIterableRest$1 = nonIterableRest.exports;
  function _slicedToArray(arr, i2) {
    return arrayWithHoles$1(arr) || iterableToArrayLimit$1(arr, i2) || unsupportedIterableToArray$1(arr, i2) || nonIterableRest$1();
  }
  module.exports = _slicedToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(slicedToArray);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Object$defineProperties2 = defineProperties4;
  var _Object$getOwnPropertyDescriptors2 = getOwnPropertyDescriptors2;
  var _forEachInstanceProperty2 = forEach2;
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$4;
  var _filterInstanceProperty2 = filter3;
  var _Object$getOwnPropertySymbols2 = getOwnPropertySymbols3;
  var _Object$keys2 = keys$5;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _slicedToArray22 = _interopRequireDefault2(slicedToArray.exports);
  var _promise2 = _interopRequireDefault2(promise$3);
  var _keys4 = _interopRequireDefault2(keys$5);
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _regenerator2 = _interopRequireDefault2(regenerator);
  var _asyncToGenerator22 = _interopRequireDefault2(asyncToGenerator.exports);
  var _slice2 = _interopRequireDefault2(slice$3);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  function ownKeys3(object, enumerableOnly) {
    var keys4 = _Object$keys2(object);
    if (_Object$getOwnPropertySymbols2) {
      var symbols = _Object$getOwnPropertySymbols2(object);
      if (enumerableOnly) {
        symbols = _filterInstanceProperty2(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor2(object, sym).enumerable;
        });
      }
      keys4.push.apply(keys4, symbols);
    }
    return keys4;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        var _context5;
        _forEachInstanceProperty2(_context5 = ownKeys3(Object(source), true)).call(_context5, function(key) {
          (0, _defineProperty22.default)(target, key, source[key]);
        });
      } else if (_Object$getOwnPropertyDescriptors2) {
        _Object$defineProperties2(target, _Object$getOwnPropertyDescriptors2(source));
      } else {
        var _context6;
        _forEachInstanceProperty2(_context6 = ownKeys3(Object(source))).call(_context6, function(key) {
          _Object$defineProperty2(target, key, _Object$getOwnPropertyDescriptor2(source, key));
        });
      }
    }
    return target;
  }
  var ParseError2 = ParseError$1.default;
  var XHR2 = null;
  if (typeof XMLHttpRequest !== "undefined") {
    XHR2 = XMLHttpRequest;
  }
  var dataUriRegexp = /^data:([a-zA-Z]+\/[-a-zA-Z0-9+.]+)(;charset=[a-zA-Z0-9\-\/]*)?;base64,/;
  function b64Digit(number) {
    if (number < 26) {
      return String.fromCharCode(65 + number);
    }
    if (number < 52) {
      return String.fromCharCode(97 + (number - 26));
    }
    if (number < 62) {
      return String.fromCharCode(48 + (number - 52));
    }
    if (number === 62) {
      return "+";
    }
    if (number === 63) {
      return "/";
    }
    throw new TypeError("Tried to encode large digit " + number + " in base64.");
  }
  var ParseFile2 = /* @__PURE__ */ function() {
    function ParseFile3(name, data2, type, metadata, tags) {
      (0, _classCallCheck22.default)(this, ParseFile3);
      (0, _defineProperty22.default)(this, "_name", void 0);
      (0, _defineProperty22.default)(this, "_url", void 0);
      (0, _defineProperty22.default)(this, "_source", void 0);
      (0, _defineProperty22.default)(this, "_previousSave", void 0);
      (0, _defineProperty22.default)(this, "_data", void 0);
      (0, _defineProperty22.default)(this, "_requestTask", void 0);
      (0, _defineProperty22.default)(this, "_metadata", void 0);
      (0, _defineProperty22.default)(this, "_tags", void 0);
      var specifiedType = type || "";
      this._name = name;
      this._metadata = metadata || {};
      this._tags = tags || {};
      if (data2 !== void 0) {
        if ((0, _isArray2.default)(data2)) {
          this._data = ParseFile3.encodeBase64(data2);
          this._source = {
            format: "base64",
            base64: this._data,
            type: specifiedType
          };
        } else if (typeof Blob !== "undefined" && data2 instanceof Blob) {
          this._source = {
            format: "file",
            file: data2,
            type: specifiedType
          };
        } else if (data2 && typeof data2.uri === "string" && data2.uri !== void 0) {
          this._source = {
            format: "uri",
            uri: data2.uri,
            type: specifiedType
          };
        } else if (data2 && typeof data2.base64 === "string") {
          var base64 = data2.base64;
          var commaIndex = (0, _indexOf2.default)(base64).call(base64, ",");
          if (commaIndex !== -1) {
            var matches2 = dataUriRegexp.exec((0, _slice2.default)(base64).call(base64, 0, commaIndex + 1));
            this._data = (0, _slice2.default)(base64).call(base64, commaIndex + 1);
            this._source = {
              format: "base64",
              base64: this._data,
              type: matches2[1]
            };
          } else {
            this._data = base64;
            this._source = {
              format: "base64",
              base64,
              type: specifiedType
            };
          }
        } else {
          throw new TypeError("Cannot create a Parse.File with that data.");
        }
      }
    }
    (0, _createClass22.default)(ParseFile3, [{
      key: "getData",
      value: function() {
        var _getData = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee() {
          var _this = this;
          var options, controller, result;
          return _regenerator2.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this._data) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", this._data);
                case 2:
                  if (this._url) {
                    _context.next = 4;
                    break;
                  }
                  throw new Error("Cannot retrieve data for unsaved ParseFile.");
                case 4:
                  options = {
                    requestTask: function(task2) {
                      return _this._requestTask = task2;
                    }
                  };
                  controller = _CoreManager2.default.getFileController();
                  _context.next = 8;
                  return controller.download(this._url, options);
                case 8:
                  result = _context.sent;
                  this._data = result.base64;
                  return _context.abrupt("return", this._data);
                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        return function() {
          return _getData.apply(this, arguments);
        };
      }()
    }, {
      key: "name",
      value: function() {
        return this._name;
      }
    }, {
      key: "url",
      value: function(options) {
        options = options || {};
        if (!this._url) {
          return;
        }
        if (options.forceSecure) {
          return this._url.replace(/^http:\/\//i, "https://");
        } else {
          return this._url;
        }
      }
    }, {
      key: "metadata",
      value: function() {
        return this._metadata;
      }
    }, {
      key: "tags",
      value: function() {
        return this._tags;
      }
    }, {
      key: "save",
      value: function(options) {
        var _this2 = this;
        options = options || {};
        options.requestTask = function(task2) {
          return _this2._requestTask = task2;
        };
        options.metadata = this._metadata;
        options.tags = this._tags;
        var controller = _CoreManager2.default.getFileController();
        if (!this._previousSave) {
          if (this._source.format === "file") {
            this._previousSave = controller.saveFile(this._name, this._source, options).then(function(res) {
              _this2._name = res.name;
              _this2._url = res.url;
              _this2._data = null;
              _this2._requestTask = null;
              return _this2;
            });
          } else if (this._source.format === "uri") {
            this._previousSave = controller.download(this._source.uri, options).then(function(result) {
              if (!(result && result.base64)) {
                return {};
              }
              var newSource = {
                format: "base64",
                base64: result.base64,
                type: result.contentType
              };
              _this2._data = result.base64;
              _this2._requestTask = null;
              return controller.saveBase64(_this2._name, newSource, options);
            }).then(function(res) {
              _this2._name = res.name;
              _this2._url = res.url;
              _this2._requestTask = null;
              return _this2;
            });
          } else {
            this._previousSave = controller.saveBase64(this._name, this._source, options).then(function(res) {
              _this2._name = res.name;
              _this2._url = res.url;
              _this2._requestTask = null;
              return _this2;
            });
          }
        }
        if (this._previousSave) {
          return this._previousSave;
        }
      }
    }, {
      key: "cancel",
      value: function() {
        if (this._requestTask && typeof this._requestTask.abort === "function") {
          this._requestTask.abort();
        }
        this._requestTask = null;
      }
    }, {
      key: "destroy",
      value: function() {
        var _this3 = this;
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!this._name) {
          throw new ParseError2(ParseError2.FILE_DELETE_UNNAMED_ERROR, "Cannot delete an unnamed file.");
        }
        var destroyOptions = {
          useMasterKey: true
        };
        if (options.hasOwnProperty("useMasterKey")) {
          destroyOptions.useMasterKey = options.useMasterKey;
        }
        var controller = _CoreManager2.default.getFileController();
        return controller.deleteFile(this._name, destroyOptions).then(function() {
          _this3._data = null;
          _this3._requestTask = null;
          return _this3;
        });
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __type: "File",
          name: this._name,
          url: this._url
        };
      }
    }, {
      key: "equals",
      value: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof ParseFile3 && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== "undefined";
      }
    }, {
      key: "setMetadata",
      value: function(metadata) {
        var _this4 = this;
        if (metadata && (0, _typeof22.default)(metadata) === "object") {
          var _context2;
          (0, _forEach2.default)(_context2 = (0, _keys4.default)(metadata)).call(_context2, function(key) {
            _this4.addMetadata(key, metadata[key]);
          });
        }
      }
    }, {
      key: "addMetadata",
      value: function(key, value) {
        if (typeof key === "string") {
          this._metadata[key] = value;
        }
      }
    }, {
      key: "setTags",
      value: function(tags) {
        var _this5 = this;
        if (tags && (0, _typeof22.default)(tags) === "object") {
          var _context3;
          (0, _forEach2.default)(_context3 = (0, _keys4.default)(tags)).call(_context3, function(key) {
            _this5.addTag(key, tags[key]);
          });
        }
      }
    }, {
      key: "addTag",
      value: function(key, value) {
        if (typeof key === "string") {
          this._tags[key] = value;
        }
      }
    }], [{
      key: "fromJSON",
      value: function(obj) {
        if (obj.__type !== "File") {
          throw new TypeError("JSON object does not represent a ParseFile");
        }
        var file = new ParseFile3(obj.name);
        file._url = obj.url;
        return file;
      }
    }, {
      key: "encodeBase64",
      value: function(bytes) {
        var chunks = [];
        chunks.length = Math.ceil(bytes.length / 3);
        for (var i2 = 0; i2 < chunks.length; i2++) {
          var b1 = bytes[i2 * 3];
          var b2 = bytes[i2 * 3 + 1] || 0;
          var b3 = bytes[i2 * 3 + 2] || 0;
          var has2 = i2 * 3 + 1 < bytes.length;
          var has3 = i2 * 3 + 2 < bytes.length;
          chunks[i2] = [b64Digit(b1 >> 2 & 63), b64Digit(b1 << 4 & 48 | b2 >> 4 & 15), has2 ? b64Digit(b2 << 2 & 60 | b3 >> 6 & 3) : "=", has3 ? b64Digit(b3 & 63) : "="].join("");
        }
        return chunks.join("");
      }
    }]);
    return ParseFile3;
  }();
  var DefaultController = {
    saveFile: function() {
      var _saveFile = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee2(name, source, options) {
        var base64Data, _base64Data$split, _base64Data$split2, first, second, data2, newSource;
        return _regenerator2.default.wrap(function(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(source.format !== "file")) {
                  _context4.next = 2;
                  break;
                }
                throw new Error("saveFile can only be used with File-type sources.");
              case 2:
                _context4.next = 4;
                return new _promise2.default(function(res, rej) {
                  var reader = new FileReader();
                  reader.onload = function() {
                    return res(reader.result);
                  };
                  reader.onerror = function(error) {
                    return rej(error);
                  };
                  reader.readAsDataURL(source.file);
                });
              case 4:
                base64Data = _context4.sent;
                _base64Data$split = base64Data.split(","), _base64Data$split2 = (0, _slicedToArray22.default)(_base64Data$split, 2), first = _base64Data$split2[0], second = _base64Data$split2[1];
                data2 = second ? second : first;
                newSource = {
                  format: "base64",
                  base64: data2,
                  type: source.type || (source.file ? source.file.type : null)
                };
                _context4.next = 10;
                return DefaultController.saveBase64(name, newSource, options);
              case 10:
                return _context4.abrupt("return", _context4.sent);
              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee2);
      }));
      return function() {
        return _saveFile.apply(this, arguments);
      };
    }(),
    saveBase64: function(name, source, options) {
      if (source.format !== "base64") {
        throw new Error("saveBase64 can only be used with Base64-type sources.");
      }
      var data2 = {
        base64: source.base64,
        fileData: {
          metadata: _objectSpread2({}, options.metadata),
          tags: _objectSpread2({}, options.tags)
        }
      };
      delete options.metadata;
      delete options.tags;
      if (source.type) {
        data2._ContentType = source.type;
      }
      return _CoreManager2.default.getRESTController().request("POST", "files/" + name, data2, options);
    },
    download: function(uri, options) {
      if (XHR2) {
        return this.downloadAjax(uri, options);
      } else {
        return _promise2.default.reject("Cannot make a request: No definition of XMLHttpRequest was found.");
      }
    },
    downloadAjax: function(uri, options) {
      return new _promise2.default(function(resolve3, reject2) {
        var xhr = new XHR2();
        xhr.open("GET", uri, true);
        xhr.responseType = "arraybuffer";
        xhr.onerror = function(e2) {
          reject2(e2);
        };
        xhr.onreadystatechange = function() {
          if (xhr.readyState !== xhr.DONE) {
            return;
          }
          if (!this.response) {
            return resolve3({});
          }
          var bytes = new Uint8Array(this.response);
          resolve3({
            base64: ParseFile2.encodeBase64(bytes),
            contentType: xhr.getResponseHeader("content-type")
          });
        };
        options.requestTask(xhr);
        xhr.send();
      });
    },
    deleteFile: function(name, options) {
      var headers = {
        "X-Parse-Application-ID": _CoreManager2.default.get("APPLICATION_ID")
      };
      if (options.useMasterKey) {
        headers["X-Parse-Master-Key"] = _CoreManager2.default.get("MASTER_KEY");
      }
      var url = _CoreManager2.default.get("SERVER_URL");
      if (url[url.length - 1] !== "/") {
        url += "/";
      }
      url += "files/" + name;
      return _CoreManager2.default.getRESTController().ajax("DELETE", url, "", headers).catch(function(response) {
        if (!response || response === "SyntaxError: Unexpected end of JSON input") {
          return _promise2.default.resolve();
        } else {
          return _CoreManager2.default.getRESTController().handleError(response);
        }
      });
    },
    _setXHR: function(xhr) {
      XHR2 = xhr;
    },
    _getXHR: function() {
      return XHR2;
    }
  };
  _CoreManager2.default.setFileController(DefaultController);
  var _default = ParseFile2;
  exports.default = _default;
  exports.b64Digit = b64Digit;
})(ParseFile);
var ParseRelation = {};
var ParseOp$1 = {};
var $$a = _export;
var global$4 = global$V;
var toAbsoluteIndex = toAbsoluteIndex$4;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var lengthOfArrayLike$2 = lengthOfArrayLike$a;
var toObject$3 = toObject$c;
var arraySpeciesCreate = arraySpeciesCreate$3;
var createProperty = createProperty$6;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
var TypeError$2 = global$4.TypeError;
var max = Math.max;
var min$1 = Math.min;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
$$a({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount) {
    var O = toObject$3(this);
    var len = lengthOfArrayLike$2(O);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from4, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$1(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError$2(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from4 = actualStart + k;
      if (from4 in O)
        createProperty(A, k, O[from4]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from4 = k + actualDeleteCount;
        to = k + insertCount;
        if (from4 in O)
          O[to] = O[from4];
        else
          delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--)
        delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from4 = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from4 in O)
          O[to] = O[from4];
        else
          delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});
var entryVirtual$8 = entryVirtual$j;
var splice$3 = entryVirtual$8("Array").splice;
var isPrototypeOf$8 = objectIsPrototypeOf;
var method$8 = splice$3;
var ArrayPrototype$7 = Array.prototype;
var splice$2 = function(it) {
  var own = it.splice;
  return it === ArrayPrototype$7 || isPrototypeOf$8(ArrayPrototype$7, it) && own === ArrayPrototype$7.splice ? method$8 : own;
};
var parent$d = splice$2;
var splice$1 = parent$d;
var splice2 = splice$1;
var arrayContainsObject = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = arrayContainsObject2;
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  function arrayContainsObject2(array, object) {
    if ((0, _indexOf2.default)(array).call(array, object) > -1) {
      return true;
    }
    for (var i2 = 0; i2 < array.length; i2++) {
      if (array[i2] instanceof _ParseObject2.default && array[i2].className === object.className && array[i2]._getId() === object._getId()) {
        return true;
      }
    }
    return false;
  }
})(arrayContainsObject);
var encode = {};
var $$9 = _export;
var uncurryThis$5 = functionUncurryThis;
objectGetOwnPropertyDescriptor.f;
var toLength = toLength$2;
var toString$4 = toString$a;
var notARegExp = notARegexp;
var requireObjectCoercible$1 = requireObjectCoercible$6;
var correctIsRegExpLogic = correctIsRegexpLogic;
var un$StartsWith = uncurryThis$5("".startsWith);
var stringSlice = uncurryThis$5("".slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
$$9({ target: "String", proto: true, forced: !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString) {
    var that = toString$4(requireObjectCoercible$1(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$4(searchString);
    return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
  }
});
var entryVirtual$7 = entryVirtual$j;
var startsWith$3 = entryVirtual$7("String").startsWith;
var isPrototypeOf$7 = objectIsPrototypeOf;
var method$7 = startsWith$3;
var StringPrototype = String.prototype;
var startsWith$2 = function(it) {
  var own = it.startsWith;
  return typeof it == "string" || it === StringPrototype || isPrototypeOf$7(StringPrototype, it) && own === StringPrototype.startsWith ? method$7 : own;
};
var parent$c = startsWith$2;
var startsWith$1 = parent$c;
var startsWith2 = startsWith$1;
var ParseGeoPoint$1 = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var ParseGeoPoint2 = /* @__PURE__ */ function() {
    function ParseGeoPoint3(arg1, arg2) {
      (0, _classCallCheck22.default)(this, ParseGeoPoint3);
      (0, _defineProperty22.default)(this, "_latitude", void 0);
      (0, _defineProperty22.default)(this, "_longitude", void 0);
      if ((0, _isArray2.default)(arg1)) {
        ParseGeoPoint3._validate(arg1[0], arg1[1]);
        this._latitude = arg1[0];
        this._longitude = arg1[1];
      } else if ((0, _typeof22.default)(arg1) === "object") {
        ParseGeoPoint3._validate(arg1.latitude, arg1.longitude);
        this._latitude = arg1.latitude;
        this._longitude = arg1.longitude;
      } else if (arg1 !== void 0 && arg2 !== void 0) {
        ParseGeoPoint3._validate(arg1, arg2);
        this._latitude = arg1;
        this._longitude = arg2;
      } else {
        this._latitude = 0;
        this._longitude = 0;
      }
    }
    (0, _createClass22.default)(ParseGeoPoint3, [{
      key: "latitude",
      get: function() {
        return this._latitude;
      },
      set: function(val) {
        ParseGeoPoint3._validate(val, this.longitude);
        this._latitude = val;
      }
    }, {
      key: "longitude",
      get: function() {
        return this._longitude;
      },
      set: function(val) {
        ParseGeoPoint3._validate(this.latitude, val);
        this._longitude = val;
      }
    }, {
      key: "toJSON",
      value: function() {
        ParseGeoPoint3._validate(this._latitude, this._longitude);
        return {
          __type: "GeoPoint",
          latitude: this._latitude,
          longitude: this._longitude
        };
      }
    }, {
      key: "equals",
      value: function(other) {
        return other instanceof ParseGeoPoint3 && this.latitude === other.latitude && this.longitude === other.longitude;
      }
    }, {
      key: "radiansTo",
      value: function(point) {
        var d2r = Math.PI / 180;
        var lat1rad = this.latitude * d2r;
        var long1rad = this.longitude * d2r;
        var lat2rad = point.latitude * d2r;
        var long2rad = point.longitude * d2r;
        var sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);
        var sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2);
        var a = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;
        a = Math.min(1, a);
        return 2 * Math.asin(Math.sqrt(a));
      }
    }, {
      key: "kilometersTo",
      value: function(point) {
        return this.radiansTo(point) * 6371;
      }
    }, {
      key: "milesTo",
      value: function(point) {
        return this.radiansTo(point) * 3958.8;
      }
    }], [{
      key: "_validate",
      value: function(latitude, longitude) {
        if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== "number" || typeof longitude !== "number") {
          throw new TypeError("GeoPoint latitude and longitude must be valid numbers");
        }
        if (latitude < -90) {
          throw new TypeError("GeoPoint latitude out of bounds: " + latitude + " < -90.0.");
        }
        if (latitude > 90) {
          throw new TypeError("GeoPoint latitude out of bounds: " + latitude + " > 90.0.");
        }
        if (longitude < -180) {
          throw new TypeError("GeoPoint longitude out of bounds: " + longitude + " < -180.0.");
        }
        if (longitude > 180) {
          throw new TypeError("GeoPoint longitude out of bounds: " + longitude + " > 180.0.");
        }
      }
    }, {
      key: "current",
      value: function() {
        return navigator.geolocation.getCurrentPosition(function(location2) {
          return new ParseGeoPoint3(location2.coords.latitude, location2.coords.longitude);
        });
      }
    }]);
    return ParseGeoPoint3;
  }();
  var _default = ParseGeoPoint2;
  exports.default = _default;
})(ParseGeoPoint$1);
var ParsePolygon$1 = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _ParseGeoPoint = _interopRequireDefault2(ParseGeoPoint$1);
  var ParsePolygon2 = /* @__PURE__ */ function() {
    function ParsePolygon3(coordinates) {
      (0, _classCallCheck22.default)(this, ParsePolygon3);
      (0, _defineProperty22.default)(this, "_coordinates", void 0);
      this._coordinates = ParsePolygon3._validate(coordinates);
    }
    (0, _createClass22.default)(ParsePolygon3, [{
      key: "coordinates",
      get: function() {
        return this._coordinates;
      },
      set: function(coords) {
        this._coordinates = ParsePolygon3._validate(coords);
      }
    }, {
      key: "toJSON",
      value: function() {
        ParsePolygon3._validate(this._coordinates);
        return {
          __type: "Polygon",
          coordinates: this._coordinates
        };
      }
    }, {
      key: "equals",
      value: function(other) {
        if (!(other instanceof ParsePolygon3) || this.coordinates.length !== other.coordinates.length) {
          return false;
        }
        var isEqual = true;
        for (var i2 = 1; i2 < this._coordinates.length; i2 += 1) {
          if (this._coordinates[i2][0] != other.coordinates[i2][0] || this._coordinates[i2][1] != other.coordinates[i2][1]) {
            isEqual = false;
            break;
          }
        }
        return isEqual;
      }
    }, {
      key: "containsPoint",
      value: function(point) {
        var minX = this._coordinates[0][0];
        var maxX = this._coordinates[0][0];
        var minY = this._coordinates[0][1];
        var maxY = this._coordinates[0][1];
        for (var i2 = 1; i2 < this._coordinates.length; i2 += 1) {
          var p2 = this._coordinates[i2];
          minX = Math.min(p2[0], minX);
          maxX = Math.max(p2[0], maxX);
          minY = Math.min(p2[1], minY);
          maxY = Math.max(p2[1], maxY);
        }
        var outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;
        if (outside) {
          return false;
        }
        var inside = false;
        for (var _i = 0, j = this._coordinates.length - 1; _i < this._coordinates.length; j = _i++) {
          var startX = this._coordinates[_i][0];
          var startY = this._coordinates[_i][1];
          var endX = this._coordinates[j][0];
          var endY = this._coordinates[j][1];
          var intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
    }], [{
      key: "_validate",
      value: function(coords) {
        if (!(0, _isArray2.default)(coords)) {
          throw new TypeError("Coordinates must be an Array");
        }
        if (coords.length < 3) {
          throw new TypeError("Polygon must have at least 3 GeoPoints or Points");
        }
        var points = [];
        for (var i2 = 0; i2 < coords.length; i2 += 1) {
          var coord = coords[i2];
          var geoPoint = void 0;
          if (coord instanceof _ParseGeoPoint.default) {
            geoPoint = coord;
          } else if ((0, _isArray2.default)(coord) && coord.length === 2) {
            geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);
          } else {
            throw new TypeError("Coordinates must be an Array of GeoPoints or Points");
          }
          points.push([geoPoint.latitude, geoPoint.longitude]);
        }
        return points;
      }
    }]);
    return ParsePolygon3;
  }();
  var _default = ParsePolygon2;
  exports.default = _default;
})(ParsePolygon$1);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _map2 = _interopRequireDefault2(map$1);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _concat2 = _interopRequireDefault2(concat$1);
  var _startsWith2 = _interopRequireDefault2(startsWith2);
  var _keys4 = _interopRequireDefault2(keys$5);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _ParseACL = _interopRequireDefault2(ParseACL);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _ParseGeoPoint = _interopRequireDefault2(ParseGeoPoint$1);
  var _ParsePolygon = _interopRequireDefault2(ParsePolygon$1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseOp = ParseOp$1;
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  function encode2(value, disallowObjects, forcePointers, seen, offline) {
    if (value instanceof _ParseObject2.default) {
      if (disallowObjects) {
        throw new Error("Parse Objects not allowed here");
      }
      var seenEntry = value.id ? value.className + ":" + value.id : value;
      if (forcePointers || !seen || (0, _indexOf2.default)(seen).call(seen, seenEntry) > -1 || value.dirty() || (0, _keys4.default)(value._getServerData()).length < 1) {
        var _context;
        if (offline && (0, _startsWith2.default)(_context = value._getId()).call(_context, "local")) {
          return value.toOfflinePointer();
        }
        return value.toPointer();
      }
      seen = (0, _concat2.default)(seen).call(seen, seenEntry);
      return value._toFullJSON(seen, offline);
    }
    if (value instanceof _ParseOp.Op || value instanceof _ParseACL.default || value instanceof _ParseGeoPoint.default || value instanceof _ParsePolygon.default || value instanceof _ParseRelation.default) {
      return value.toJSON();
    }
    if (value instanceof _ParseFile.default) {
      if (!value.url()) {
        throw new Error("Tried to encode an unsaved file.");
      }
      return value.toJSON();
    }
    if (Object.prototype.toString.call(value) === "[object Date]") {
      if (isNaN(value)) {
        throw new Error("Tried to encode an invalid date.");
      }
      return {
        __type: "Date",
        iso: value.toJSON()
      };
    }
    if (Object.prototype.toString.call(value) === "[object RegExp]" && typeof value.source === "string") {
      return value.source;
    }
    if ((0, _isArray2.default)(value)) {
      return (0, _map2.default)(value).call(value, function(v) {
        return encode2(v, disallowObjects, forcePointers, seen, offline);
      });
    }
    if (value && (0, _typeof22.default)(value) === "object") {
      var output = {};
      for (var k in value) {
        output[k] = encode2(value[k], disallowObjects, forcePointers, seen, offline);
      }
      return output;
    }
    return value;
  }
  function _default(value, disallowObjects, forcePointers, seen, offline) {
    return encode2(value, !!disallowObjects, !!forcePointers, seen || [], offline);
  }
})(encode);
var unique = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = unique2;
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _arrayContainsObject = _interopRequireDefault2(arrayContainsObject);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  function unique2(arr) {
    var uniques = [];
    (0, _forEach2.default)(arr).call(arr, function(value) {
      if (value instanceof _ParseObject2.default) {
        if (!(0, _arrayContainsObject.default)(uniques, value)) {
          uniques.push(value);
        }
      } else {
        if ((0, _indexOf2.default)(uniques).call(uniques, value) < 0) {
          uniques.push(value);
        }
      }
    });
    return uniques;
  }
})(unique);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.UnsetOp = exports.SetOp = exports.RemoveOp = exports.RelationOp = exports.Op = exports.IncrementOp = exports.AddUniqueOp = exports.AddOp = void 0;
  exports.opFromJSON = opFromJSON;
  var _map2 = _interopRequireDefault2(map$1);
  var _splice2 = _interopRequireDefault2(splice2);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _assertThisInitialized2 = _interopRequireDefault2(assertThisInitialized.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _concat2 = _interopRequireDefault2(concat$1);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _arrayContainsObject = _interopRequireDefault2(arrayContainsObject);
  var _decode2 = _interopRequireDefault2(decode$2);
  var _encode2 = _interopRequireDefault2(encode);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  var _unique = _interopRequireDefault2(unique);
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function opFromJSON(json) {
    if (!json || !json.__op) {
      return null;
    }
    switch (json.__op) {
      case "Delete":
        return new UnsetOp();
      case "Increment":
        return new IncrementOp(json.amount);
      case "Add":
        return new AddOp((0, _decode2.default)(json.objects));
      case "AddUnique":
        return new AddUniqueOp((0, _decode2.default)(json.objects));
      case "Remove":
        return new RemoveOp((0, _decode2.default)(json.objects));
      case "AddRelation": {
        var toAdd = (0, _decode2.default)(json.objects);
        if (!(0, _isArray2.default)(toAdd)) {
          return new RelationOp([], []);
        }
        return new RelationOp(toAdd, []);
      }
      case "RemoveRelation": {
        var toRemove = (0, _decode2.default)(json.objects);
        if (!(0, _isArray2.default)(toRemove)) {
          return new RelationOp([], []);
        }
        return new RelationOp([], toRemove);
      }
      case "Batch": {
        var _toAdd = [];
        var _toRemove = [];
        for (var i2 = 0; i2 < json.ops.length; i2++) {
          if (json.ops[i2].__op === "AddRelation") {
            _toAdd = (0, _concat2.default)(_toAdd).call(_toAdd, (0, _decode2.default)(json.ops[i2].objects));
          } else if (json.ops[i2].__op === "RemoveRelation") {
            _toRemove = (0, _concat2.default)(_toRemove).call(_toRemove, (0, _decode2.default)(json.ops[i2].objects));
          }
        }
        return new RelationOp(_toAdd, _toRemove);
      }
    }
    return null;
  }
  var Op = /* @__PURE__ */ function() {
    function Op2() {
      (0, _classCallCheck22.default)(this, Op2);
    }
    (0, _createClass22.default)(Op2, [{
      key: "applyTo",
      value: function() {
      }
    }, {
      key: "mergeWith",
      value: function() {
      }
    }, {
      key: "toJSON",
      value: function() {
      }
    }]);
    return Op2;
  }();
  exports.Op = Op;
  var SetOp = /* @__PURE__ */ function(_Op) {
    (0, _inherits2.default)(SetOp2, _Op);
    var _super = _createSuper(SetOp2);
    function SetOp2(value) {
      var _this;
      (0, _classCallCheck22.default)(this, SetOp2);
      _this = _super.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "_value", void 0);
      _this._value = value;
      return _this;
    }
    (0, _createClass22.default)(SetOp2, [{
      key: "applyTo",
      value: function() {
        return this._value;
      }
    }, {
      key: "mergeWith",
      value: function() {
        return new SetOp2(this._value);
      }
    }, {
      key: "toJSON",
      value: function(offline) {
        return (0, _encode2.default)(this._value, false, true, void 0, offline);
      }
    }]);
    return SetOp2;
  }(Op);
  exports.SetOp = SetOp;
  var UnsetOp = /* @__PURE__ */ function(_Op2) {
    (0, _inherits2.default)(UnsetOp2, _Op2);
    var _super2 = _createSuper(UnsetOp2);
    function UnsetOp2() {
      (0, _classCallCheck22.default)(this, UnsetOp2);
      return _super2.apply(this, arguments);
    }
    (0, _createClass22.default)(UnsetOp2, [{
      key: "applyTo",
      value: function() {
        return void 0;
      }
    }, {
      key: "mergeWith",
      value: function() {
        return new UnsetOp2();
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __op: "Delete"
        };
      }
    }]);
    return UnsetOp2;
  }(Op);
  exports.UnsetOp = UnsetOp;
  var IncrementOp = /* @__PURE__ */ function(_Op3) {
    (0, _inherits2.default)(IncrementOp2, _Op3);
    var _super3 = _createSuper(IncrementOp2);
    function IncrementOp2(amount) {
      var _this2;
      (0, _classCallCheck22.default)(this, IncrementOp2);
      _this2 = _super3.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this2), "_amount", void 0);
      if (typeof amount !== "number") {
        throw new TypeError("Increment Op must be initialized with a numeric amount.");
      }
      _this2._amount = amount;
      return _this2;
    }
    (0, _createClass22.default)(IncrementOp2, [{
      key: "applyTo",
      value: function(value) {
        if (typeof value === "undefined") {
          return this._amount;
        }
        if (typeof value !== "number") {
          throw new TypeError("Cannot increment a non-numeric value.");
        }
        return this._amount + value;
      }
    }, {
      key: "mergeWith",
      value: function(previous) {
        if (!previous) {
          return this;
        }
        if (previous instanceof SetOp) {
          return new SetOp(this.applyTo(previous._value));
        }
        if (previous instanceof UnsetOp) {
          return new SetOp(this._amount);
        }
        if (previous instanceof IncrementOp2) {
          return new IncrementOp2(this.applyTo(previous._amount));
        }
        throw new Error("Cannot merge Increment Op with the previous Op");
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __op: "Increment",
          amount: this._amount
        };
      }
    }]);
    return IncrementOp2;
  }(Op);
  exports.IncrementOp = IncrementOp;
  var AddOp = /* @__PURE__ */ function(_Op4) {
    (0, _inherits2.default)(AddOp2, _Op4);
    var _super4 = _createSuper(AddOp2);
    function AddOp2(value) {
      var _this3;
      (0, _classCallCheck22.default)(this, AddOp2);
      _this3 = _super4.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this3), "_value", void 0);
      _this3._value = (0, _isArray2.default)(value) ? value : [value];
      return _this3;
    }
    (0, _createClass22.default)(AddOp2, [{
      key: "applyTo",
      value: function(value) {
        if (value == null) {
          return this._value;
        }
        if ((0, _isArray2.default)(value)) {
          return (0, _concat2.default)(value).call(value, this._value);
        }
        throw new Error("Cannot add elements to a non-array value");
      }
    }, {
      key: "mergeWith",
      value: function(previous) {
        if (!previous) {
          return this;
        }
        if (previous instanceof SetOp) {
          return new SetOp(this.applyTo(previous._value));
        }
        if (previous instanceof UnsetOp) {
          return new SetOp(this._value);
        }
        if (previous instanceof AddOp2) {
          return new AddOp2(this.applyTo(previous._value));
        }
        throw new Error("Cannot merge Add Op with the previous Op");
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __op: "Add",
          objects: (0, _encode2.default)(this._value, false, true)
        };
      }
    }]);
    return AddOp2;
  }(Op);
  exports.AddOp = AddOp;
  var AddUniqueOp = /* @__PURE__ */ function(_Op5) {
    (0, _inherits2.default)(AddUniqueOp2, _Op5);
    var _super5 = _createSuper(AddUniqueOp2);
    function AddUniqueOp2(value) {
      var _this4;
      (0, _classCallCheck22.default)(this, AddUniqueOp2);
      _this4 = _super5.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this4), "_value", void 0);
      _this4._value = (0, _unique.default)((0, _isArray2.default)(value) ? value : [value]);
      return _this4;
    }
    (0, _createClass22.default)(AddUniqueOp2, [{
      key: "applyTo",
      value: function(value) {
        if (value == null) {
          return this._value || [];
        }
        if ((0, _isArray2.default)(value)) {
          var _context;
          var toAdd = [];
          (0, _forEach2.default)(_context = this._value).call(_context, function(v) {
            if (v instanceof _ParseObject2.default) {
              if (!(0, _arrayContainsObject.default)(value, v)) {
                toAdd.push(v);
              }
            } else {
              if ((0, _indexOf2.default)(value).call(value, v) < 0) {
                toAdd.push(v);
              }
            }
          });
          return (0, _concat2.default)(value).call(value, toAdd);
        }
        throw new Error("Cannot add elements to a non-array value");
      }
    }, {
      key: "mergeWith",
      value: function(previous) {
        if (!previous) {
          return this;
        }
        if (previous instanceof SetOp) {
          return new SetOp(this.applyTo(previous._value));
        }
        if (previous instanceof UnsetOp) {
          return new SetOp(this._value);
        }
        if (previous instanceof AddUniqueOp2) {
          return new AddUniqueOp2(this.applyTo(previous._value));
        }
        throw new Error("Cannot merge AddUnique Op with the previous Op");
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __op: "AddUnique",
          objects: (0, _encode2.default)(this._value, false, true)
        };
      }
    }]);
    return AddUniqueOp2;
  }(Op);
  exports.AddUniqueOp = AddUniqueOp;
  var RemoveOp = /* @__PURE__ */ function(_Op6) {
    (0, _inherits2.default)(RemoveOp2, _Op6);
    var _super6 = _createSuper(RemoveOp2);
    function RemoveOp2(value) {
      var _this5;
      (0, _classCallCheck22.default)(this, RemoveOp2);
      _this5 = _super6.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this5), "_value", void 0);
      _this5._value = (0, _unique.default)((0, _isArray2.default)(value) ? value : [value]);
      return _this5;
    }
    (0, _createClass22.default)(RemoveOp2, [{
      key: "applyTo",
      value: function(value) {
        if (value == null) {
          return [];
        }
        if ((0, _isArray2.default)(value)) {
          var removed = (0, _concat2.default)(value).call(value, []);
          for (var i2 = 0; i2 < this._value.length; i2++) {
            var index = (0, _indexOf2.default)(removed).call(removed, this._value[i2]);
            while (index > -1) {
              (0, _splice2.default)(removed).call(removed, index, 1);
              index = (0, _indexOf2.default)(removed).call(removed, this._value[i2]);
            }
            if (this._value[i2] instanceof _ParseObject2.default && this._value[i2].id) {
              for (var j = 0; j < removed.length; j++) {
                if (removed[j] instanceof _ParseObject2.default && this._value[i2].id === removed[j].id) {
                  (0, _splice2.default)(removed).call(removed, j, 1);
                  j--;
                }
              }
            }
          }
          return removed;
        }
        throw new Error("Cannot remove elements from a non-array value");
      }
    }, {
      key: "mergeWith",
      value: function(previous) {
        if (!previous) {
          return this;
        }
        if (previous instanceof SetOp) {
          return new SetOp(this.applyTo(previous._value));
        }
        if (previous instanceof UnsetOp) {
          return new UnsetOp();
        }
        if (previous instanceof RemoveOp2) {
          var _context2;
          var uniques = (0, _concat2.default)(_context2 = previous._value).call(_context2, []);
          for (var i2 = 0; i2 < this._value.length; i2++) {
            if (this._value[i2] instanceof _ParseObject2.default) {
              if (!(0, _arrayContainsObject.default)(uniques, this._value[i2])) {
                uniques.push(this._value[i2]);
              }
            } else {
              if ((0, _indexOf2.default)(uniques).call(uniques, this._value[i2]) < 0) {
                uniques.push(this._value[i2]);
              }
            }
          }
          return new RemoveOp2(uniques);
        }
        throw new Error("Cannot merge Remove Op with the previous Op");
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __op: "Remove",
          objects: (0, _encode2.default)(this._value, false, true)
        };
      }
    }]);
    return RemoveOp2;
  }(Op);
  exports.RemoveOp = RemoveOp;
  var RelationOp = /* @__PURE__ */ function(_Op7) {
    (0, _inherits2.default)(RelationOp2, _Op7);
    var _super7 = _createSuper(RelationOp2);
    function RelationOp2(adds, removes) {
      var _this6;
      (0, _classCallCheck22.default)(this, RelationOp2);
      _this6 = _super7.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this6), "_targetClassName", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this6), "relationsToAdd", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this6), "relationsToRemove", void 0);
      _this6._targetClassName = null;
      if ((0, _isArray2.default)(adds)) {
        _this6.relationsToAdd = (0, _unique.default)((0, _map2.default)(adds).call(adds, _this6._extractId, (0, _assertThisInitialized2.default)(_this6)));
      }
      if ((0, _isArray2.default)(removes)) {
        _this6.relationsToRemove = (0, _unique.default)((0, _map2.default)(removes).call(removes, _this6._extractId, (0, _assertThisInitialized2.default)(_this6)));
      }
      return _this6;
    }
    (0, _createClass22.default)(RelationOp2, [{
      key: "_extractId",
      value: function(obj) {
        if (typeof obj === "string") {
          return obj;
        }
        if (!obj.id) {
          throw new Error("You cannot add or remove an unsaved Parse Object from a relation");
        }
        if (!this._targetClassName) {
          this._targetClassName = obj.className;
        }
        if (this._targetClassName !== obj.className) {
          throw new Error("Tried to create a Relation with 2 different object types: " + this._targetClassName + " and " + obj.className + ".");
        }
        return obj.id;
      }
    }, {
      key: "applyTo",
      value: function(value, object, key) {
        if (!value) {
          var _context3;
          if (!object || !key) {
            throw new Error("Cannot apply a RelationOp without either a previous value, or an object and a key");
          }
          var parent2 = new _ParseObject2.default(object.className);
          if (object.id && (0, _indexOf2.default)(_context3 = object.id).call(_context3, "local") === 0) {
            parent2._localId = object.id;
          } else if (object.id) {
            parent2.id = object.id;
          }
          var relation = new _ParseRelation.default(parent2, key);
          relation.targetClassName = this._targetClassName;
          return relation;
        }
        if (value instanceof _ParseRelation.default) {
          if (this._targetClassName) {
            if (value.targetClassName) {
              if (this._targetClassName !== value.targetClassName) {
                throw new Error("Related object must be a " + value.targetClassName + ", but a " + this._targetClassName + " was passed in.");
              }
            } else {
              value.targetClassName = this._targetClassName;
            }
          }
          return value;
        } else {
          throw new Error("Relation cannot be applied to a non-relation field");
        }
      }
    }, {
      key: "mergeWith",
      value: function(previous) {
        if (!previous) {
          return this;
        } else if (previous instanceof UnsetOp) {
          throw new Error("You cannot modify a relation after deleting it.");
        } else if (previous instanceof SetOp && previous._value instanceof _ParseRelation.default) {
          return this;
        } else if (previous instanceof RelationOp2) {
          var _context4, _context5, _context6, _context7, _context8, _context9;
          if (previous._targetClassName && previous._targetClassName !== this._targetClassName) {
            throw new Error("Related object must be of class " + previous._targetClassName + ", but " + (this._targetClassName || "null") + " was passed in.");
          }
          var newAdd = (0, _concat2.default)(_context4 = previous.relationsToAdd).call(_context4, []);
          (0, _forEach2.default)(_context5 = this.relationsToRemove).call(_context5, function(r2) {
            var index = (0, _indexOf2.default)(newAdd).call(newAdd, r2);
            if (index > -1) {
              (0, _splice2.default)(newAdd).call(newAdd, index, 1);
            }
          });
          (0, _forEach2.default)(_context6 = this.relationsToAdd).call(_context6, function(r2) {
            var index = (0, _indexOf2.default)(newAdd).call(newAdd, r2);
            if (index < 0) {
              newAdd.push(r2);
            }
          });
          var newRemove = (0, _concat2.default)(_context7 = previous.relationsToRemove).call(_context7, []);
          (0, _forEach2.default)(_context8 = this.relationsToAdd).call(_context8, function(r2) {
            var index = (0, _indexOf2.default)(newRemove).call(newRemove, r2);
            if (index > -1) {
              (0, _splice2.default)(newRemove).call(newRemove, index, 1);
            }
          });
          (0, _forEach2.default)(_context9 = this.relationsToRemove).call(_context9, function(r2) {
            var index = (0, _indexOf2.default)(newRemove).call(newRemove, r2);
            if (index < 0) {
              newRemove.push(r2);
            }
          });
          var newRelation = new RelationOp2(newAdd, newRemove);
          newRelation._targetClassName = this._targetClassName;
          return newRelation;
        }
        throw new Error("Cannot merge Relation Op with the previous Op");
      }
    }, {
      key: "toJSON",
      value: function() {
        var _this7 = this;
        var idToPointer = function(id2) {
          return {
            __type: "Pointer",
            className: _this7._targetClassName,
            objectId: id2
          };
        };
        var adds = null;
        var removes = null;
        var pointers = null;
        if (this.relationsToAdd.length > 0) {
          var _context10;
          pointers = (0, _map2.default)(_context10 = this.relationsToAdd).call(_context10, idToPointer);
          adds = {
            __op: "AddRelation",
            objects: pointers
          };
        }
        if (this.relationsToRemove.length > 0) {
          var _context11;
          pointers = (0, _map2.default)(_context11 = this.relationsToRemove).call(_context11, idToPointer);
          removes = {
            __op: "RemoveRelation",
            objects: pointers
          };
        }
        if (adds && removes) {
          return {
            __op: "Batch",
            ops: [adds, removes]
          };
        }
        return adds || removes || {};
      }
    }]);
    return RelationOp2;
  }(Op);
  exports.RelationOp = RelationOp;
})(ParseOp$1);
var ParseQuery = {};
var DESCRIPTORS$1 = descriptors;
var uncurryThis$4 = functionUncurryThis;
var objectKeys$1 = objectKeys$4;
var toIndexedObject = toIndexedObject$b;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable3 = uncurryThis$4($propertyIsEnumerable);
var push$1 = uncurryThis$4([].push);
var createMethod$2 = function(TO_ENTRIES) {
  return function(it) {
    var O = toIndexedObject(it);
    var keys4 = objectKeys$1(O);
    var length = keys4.length;
    var i2 = 0;
    var result = [];
    var key;
    while (length > i2) {
      key = keys4[i2++];
      if (!DESCRIPTORS$1 || propertyIsEnumerable3(O, key)) {
        push$1(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};
var objectToArray = {
  entries: createMethod$2(true),
  values: createMethod$2(false)
};
var $$8 = _export;
var $entries = objectToArray.entries;
$$8({ target: "Object", stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});
var path$6 = path$u;
var entries$7 = path$6.Object.entries;
var parent$b = entries$7;
var entries$6 = parent$b;
var entries$5 = entries$6;
var toConsumableArray = { exports: {} };
var arrayWithoutHoles = { exports: {} };
(function(module) {
  var _Array$isArray3 = isArray2;
  var arrayLikeToArray$1 = arrayLikeToArray.exports;
  function _arrayWithoutHoles(arr) {
    if (_Array$isArray3(arr))
      return arrayLikeToArray$1(arr);
  }
  module.exports = _arrayWithoutHoles;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(arrayWithoutHoles);
var iterableToArray = { exports: {} };
(function(module) {
  var _Symbol2 = symbol$1;
  var _getIteratorMethod2 = getIteratorMethod$1;
  var _Array$from3 = from3;
  function _iterableToArray(iter) {
    if (typeof _Symbol2 !== "undefined" && _getIteratorMethod2(iter) != null || iter["@@iterator"] != null)
      return _Array$from3(iter);
  }
  module.exports = _iterableToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(iterableToArray);
var nonIterableSpread = { exports: {} };
(function(module) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableSpread;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(nonIterableSpread);
(function(module) {
  var arrayWithoutHoles$1 = arrayWithoutHoles.exports;
  var iterableToArray$1 = iterableToArray.exports;
  var unsupportedIterableToArray$1 = unsupportedIterableToArray.exports;
  var nonIterableSpread$1 = nonIterableSpread.exports;
  function _toConsumableArray(arr) {
    return arrayWithoutHoles$1(arr) || iterableToArray$1(arr) || unsupportedIterableToArray$1(arr) || nonIterableSpread$1();
  }
  module.exports = _toConsumableArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
})(toConsumableArray);
var arraySlice$1 = arraySliceSimple;
var floor$1 = Math.floor;
var mergeSort = function(array, comparefn) {
  var length = array.length;
  var middle = floor$1(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge2(array, mergeSort(arraySlice$1(array, 0, middle), comparefn), mergeSort(arraySlice$1(array, middle), comparefn), comparefn);
};
var insertionSort = function(array, comparefn) {
  var length = array.length;
  var i2 = 1;
  var element, j;
  while (i2 < length) {
    j = i2;
    element = array[i2];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i2++)
      array[j] = element;
  }
  return array;
};
var merge2 = function(array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
  }
  return array;
};
var arraySort = mergeSort;
var userAgent$2 = engineUserAgent;
var firefox = userAgent$2.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];
var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent$1 = engineUserAgent;
var webkit = userAgent$1.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];
var $$7 = _export;
var uncurryThis$3 = functionUncurryThis;
var aCallable$1 = aCallable$m;
var toObject$2 = toObject$c;
var lengthOfArrayLike$1 = lengthOfArrayLike$a;
var toString$3 = toString$a;
var fails$2 = fails$u;
var internalSort = arraySort;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$5;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var un$Sort = uncurryThis$3(test.sort);
var push = uncurryThis$3(test.push);
var FAILS_ON_UNDEFINED = fails$2(function() {
  test.sort(void 0);
});
var FAILS_ON_NULL = fails$2(function() {
  test.sort(null);
});
var STRICT_METHOD$2 = arrayMethodIsStrict$2("sort");
var STABLE_SORT = !fails$2(function() {
  if (V8)
    return V8 < 70;
  if (FF && FF > 3)
    return;
  if (IE_OR_EDGE)
    return true;
  if (WEBKIT)
    return WEBKIT < 603;
  var result = "";
  var code, chr, value, index;
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);
    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }
  test.sort(function(a, b) {
    return b.v - a.v;
  });
  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr)
      result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$2 || !STABLE_SORT;
var getSortCompare = function(comparefn) {
  return function(x, y) {
    if (y === void 0)
      return -1;
    if (x === void 0)
      return 1;
    if (comparefn !== void 0)
      return +comparefn(x, y) || 0;
    return toString$3(x) > toString$3(y) ? 1 : -1;
  };
};
$$7({ target: "Array", proto: true, forced: FORCED$1 }, {
  sort: function sort(comparefn) {
    if (comparefn !== void 0)
      aCallable$1(comparefn);
    var array = toObject$2(this);
    if (STABLE_SORT)
      return comparefn === void 0 ? un$Sort(array) : un$Sort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike$1(array);
    var itemsLength, index;
    for (index = 0; index < arrayLength; index++) {
      if (index in array)
        push(items, array[index]);
    }
    internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;
    while (index < itemsLength)
      array[index] = items[index++];
    while (index < arrayLength)
      delete array[index++];
    return array;
  }
});
var entryVirtual$6 = entryVirtual$j;
var sort$3 = entryVirtual$6("Array").sort;
var isPrototypeOf$6 = objectIsPrototypeOf;
var method$6 = sort$3;
var ArrayPrototype$6 = Array.prototype;
var sort$2 = function(it) {
  var own = it.sort;
  return it === ArrayPrototype$6 || isPrototypeOf$6(ArrayPrototype$6, it) && own === ArrayPrototype$6.sort ? method$6 : own;
};
var parent$a = sort$2;
var sort$1 = parent$a;
var sort2 = sort$1;
var entryVirtual$5 = entryVirtual$j;
var keys$4 = entryVirtual$5("Array").keys;
var parent$9 = keys$4;
var keys$3 = parent$9;
var classof$2 = classof$d;
var hasOwn$2 = hasOwnProperty_1;
var isPrototypeOf$5 = objectIsPrototypeOf;
var method$5 = keys$3;
var ArrayPrototype$5 = Array.prototype;
var DOMIterables$2 = {
  DOMTokenList: true,
  NodeList: true
};
var keys$2 = function(it) {
  var own = it.keys;
  return it === ArrayPrototype$5 || isPrototypeOf$5(ArrayPrototype$5, it) && own === ArrayPrototype$5.keys || hasOwn$2(DOMIterables$2, classof$2(it)) ? method$5 : own;
};
var keys$1 = keys$2;
var promiseUtils = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.continueWhile = continueWhile;
  exports.resolvingPromise = resolvingPromise;
  exports.when = when;
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _promise2 = _interopRequireDefault2(promise$3);
  function resolvingPromise() {
    var res;
    var rej;
    var promise2 = new _promise2.default(function(resolve3, reject2) {
      res = resolve3;
      rej = reject2;
    });
    promise2.resolve = res;
    promise2.reject = rej;
    return promise2;
  }
  function when(promises) {
    var objects;
    var arrayArgument = (0, _isArray2.default)(promises);
    if (arrayArgument) {
      objects = promises;
    } else {
      objects = arguments;
    }
    var total = objects.length;
    var hadError = false;
    var results = [];
    var returnValue = arrayArgument ? [results] : results;
    var errors = [];
    results.length = objects.length;
    errors.length = objects.length;
    if (total === 0) {
      return _promise2.default.resolve(returnValue);
    }
    var promise2 = new resolvingPromise();
    var resolveOne = function() {
      total--;
      if (total <= 0) {
        if (hadError) {
          promise2.reject(errors);
        } else {
          promise2.resolve(returnValue);
        }
      }
    };
    var chain = function(object, index) {
      if (object && typeof object.then === "function") {
        object.then(function(result) {
          results[index] = result;
          resolveOne();
        }, function(error) {
          errors[index] = error;
          hadError = true;
          resolveOne();
        });
      } else {
        results[index] = object;
        resolveOne();
      }
    };
    for (var i2 = 0; i2 < objects.length; i2++) {
      chain(objects[i2], i2);
    }
    return promise2;
  }
  function continueWhile(test2, emitter) {
    if (test2()) {
      return emitter().then(function() {
        return continueWhile(test2, emitter);
      });
    }
    return _promise2.default.resolve();
  }
})(promiseUtils);
var isObject$1 = isObject$o;
var floor = Math.floor;
var isIntegralNumber$1 = Number.isInteger || function isInteger(it) {
  return !isObject$1(it) && isFinite(it) && floor(it) === it;
};
var $$6 = _export;
var isIntegralNumber = isIntegralNumber$1;
$$6({ target: "Number", stat: true }, {
  isInteger: isIntegralNumber
});
var path$5 = path$u;
var isInteger$2 = path$5.Number.isInteger;
var parent$8 = isInteger$2;
var isInteger$1 = parent$8;
var isInteger2 = isInteger$1;
var equals = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = equals2;
  var _keys4 = _interopRequireDefault2(keys$5);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _ParseACL = _interopRequireDefault2(ParseACL);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _ParseGeoPoint = _interopRequireDefault2(ParseGeoPoint$1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  function equals2(a, b) {
    var toString3 = Object.prototype.toString;
    if (toString3.call(a) === "[object Date]" || toString3.call(b) === "[object Date]") {
      var dateA = new Date(a);
      var dateB = new Date(b);
      return +dateA === +dateB;
    }
    if ((0, _typeof22.default)(a) !== (0, _typeof22.default)(b)) {
      return false;
    }
    if (!a || (0, _typeof22.default)(a) !== "object") {
      return a === b;
    }
    if ((0, _isArray2.default)(a) || (0, _isArray2.default)(b)) {
      if (!(0, _isArray2.default)(a) || !(0, _isArray2.default)(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (var i2 = a.length; i2--; ) {
        if (!equals2(a[i2], b[i2])) {
          return false;
        }
      }
      return true;
    }
    if (a instanceof _ParseACL.default || a instanceof _ParseFile.default || a instanceof _ParseGeoPoint.default || a instanceof _ParseObject2.default) {
      return a.equals(b);
    }
    if (b instanceof _ParseObject2.default) {
      if (a.__type === "Object" || a.__type === "Pointer") {
        return a.objectId === b.id && a.className === b.className;
      }
    }
    if ((0, _keys4.default)(a).length !== (0, _keys4.default)(b).length) {
      return false;
    }
    for (var k in a) {
      if (!equals2(a[k], b[k])) {
        return false;
      }
    }
    return true;
  }
})(equals);
var _interopRequireDefault$9 = interopRequireDefault.exports;
var _Array$isArray2$1 = isArray$4;
var _getIteratorMethod$2 = getIteratorMethod$1;
var _Symbol$2 = symbol;
var _Array$from$1 = from$3;
var _sliceInstanceProperty2 = slice$3;
var _keys = _interopRequireDefault$9(keys$5);
var _forEach = _interopRequireDefault$9(forEach2);
var _map$2 = _interopRequireDefault$9(map$1);
var _concat$1 = _interopRequireDefault$9(concat$1);
var _typeof2$1 = _interopRequireDefault$9(_typeof$1.exports);
var _isInteger = _interopRequireDefault$9(isInteger2);
var _slicedToArray2$1 = _interopRequireDefault$9(slicedToArray.exports);
var _slice = _interopRequireDefault$9(slice$3);
var _filter$1 = _interopRequireDefault$9(filter3);
var _isArray$1 = _interopRequireDefault$9(isArray$4);
var _indexOf = _interopRequireDefault$9(indexOf2);
function _createForOfIteratorHelper$2(o2, allowArrayLike) {
  var it = typeof _Symbol$2 !== "undefined" && _getIteratorMethod$2(o2) || o2["@@iterator"];
  if (!it) {
    if (_Array$isArray2$1(o2) || (it = _unsupportedIterableToArray$2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o2);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _unsupportedIterableToArray$2(o2, minLen) {
  var _context6;
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n2 = _sliceInstanceProperty2(_context6 = Object.prototype.toString.call(o2)).call(_context6, 8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return _Array$from$1(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var equalObjects = equals.default;
var decode$1 = decode$2.default;
var ParseError = ParseError$1.default;
var ParsePolygon = ParsePolygon$1.default;
var ParseGeoPoint = ParseGeoPoint$1.default;
function contains(haystack, needle) {
  if (needle && needle.__type && (needle.__type === "Pointer" || needle.__type === "Object")) {
    for (var i2 in haystack) {
      var ptr = haystack[i2];
      if (typeof ptr === "string" && ptr === needle.objectId) {
        return true;
      }
      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {
        return true;
      }
    }
    return false;
  }
  return (0, _indexOf.default)(haystack).call(haystack, needle) > -1;
}
function transformObject(object) {
  if (object._toFullJSON) {
    return object._toFullJSON();
  }
  return object;
}
function matchesQuery(className, object, objects, query) {
  if (object.className !== className) {
    return false;
  }
  var obj = object;
  var q = query;
  if (object.toJSON) {
    obj = object.toJSON();
  }
  if (query.toJSON) {
    q = query.toJSON().where;
  }
  obj.className = className;
  for (var field in q) {
    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {
      return false;
    }
  }
  return true;
}
function equalObjectsGeneric(obj, compareTo, eqlFn) {
  if ((0, _isArray$1.default)(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      if (eqlFn(obj[i2], compareTo)) {
        return true;
      }
    }
    return false;
  }
  return eqlFn(obj, compareTo);
}
function relativeTimeToDate(text) {
  var now = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date();
  text = text.toLowerCase();
  var parts = text.split(" ");
  parts = (0, _filter$1.default)(parts).call(parts, function(part) {
    return part !== "";
  });
  var future = parts[0] === "in";
  var past = parts[parts.length - 1] === "ago";
  if (!future && !past && text !== "now") {
    return {
      status: "error",
      info: "Time should either start with 'in' or end with 'ago'"
    };
  }
  if (future && past) {
    return {
      status: "error",
      info: "Time cannot have both 'in' and 'ago'"
    };
  }
  if (future) {
    parts = (0, _slice.default)(parts).call(parts, 1);
  } else {
    parts = (0, _slice.default)(parts).call(parts, 0, parts.length - 1);
  }
  if (parts.length % 2 !== 0 && text !== "now") {
    return {
      status: "error",
      info: "Invalid time string. Dangling unit or number."
    };
  }
  var pairs = [];
  while (parts.length) {
    pairs.push([parts.shift(), parts.shift()]);
  }
  var seconds = 0;
  for (var _i = 0, _pairs = pairs; _i < _pairs.length; _i++) {
    var _pairs$_i = (0, _slicedToArray2$1.default)(_pairs[_i], 2), num = _pairs$_i[0], interval = _pairs$_i[1];
    var val = Number(num);
    if (!(0, _isInteger.default)(val)) {
      return {
        status: "error",
        info: "'".concat(num, "' is not an integer.")
      };
    }
    switch (interval) {
      case "yr":
      case "yrs":
      case "year":
      case "years":
        seconds += val * 31536e3;
        break;
      case "wk":
      case "wks":
      case "week":
      case "weeks":
        seconds += val * 604800;
        break;
      case "d":
      case "day":
      case "days":
        seconds += val * 86400;
        break;
      case "hr":
      case "hrs":
      case "hour":
      case "hours":
        seconds += val * 3600;
        break;
      case "min":
      case "mins":
      case "minute":
      case "minutes":
        seconds += val * 60;
        break;
      case "sec":
      case "secs":
      case "second":
      case "seconds":
        seconds += val;
        break;
      default:
        return {
          status: "error",
          info: "Invalid interval: '".concat(interval, "'")
        };
    }
  }
  var milliseconds = seconds * 1e3;
  if (future) {
    return {
      status: "success",
      info: "future",
      result: new Date(now.valueOf() + milliseconds)
    };
  } else if (past) {
    return {
      status: "success",
      info: "past",
      result: new Date(now.valueOf() - milliseconds)
    };
  } else {
    return {
      status: "success",
      info: "present",
      result: new Date(now.valueOf())
    };
  }
}
function matchesKeyConstraints(className, object, objects, key, constraints) {
  if (constraints === null) {
    return false;
  }
  if ((0, _indexOf.default)(key).call(key, ".") >= 0) {
    var keyComponents = key.split(".");
    var subObjectKey = keyComponents[0];
    var keyRemainder = (0, _slice.default)(keyComponents).call(keyComponents, 1).join(".");
    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);
  }
  var i2;
  if (key === "$or") {
    for (i2 = 0; i2 < constraints.length; i2++) {
      if (matchesQuery(className, object, objects, constraints[i2])) {
        return true;
      }
    }
    return false;
  }
  if (key === "$and") {
    for (i2 = 0; i2 < constraints.length; i2++) {
      if (!matchesQuery(className, object, objects, constraints[i2])) {
        return false;
      }
    }
    return true;
  }
  if (key === "$nor") {
    for (i2 = 0; i2 < constraints.length; i2++) {
      if (matchesQuery(className, object, objects, constraints[i2])) {
        return false;
      }
    }
    return true;
  }
  if (key === "$relatedTo") {
    return false;
  }
  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {
    throw new ParseError(ParseError.INVALID_KEY_NAME, "Invalid Key: ".concat(key));
  }
  if ((0, _typeof2$1.default)(constraints) !== "object") {
    if ((0, _isArray$1.default)(object[key])) {
      var _context;
      return (0, _indexOf.default)(_context = object[key]).call(_context, constraints) > -1;
    }
    return object[key] === constraints;
  }
  var compareTo;
  if (constraints.__type) {
    if (constraints.__type === "Pointer") {
      return equalObjectsGeneric(object[key], constraints, function(obj, ptr) {
        return typeof obj !== "undefined" && ptr.className === obj.className && ptr.objectId === obj.objectId;
      });
    }
    return equalObjectsGeneric(decode$1(object[key]), decode$1(constraints), equalObjects);
  }
  for (var condition in constraints) {
    compareTo = constraints[condition];
    if (compareTo.__type) {
      compareTo = decode$1(compareTo);
    }
    if (compareTo["$relativeTime"]) {
      var parserResult = relativeTimeToDate(compareTo["$relativeTime"]);
      if (parserResult.status !== "success") {
        var _context2;
        throw new ParseError(ParseError.INVALID_JSON, (0, _concat$1.default)(_context2 = "bad $relativeTime (".concat(key, ") value. ")).call(_context2, parserResult.info));
      }
      compareTo = parserResult.result;
    }
    if (toString.call(compareTo) === "[object Date]" || typeof compareTo === "string" && new Date(compareTo) !== "Invalid Date" && !isNaN(new Date(compareTo))) {
      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);
    }
    switch (condition) {
      case "$lt":
        if (object[key] >= compareTo) {
          return false;
        }
        break;
      case "$lte":
        if (object[key] > compareTo) {
          return false;
        }
        break;
      case "$gt":
        if (object[key] <= compareTo) {
          return false;
        }
        break;
      case "$gte":
        if (object[key] < compareTo) {
          return false;
        }
        break;
      case "$ne":
        if (equalObjects(object[key], compareTo)) {
          return false;
        }
        break;
      case "$in":
        if (!contains(compareTo, object[key])) {
          return false;
        }
        break;
      case "$nin":
        if (contains(compareTo, object[key])) {
          return false;
        }
        break;
      case "$all":
        for (i2 = 0; i2 < compareTo.length; i2++) {
          var _context3;
          if ((0, _indexOf.default)(_context3 = object[key]).call(_context3, compareTo[i2]) < 0) {
            return false;
          }
        }
        break;
      case "$exists": {
        var propertyExists = typeof object[key] !== "undefined";
        var existenceIsRequired = constraints["$exists"];
        if (typeof constraints["$exists"] !== "boolean") {
          break;
        }
        if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {
          return false;
        }
        break;
      }
      case "$regex": {
        if ((0, _typeof2$1.default)(compareTo) === "object") {
          return compareTo.test(object[key]);
        }
        var expString = "";
        var escapeEnd = -2;
        var escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, "\\Q");
        while (escapeStart > -1) {
          expString += compareTo.substring(escapeEnd + 2, escapeStart);
          escapeEnd = (0, _indexOf.default)(compareTo).call(compareTo, "\\E", escapeStart);
          if (escapeEnd > -1) {
            expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\E/g, "\\E").replace(/\W/g, "\\$&");
          }
          escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, "\\Q", escapeEnd);
        }
        expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));
        var modifiers = constraints.$options || "";
        modifiers = modifiers.replace("x", "").replace("s", "");
        var exp = new RegExp(expString, modifiers);
        if (!exp.test(object[key])) {
          return false;
        }
        break;
      }
      case "$nearSphere": {
        if (!compareTo || !object[key]) {
          return false;
        }
        var distance = compareTo.radiansTo(object[key]);
        var max2 = constraints.$maxDistance || Infinity;
        return distance <= max2;
      }
      case "$within": {
        if (!compareTo || !object[key]) {
          return false;
        }
        var southWest = compareTo.$box[0];
        var northEast = compareTo.$box[1];
        if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {
          return false;
        }
        return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;
      }
      case "$options":
        break;
      case "$maxDistance":
        break;
      case "$select": {
        var subQueryObjects = (0, _filter$1.default)(objects).call(objects, function(obj, index, arr) {
          return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);
        });
        for (var _i2 = 0; _i2 < subQueryObjects.length; _i2 += 1) {
          var subObject = transformObject(subQueryObjects[_i2]);
          return equalObjects(object[key], subObject[compareTo.key]);
        }
        return false;
      }
      case "$dontSelect": {
        var _subQueryObjects = (0, _filter$1.default)(objects).call(objects, function(obj, index, arr) {
          return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);
        });
        for (var _i3 = 0; _i3 < _subQueryObjects.length; _i3 += 1) {
          var _subObject = transformObject(_subQueryObjects[_i3]);
          return !equalObjects(object[key], _subObject[compareTo.key]);
        }
        return false;
      }
      case "$inQuery": {
        var _subQueryObjects2 = (0, _filter$1.default)(objects).call(objects, function(obj, index, arr) {
          return matchesQuery(compareTo.className, obj, arr, compareTo.where);
        });
        for (var _i4 = 0; _i4 < _subQueryObjects2.length; _i4 += 1) {
          var _subObject2 = transformObject(_subQueryObjects2[_i4]);
          if (object[key].className === _subObject2.className && object[key].objectId === _subObject2.objectId) {
            return true;
          }
        }
        return false;
      }
      case "$notInQuery": {
        var _subQueryObjects3 = (0, _filter$1.default)(objects).call(objects, function(obj, index, arr) {
          return matchesQuery(compareTo.className, obj, arr, compareTo.where);
        });
        for (var _i5 = 0; _i5 < _subQueryObjects3.length; _i5 += 1) {
          var _subObject3 = transformObject(_subQueryObjects3[_i5]);
          if (object[key].className === _subObject3.className && object[key].objectId === _subObject3.objectId) {
            return false;
          }
        }
        return true;
      }
      case "$containedBy": {
        var _iterator = _createForOfIteratorHelper$2(object[key]), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var value = _step.value;
            if (!contains(compareTo, value)) {
              return false;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return true;
      }
      case "$geoWithin": {
        var _context4;
        var points = (0, _map$2.default)(_context4 = compareTo.$polygon).call(_context4, function(geoPoint) {
          return [geoPoint.latitude, geoPoint.longitude];
        });
        var polygon = new ParsePolygon(points);
        return polygon.containsPoint(object[key]);
      }
      case "$geoIntersects": {
        var _polygon = new ParsePolygon(object[key].coordinates);
        var point = new ParseGeoPoint(compareTo.$point);
        return _polygon.containsPoint(point);
      }
      default:
        return false;
    }
  }
  return true;
}
function validateQuery(query) {
  var _context5;
  var q = query;
  if (query.toJSON) {
    q = query.toJSON().where;
  }
  var specialQuerykeys = ["$and", "$or", "$nor", "_rperm", "_wperm", "_perishable_token", "_email_verify_token", "_email_verify_token_expires_at", "_account_lockout_expires_at", "_failed_login_count"];
  (0, _forEach.default)(_context5 = (0, _keys.default)(q)).call(_context5, function(key) {
    if (q && q[key] && q[key].$regex) {
      if (typeof q[key].$options === "string") {
        if (!q[key].$options.match(/^[imxs]+$/)) {
          throw new ParseError(ParseError.INVALID_QUERY, "Bad $options value for query: ".concat(q[key].$options));
        }
      }
    }
    if ((0, _indexOf.default)(specialQuerykeys).call(specialQuerykeys, key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\.]*$/)) {
      throw new ParseError(ParseError.INVALID_KEY_NAME, "Invalid key name: ".concat(key));
    }
  });
}
var OfflineQuery = {
  matchesQuery,
  validateQuery
};
var OfflineQuery_1 = OfflineQuery;
var LocalDatastoreUtils = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.PIN_PREFIX = exports.OBJECT_PREFIX = exports.DEFAULT_PIN = void 0;
  exports.isLocalDatastoreKey = isLocalDatastoreKey;
  var _startsWith2 = _interopRequireDefault2(startsWith2);
  var DEFAULT_PIN = "_default";
  exports.DEFAULT_PIN = DEFAULT_PIN;
  var PIN_PREFIX = "parsePin_";
  exports.PIN_PREFIX = PIN_PREFIX;
  var OBJECT_PREFIX = "Parse_LDS_";
  exports.OBJECT_PREFIX = OBJECT_PREFIX;
  function isLocalDatastoreKey(key) {
    return !!(key && (key === DEFAULT_PIN || (0, _startsWith2.default)(key).call(key, PIN_PREFIX) || (0, _startsWith2.default)(key).call(key, OBJECT_PREFIX)));
  }
})(LocalDatastoreUtils);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _entries = _interopRequireDefault2(entries$5);
  var _slicedToArray22 = _interopRequireDefault2(slicedToArray.exports);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _toConsumableArray22 = _interopRequireDefault2(toConsumableArray.exports);
  var _find2 = _interopRequireDefault2(find3);
  var _promise2 = _interopRequireDefault2(promise$3);
  var _regenerator2 = _interopRequireDefault2(regenerator);
  var _splice2 = _interopRequireDefault2(splice2);
  var _sort = _interopRequireDefault2(sort2);
  var _includes2 = _interopRequireDefault2(includes4);
  var _concat2 = _interopRequireDefault2(concat$1);
  var _keys4 = _interopRequireDefault2(keys$1);
  var _filter2 = _interopRequireDefault2(filter3);
  var _asyncToGenerator22 = _interopRequireDefault2(asyncToGenerator.exports);
  var _map2 = _interopRequireDefault2(map$1);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _slice2 = _interopRequireDefault2(slice$3);
  var _keys22 = _interopRequireDefault2(keys$5);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _encode2 = _interopRequireDefault2(encode);
  var _promiseUtils2 = promiseUtils;
  var _ParseError2 = _interopRequireDefault2(ParseError$1);
  var _ParseGeoPoint = _interopRequireDefault2(ParseGeoPoint$1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _OfflineQuery = _interopRequireDefault2(OfflineQuery_1);
  var _LocalDatastoreUtils2 = LocalDatastoreUtils;
  function quote(s) {
    return "\\Q" + s.replace("\\E", "\\E\\\\E\\Q") + "\\E";
  }
  function _getClassNameFromQueries(queries) {
    var className = null;
    (0, _forEach2.default)(queries).call(queries, function(q) {
      if (!className) {
        className = q.className;
      }
      if (className !== q.className) {
        throw new Error("All queries must be for the same class.");
      }
    });
    return className;
  }
  function handleSelectResult(data2, select) {
    var serverDataMask = {};
    (0, _forEach2.default)(select).call(select, function(field) {
      var hasSubObjectSelect = (0, _indexOf2.default)(field).call(field, ".") !== -1;
      if (!hasSubObjectSelect && !data2.hasOwnProperty(field)) {
        data2[field] = void 0;
      } else if (hasSubObjectSelect) {
        var pathComponents = field.split(".");
        var _obj = data2;
        var serverMask = serverDataMask;
        (0, _forEach2.default)(pathComponents).call(pathComponents, function(component, index, arr) {
          if (_obj && !_obj.hasOwnProperty(component)) {
            _obj[component] = void 0;
          }
          if (_obj && (0, _typeof22.default)(_obj) === "object") {
            _obj = _obj[component];
          }
          if (index < arr.length - 1) {
            if (!serverMask[component]) {
              serverMask[component] = {};
            }
            serverMask = serverMask[component];
          }
        });
      }
    });
    if ((0, _keys22.default)(serverDataMask).length > 0) {
      var serverData = _CoreManager2.default.getObjectStateController().getServerData({
        id: data2.objectId,
        className: data2.className
      });
      copyMissingDataWithMask(serverData, data2, serverDataMask, false);
    }
  }
  function copyMissingDataWithMask(src, dest, mask, copyThisLevel) {
    if (copyThisLevel) {
      for (var _key in src) {
        if (src.hasOwnProperty(_key) && !dest.hasOwnProperty(_key)) {
          dest[_key] = src[_key];
        }
      }
    }
    for (var _key2 in mask) {
      if (dest[_key2] !== void 0 && dest[_key2] !== null && src !== void 0 && src !== null) {
        copyMissingDataWithMask(src[_key2], dest[_key2], mask[_key2], true);
      }
    }
  }
  function handleOfflineSort(a, b, sorts) {
    var order = sorts[0];
    var operator = (0, _slice2.default)(order).call(order, 0, 1);
    var isDescending = operator === "-";
    if (isDescending) {
      order = order.substring(1);
    }
    if (order === "_created_at") {
      order = "createdAt";
    }
    if (order === "_updated_at") {
      order = "updatedAt";
    }
    if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === "password") {
      throw new _ParseError2.default(_ParseError2.default.INVALID_KEY_NAME, "Invalid Key: ".concat(order));
    }
    var field1 = a.get(order);
    var field2 = b.get(order);
    if (field1 < field2) {
      return isDescending ? 1 : -1;
    }
    if (field1 > field2) {
      return isDescending ? -1 : 1;
    }
    if (sorts.length > 1) {
      var remainingSorts = (0, _slice2.default)(sorts).call(sorts, 1);
      return handleOfflineSort(a, b, remainingSorts);
    }
    return 0;
  }
  var ParseQuery2 = /* @__PURE__ */ function() {
    function ParseQuery3(objectClass) {
      (0, _classCallCheck22.default)(this, ParseQuery3);
      (0, _defineProperty22.default)(this, "className", void 0);
      (0, _defineProperty22.default)(this, "_where", void 0);
      (0, _defineProperty22.default)(this, "_include", void 0);
      (0, _defineProperty22.default)(this, "_exclude", void 0);
      (0, _defineProperty22.default)(this, "_select", void 0);
      (0, _defineProperty22.default)(this, "_limit", void 0);
      (0, _defineProperty22.default)(this, "_skip", void 0);
      (0, _defineProperty22.default)(this, "_count", void 0);
      (0, _defineProperty22.default)(this, "_order", void 0);
      (0, _defineProperty22.default)(this, "_readPreference", void 0);
      (0, _defineProperty22.default)(this, "_includeReadPreference", void 0);
      (0, _defineProperty22.default)(this, "_subqueryReadPreference", void 0);
      (0, _defineProperty22.default)(this, "_queriesLocalDatastore", void 0);
      (0, _defineProperty22.default)(this, "_localDatastorePinName", void 0);
      (0, _defineProperty22.default)(this, "_extraOptions", void 0);
      (0, _defineProperty22.default)(this, "_hint", void 0);
      (0, _defineProperty22.default)(this, "_explain", void 0);
      (0, _defineProperty22.default)(this, "_xhrRequest", void 0);
      if (typeof objectClass === "string") {
        if (objectClass === "User" && _CoreManager2.default.get("PERFORM_USER_REWRITE")) {
          this.className = "_User";
        } else {
          this.className = objectClass;
        }
      } else if (objectClass instanceof _ParseObject2.default) {
        this.className = objectClass.className;
      } else if (typeof objectClass === "function") {
        if (typeof objectClass.className === "string") {
          this.className = objectClass.className;
        } else {
          var _obj2 = new objectClass();
          this.className = _obj2.className;
        }
      } else {
        throw new TypeError("A ParseQuery must be constructed with a ParseObject or class name.");
      }
      this._where = {};
      this._include = [];
      this._exclude = [];
      this._count = false;
      this._limit = -1;
      this._skip = 0;
      this._readPreference = null;
      this._includeReadPreference = null;
      this._subqueryReadPreference = null;
      this._queriesLocalDatastore = false;
      this._localDatastorePinName = null;
      this._extraOptions = {};
      this._xhrRequest = {
        task: null,
        onchange: function() {
        }
      };
    }
    (0, _createClass22.default)(ParseQuery3, [{
      key: "_orQuery",
      value: function(queries) {
        var queryJSON = (0, _map2.default)(queries).call(queries, function(q) {
          return q.toJSON().where;
        });
        this._where.$or = queryJSON;
        return this;
      }
    }, {
      key: "_andQuery",
      value: function(queries) {
        var queryJSON = (0, _map2.default)(queries).call(queries, function(q) {
          return q.toJSON().where;
        });
        this._where.$and = queryJSON;
        return this;
      }
    }, {
      key: "_norQuery",
      value: function(queries) {
        var queryJSON = (0, _map2.default)(queries).call(queries, function(q) {
          return q.toJSON().where;
        });
        this._where.$nor = queryJSON;
        return this;
      }
    }, {
      key: "_addCondition",
      value: function(key, condition, value) {
        if (!this._where[key] || typeof this._where[key] === "string") {
          this._where[key] = {};
        }
        this._where[key][condition] = (0, _encode2.default)(value, false, true);
        return this;
      }
    }, {
      key: "_regexStartWith",
      value: function(string) {
        return "^" + quote(string);
      }
    }, {
      key: "_handleOfflineQuery",
      value: function() {
        var _handleOfflineQuery2 = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee(params) {
          var _context, _this2 = this;
          var localDatastore, objects, results, keys4, alwaysSelectedKeys, sorts, count, limit;
          return _regenerator2.default.wrap(function(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _OfflineQuery.default.validateQuery(this);
                  localDatastore = _CoreManager2.default.getLocalDatastore();
                  _context3.next = 4;
                  return localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);
                case 4:
                  objects = _context3.sent;
                  results = (0, _filter2.default)(_context = (0, _map2.default)(objects).call(objects, function(json, index, arr) {
                    var object = _ParseObject2.default.fromJSON(json, false);
                    if (json._localId && !json.objectId) {
                      object._localId = json._localId;
                    }
                    if (!_OfflineQuery.default.matchesQuery(_this2.className, object, arr, _this2)) {
                      return null;
                    }
                    return object;
                  })).call(_context, function(object) {
                    return object !== null;
                  });
                  if ((0, _keys4.default)(params)) {
                    keys4 = (0, _keys4.default)(params).split(",");
                    alwaysSelectedKeys = ["className", "objectId", "createdAt", "updatedAt", "ACL"];
                    keys4 = (0, _concat2.default)(keys4).call(keys4, alwaysSelectedKeys);
                    results = (0, _map2.default)(results).call(results, function(object) {
                      var _context2;
                      var json = object._toFullJSON();
                      (0, _forEach2.default)(_context2 = (0, _keys22.default)(json)).call(_context2, function(key) {
                        if (!(0, _includes2.default)(keys4).call(keys4, key)) {
                          delete json[key];
                        }
                      });
                      return _ParseObject2.default.fromJSON(json, false);
                    });
                  }
                  if (params.order) {
                    sorts = params.order.split(",");
                    (0, _sort.default)(results).call(results, function(a, b) {
                      return handleOfflineSort(a, b, sorts);
                    });
                  }
                  if (params.count) {
                    count = results.length;
                  }
                  if (params.skip) {
                    if (params.skip >= results.length) {
                      results = [];
                    } else {
                      results = (0, _splice2.default)(results).call(results, params.skip, results.length);
                    }
                  }
                  limit = results.length;
                  if (params.limit !== 0 && params.limit < results.length) {
                    limit = params.limit;
                  }
                  results = (0, _splice2.default)(results).call(results, 0, limit);
                  if (!(typeof count === "number")) {
                    _context3.next = 15;
                    break;
                  }
                  return _context3.abrupt("return", {
                    results,
                    count
                  });
                case 15:
                  return _context3.abrupt("return", results);
                case 16:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee, this);
        }));
        return function() {
          return _handleOfflineQuery2.apply(this, arguments);
        };
      }()
    }, {
      key: "toJSON",
      value: function() {
        var params = {
          where: this._where
        };
        if (this._include.length) {
          params.include = this._include.join(",");
        }
        if (this._exclude.length) {
          params.excludeKeys = this._exclude.join(",");
        }
        if (this._select) {
          params.keys = this._select.join(",");
        }
        if (this._count) {
          params.count = 1;
        }
        if (this._limit >= 0) {
          params.limit = this._limit;
        }
        if (this._skip > 0) {
          params.skip = this._skip;
        }
        if (this._order) {
          params.order = this._order.join(",");
        }
        if (this._readPreference) {
          params.readPreference = this._readPreference;
        }
        if (this._includeReadPreference) {
          params.includeReadPreference = this._includeReadPreference;
        }
        if (this._subqueryReadPreference) {
          params.subqueryReadPreference = this._subqueryReadPreference;
        }
        if (this._hint) {
          params.hint = this._hint;
        }
        if (this._explain) {
          params.explain = true;
        }
        for (var _key3 in this._extraOptions) {
          params[_key3] = this._extraOptions[_key3];
        }
        return params;
      }
    }, {
      key: "withJSON",
      value: function(json) {
        if (json.where) {
          this._where = json.where;
        }
        if (json.include) {
          this._include = json.include.split(",");
        }
        if ((0, _keys4.default)(json)) {
          this._select = (0, _keys4.default)(json).split(",");
        }
        if (json.excludeKeys) {
          this._exclude = json.excludeKeys.split(",");
        }
        if (json.count) {
          this._count = json.count === 1;
        }
        if (json.limit) {
          this._limit = json.limit;
        }
        if (json.skip) {
          this._skip = json.skip;
        }
        if (json.order) {
          this._order = json.order.split(",");
        }
        if (json.readPreference) {
          this._readPreference = json.readPreference;
        }
        if (json.includeReadPreference) {
          this._includeReadPreference = json.includeReadPreference;
        }
        if (json.subqueryReadPreference) {
          this._subqueryReadPreference = json.subqueryReadPreference;
        }
        if (json.hint) {
          this._hint = json.hint;
        }
        if (json.explain) {
          this._explain = !!json.explain;
        }
        for (var _key4 in json) {
          if (json.hasOwnProperty(_key4)) {
            var _context4;
            if ((0, _indexOf2.default)(_context4 = ["where", "include", "keys", "count", "limit", "skip", "order", "readPreference", "includeReadPreference", "subqueryReadPreference", "hint", "explain"]).call(_context4, _key4) === -1) {
              this._extraOptions[_key4] = json[_key4];
            }
          }
        }
        return this;
      }
    }, {
      key: "get",
      value: function(objectId, options) {
        this.equalTo("objectId", objectId);
        var firstOptions = {};
        if (options && options.hasOwnProperty("useMasterKey")) {
          firstOptions.useMasterKey = options.useMasterKey;
        }
        if (options && options.hasOwnProperty("sessionToken")) {
          firstOptions.sessionToken = options.sessionToken;
        }
        if (options && options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          firstOptions.context = options.context;
        }
        if (options && options.hasOwnProperty("json")) {
          firstOptions.json = options.json;
        }
        return this.first(firstOptions).then(function(response) {
          if (response) {
            return response;
          }
          var errorObject = new _ParseError2.default(_ParseError2.default.OBJECT_NOT_FOUND, "Object not found.");
          return _promise2.default.reject(errorObject);
        });
      }
    }, {
      key: "find",
      value: function(options) {
        var _this3 = this;
        options = options || {};
        var findOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          findOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          findOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          findOptions.context = options.context;
        }
        this._setRequestTask(findOptions);
        var controller = _CoreManager2.default.getQueryController();
        var select = this._select;
        if (this._queriesLocalDatastore) {
          return this._handleOfflineQuery(this.toJSON());
        }
        return (0, _find2.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(function(response) {
          var _context5;
          if (_this3._explain) {
            return response.results;
          }
          var results = (0, _map2.default)(_context5 = response.results).call(_context5, function(data2) {
            var override = response.className || _this3.className;
            if (!data2.className) {
              data2.className = override;
            }
            if (select) {
              handleSelectResult(data2, select);
            }
            if (options.json) {
              return data2;
            } else {
              return _ParseObject2.default.fromJSON(data2, !select);
            }
          });
          var count = response.count;
          if (typeof count === "number") {
            return {
              results,
              count
            };
          } else {
            return results;
          }
        });
      }
    }, {
      key: "findAll",
      value: function() {
        var _findAll = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee2(options) {
          var result;
          return _regenerator2.default.wrap(function(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  result = [];
                  _context7.next = 3;
                  return this.eachBatch(function(objects) {
                    var _context6;
                    result = (0, _concat2.default)(_context6 = []).call(_context6, (0, _toConsumableArray22.default)(result), (0, _toConsumableArray22.default)(objects));
                  }, options);
                case 3:
                  return _context7.abrupt("return", result);
                case 4:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee2, this);
        }));
        return function() {
          return _findAll.apply(this, arguments);
        };
      }()
    }, {
      key: "count",
      value: function(options) {
        options = options || {};
        var findOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          findOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          findOptions.sessionToken = options.sessionToken;
        }
        this._setRequestTask(findOptions);
        var controller = _CoreManager2.default.getQueryController();
        var params = this.toJSON();
        params.limit = 0;
        params.count = 1;
        return (0, _find2.default)(controller).call(controller, this.className, params, findOptions).then(function(result) {
          return result.count;
        });
      }
    }, {
      key: "distinct",
      value: function(key, options) {
        options = options || {};
        var distinctOptions = {};
        distinctOptions.useMasterKey = true;
        if (options.hasOwnProperty("sessionToken")) {
          distinctOptions.sessionToken = options.sessionToken;
        }
        this._setRequestTask(distinctOptions);
        var controller = _CoreManager2.default.getQueryController();
        var params = {
          distinct: key,
          where: this._where,
          hint: this._hint
        };
        return controller.aggregate(this.className, params, distinctOptions).then(function(results) {
          return results.results;
        });
      }
    }, {
      key: "aggregate",
      value: function(pipeline, options) {
        options = options || {};
        var aggregateOptions = {};
        aggregateOptions.useMasterKey = true;
        if (options.hasOwnProperty("sessionToken")) {
          aggregateOptions.sessionToken = options.sessionToken;
        }
        this._setRequestTask(aggregateOptions);
        var controller = _CoreManager2.default.getQueryController();
        if (!(0, _isArray2.default)(pipeline) && (0, _typeof22.default)(pipeline) !== "object") {
          throw new Error("Invalid pipeline must be Array or Object");
        }
        if ((0, _keys22.default)(this._where || {}).length) {
          if (!(0, _isArray2.default)(pipeline)) {
            pipeline = [pipeline];
          }
          pipeline.unshift({
            match: this._where
          });
        }
        var params = {
          pipeline,
          hint: this._hint,
          explain: this._explain,
          readPreference: this._readPreference
        };
        return controller.aggregate(this.className, params, aggregateOptions).then(function(results) {
          return results.results;
        });
      }
    }, {
      key: "first",
      value: function(options) {
        var _this4 = this;
        options = options || {};
        var findOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          findOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          findOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          findOptions.context = options.context;
        }
        this._setRequestTask(findOptions);
        var controller = _CoreManager2.default.getQueryController();
        var params = this.toJSON();
        params.limit = 1;
        var select = this._select;
        if (this._queriesLocalDatastore) {
          return this._handleOfflineQuery(params).then(function(objects) {
            if (!objects[0]) {
              return void 0;
            }
            return objects[0];
          });
        }
        return (0, _find2.default)(controller).call(controller, this.className, params, findOptions).then(function(response) {
          var objects = response.results;
          if (!objects[0]) {
            return void 0;
          }
          if (!objects[0].className) {
            objects[0].className = _this4.className;
          }
          if (select) {
            handleSelectResult(objects[0], select);
          }
          if (options.json) {
            return objects[0];
          } else {
            return _ParseObject2.default.fromJSON(objects[0], !select);
          }
        });
      }
    }, {
      key: "eachBatch",
      value: function(callback, options) {
        var _context8;
        options = options || {};
        if (this._order || this._skip || this._limit >= 0) {
          return _promise2.default.reject("Cannot iterate on a query with sort, skip, or limit.");
        }
        var query = new ParseQuery3(this.className);
        query._limit = options.batchSize || 100;
        query._include = (0, _map2.default)(_context8 = this._include).call(_context8, function(i2) {
          return i2;
        });
        if (this._select) {
          var _context9;
          query._select = (0, _map2.default)(_context9 = this._select).call(_context9, function(s) {
            return s;
          });
        }
        query._hint = this._hint;
        query._where = {};
        for (var _attr in this._where) {
          var val = this._where[_attr];
          if ((0, _isArray2.default)(val)) {
            query._where[_attr] = (0, _map2.default)(val).call(val, function(v) {
              return v;
            });
          } else if (val && (0, _typeof22.default)(val) === "object") {
            var conditionMap = {};
            query._where[_attr] = conditionMap;
            for (var cond in val) {
              conditionMap[cond] = val[cond];
            }
          } else {
            query._where[_attr] = val;
          }
        }
        query.ascending("objectId");
        var findOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          findOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          findOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          findOptions.context = options.context;
        }
        var finished = false;
        var previousResults = [];
        return (0, _promiseUtils2.continueWhile)(function() {
          return !finished;
        }, /* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee3() {
          var _yield$Promise$all, _yield$Promise$all2, results;
          return _regenerator2.default.wrap(function(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.next = 2;
                  return _promise2.default.all([(0, _find2.default)(query).call(query, findOptions), _promise2.default.resolve(previousResults.length > 0 && callback(previousResults))]);
                case 2:
                  _yield$Promise$all = _context10.sent;
                  _yield$Promise$all2 = (0, _slicedToArray22.default)(_yield$Promise$all, 1);
                  results = _yield$Promise$all2[0];
                  if (!(results.length >= query._limit)) {
                    _context10.next = 10;
                    break;
                  }
                  query.greaterThan("objectId", results[results.length - 1].id);
                  previousResults = results;
                  _context10.next = 17;
                  break;
                case 10:
                  if (!(results.length > 0)) {
                    _context10.next = 16;
                    break;
                  }
                  _context10.next = 13;
                  return _promise2.default.resolve(callback(results));
                case 13:
                  finished = true;
                  _context10.next = 17;
                  break;
                case 16:
                  finished = true;
                case 17:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee3);
        })));
      }
    }, {
      key: "each",
      value: function(callback, options) {
        return this.eachBatch(function(results) {
          var callbacksDone = _promise2.default.resolve();
          (0, _forEach2.default)(results).call(results, function(result) {
            callbacksDone = callbacksDone.then(function() {
              return callback(result);
            });
          });
          return callbacksDone;
        }, options);
      }
    }, {
      key: "hint",
      value: function(value) {
        if (typeof value === "undefined") {
          delete this._hint;
        }
        this._hint = value;
        return this;
      }
    }, {
      key: "explain",
      value: function() {
        var _explain = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (typeof _explain !== "boolean") {
          throw new Error("You can only set explain to a boolean value");
        }
        this._explain = _explain;
        return this;
      }
    }, {
      key: "map",
      value: function() {
        var _map3 = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee4(callback, options) {
          var _this5 = this;
          var array, index;
          return _regenerator2.default.wrap(function(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  array = [];
                  index = 0;
                  _context11.next = 4;
                  return this.each(function(object) {
                    return _promise2.default.resolve(callback(object, index, _this5)).then(function(result) {
                      array.push(result);
                      index += 1;
                    });
                  }, options);
                case 4:
                  return _context11.abrupt("return", array);
                case 5:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee4, this);
        }));
        return function() {
          return _map3.apply(this, arguments);
        };
      }()
    }, {
      key: "reduce",
      value: function() {
        var _reduce2 = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee5(callback, initialValue, options) {
          var accumulator, index;
          return _regenerator2.default.wrap(function(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  accumulator = initialValue;
                  index = 0;
                  _context12.next = 4;
                  return this.each(function(object) {
                    if (index === 0 && initialValue === void 0) {
                      accumulator = object;
                      index += 1;
                      return;
                    }
                    return _promise2.default.resolve(callback(accumulator, object, index)).then(function(result) {
                      accumulator = result;
                      index += 1;
                    });
                  }, options);
                case 4:
                  if (!(index === 0 && initialValue === void 0)) {
                    _context12.next = 6;
                    break;
                  }
                  throw new TypeError("Reducing empty query result set with no initial value");
                case 6:
                  return _context12.abrupt("return", accumulator);
                case 7:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee5, this);
        }));
        return function() {
          return _reduce2.apply(this, arguments);
        };
      }()
    }, {
      key: "filter",
      value: function() {
        var _filter3 = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee6(callback, options) {
          var _this6 = this;
          var array, index;
          return _regenerator2.default.wrap(function(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  array = [];
                  index = 0;
                  _context13.next = 4;
                  return this.each(function(object) {
                    return _promise2.default.resolve(callback(object, index, _this6)).then(function(flag) {
                      if (flag) {
                        array.push(object);
                      }
                      index += 1;
                    });
                  }, options);
                case 4:
                  return _context13.abrupt("return", array);
                case 5:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee6, this);
        }));
        return function() {
          return _filter3.apply(this, arguments);
        };
      }()
    }, {
      key: "equalTo",
      value: function(key, value) {
        var _this7 = this;
        if (key && (0, _typeof22.default)(key) === "object") {
          var _context14;
          (0, _forEach2.default)(_context14 = (0, _entries.default)(key)).call(_context14, function(_ref2) {
            var _ref3 = (0, _slicedToArray22.default)(_ref2, 2), k = _ref3[0], val = _ref3[1];
            return _this7.equalTo(k, val);
          });
          return this;
        }
        if (typeof value === "undefined") {
          return this.doesNotExist(key);
        }
        this._where[key] = (0, _encode2.default)(value, false, true);
        return this;
      }
    }, {
      key: "notEqualTo",
      value: function(key, value) {
        var _this8 = this;
        if (key && (0, _typeof22.default)(key) === "object") {
          var _context15;
          (0, _forEach2.default)(_context15 = (0, _entries.default)(key)).call(_context15, function(_ref4) {
            var _ref5 = (0, _slicedToArray22.default)(_ref4, 2), k = _ref5[0], val = _ref5[1];
            return _this8.notEqualTo(k, val);
          });
          return this;
        }
        return this._addCondition(key, "$ne", value);
      }
    }, {
      key: "lessThan",
      value: function(key, value) {
        return this._addCondition(key, "$lt", value);
      }
    }, {
      key: "greaterThan",
      value: function(key, value) {
        return this._addCondition(key, "$gt", value);
      }
    }, {
      key: "lessThanOrEqualTo",
      value: function(key, value) {
        return this._addCondition(key, "$lte", value);
      }
    }, {
      key: "greaterThanOrEqualTo",
      value: function(key, value) {
        return this._addCondition(key, "$gte", value);
      }
    }, {
      key: "containedIn",
      value: function(key, value) {
        return this._addCondition(key, "$in", value);
      }
    }, {
      key: "notContainedIn",
      value: function(key, value) {
        return this._addCondition(key, "$nin", value);
      }
    }, {
      key: "containedBy",
      value: function(key, values2) {
        return this._addCondition(key, "$containedBy", values2);
      }
    }, {
      key: "containsAll",
      value: function(key, values2) {
        return this._addCondition(key, "$all", values2);
      }
    }, {
      key: "containsAllStartingWith",
      value: function(key, values2) {
        var _this = this;
        if (!(0, _isArray2.default)(values2)) {
          values2 = [values2];
        }
        var regexObject = (0, _map2.default)(values2).call(values2, function(value) {
          return {
            $regex: _this._regexStartWith(value)
          };
        });
        return this.containsAll(key, regexObject);
      }
    }, {
      key: "exists",
      value: function(key) {
        return this._addCondition(key, "$exists", true);
      }
    }, {
      key: "doesNotExist",
      value: function(key) {
        return this._addCondition(key, "$exists", false);
      }
    }, {
      key: "matches",
      value: function(key, regex, modifiers) {
        this._addCondition(key, "$regex", regex);
        if (!modifiers) {
          modifiers = "";
        }
        if (regex.ignoreCase) {
          modifiers += "i";
        }
        if (regex.multiline) {
          modifiers += "m";
        }
        if (modifiers.length) {
          this._addCondition(key, "$options", modifiers);
        }
        return this;
      }
    }, {
      key: "matchesQuery",
      value: function(key, query) {
        var queryJSON = query.toJSON();
        queryJSON.className = query.className;
        return this._addCondition(key, "$inQuery", queryJSON);
      }
    }, {
      key: "doesNotMatchQuery",
      value: function(key, query) {
        var queryJSON = query.toJSON();
        queryJSON.className = query.className;
        return this._addCondition(key, "$notInQuery", queryJSON);
      }
    }, {
      key: "matchesKeyInQuery",
      value: function(key, queryKey, query) {
        var queryJSON = query.toJSON();
        queryJSON.className = query.className;
        return this._addCondition(key, "$select", {
          key: queryKey,
          query: queryJSON
        });
      }
    }, {
      key: "doesNotMatchKeyInQuery",
      value: function(key, queryKey, query) {
        var queryJSON = query.toJSON();
        queryJSON.className = query.className;
        return this._addCondition(key, "$dontSelect", {
          key: queryKey,
          query: queryJSON
        });
      }
    }, {
      key: "contains",
      value: function(key, substring) {
        if (typeof substring !== "string") {
          throw new Error("The value being searched for must be a string.");
        }
        return this._addCondition(key, "$regex", quote(substring));
      }
    }, {
      key: "fullText",
      value: function(key, value, options) {
        options = options || {};
        if (!key) {
          throw new Error("A key is required.");
        }
        if (!value) {
          throw new Error("A search term is required");
        }
        if (typeof value !== "string") {
          throw new Error("The value being searched for must be a string.");
        }
        var fullOptions = {};
        fullOptions.$term = value;
        for (var option in options) {
          switch (option) {
            case "language":
              fullOptions.$language = options[option];
              break;
            case "caseSensitive":
              fullOptions.$caseSensitive = options[option];
              break;
            case "diacriticSensitive":
              fullOptions.$diacriticSensitive = options[option];
              break;
            default:
              throw new Error("Unknown option: ".concat(option));
          }
        }
        return this._addCondition(key, "$text", {
          $search: fullOptions
        });
      }
    }, {
      key: "sortByTextScore",
      value: function() {
        this.ascending("$score");
        this.select(["$score"]);
        return this;
      }
    }, {
      key: "startsWith",
      value: function(key, prefix, modifiers) {
        if (typeof prefix !== "string") {
          throw new Error("The value being searched for must be a string.");
        }
        return this.matches(key, this._regexStartWith(prefix), modifiers);
      }
    }, {
      key: "endsWith",
      value: function(key, suffix, modifiers) {
        if (typeof suffix !== "string") {
          throw new Error("The value being searched for must be a string.");
        }
        return this.matches(key, quote(suffix) + "$", modifiers);
      }
    }, {
      key: "near",
      value: function(key, point) {
        if (!(point instanceof _ParseGeoPoint.default)) {
          point = new _ParseGeoPoint.default(point);
        }
        return this._addCondition(key, "$nearSphere", point);
      }
    }, {
      key: "withinRadians",
      value: function(key, point, maxDistance, sorted) {
        if (sorted || sorted === void 0) {
          this.near(key, point);
          return this._addCondition(key, "$maxDistance", maxDistance);
        } else {
          return this._addCondition(key, "$geoWithin", {
            $centerSphere: [[point.longitude, point.latitude], maxDistance]
          });
        }
      }
    }, {
      key: "withinMiles",
      value: function(key, point, maxDistance, sorted) {
        return this.withinRadians(key, point, maxDistance / 3958.8, sorted);
      }
    }, {
      key: "withinKilometers",
      value: function(key, point, maxDistance, sorted) {
        return this.withinRadians(key, point, maxDistance / 6371, sorted);
      }
    }, {
      key: "withinGeoBox",
      value: function(key, southwest, northeast) {
        if (!(southwest instanceof _ParseGeoPoint.default)) {
          southwest = new _ParseGeoPoint.default(southwest);
        }
        if (!(northeast instanceof _ParseGeoPoint.default)) {
          northeast = new _ParseGeoPoint.default(northeast);
        }
        this._addCondition(key, "$within", {
          $box: [southwest, northeast]
        });
        return this;
      }
    }, {
      key: "withinPolygon",
      value: function(key, points) {
        return this._addCondition(key, "$geoWithin", {
          $polygon: points
        });
      }
    }, {
      key: "polygonContains",
      value: function(key, point) {
        return this._addCondition(key, "$geoIntersects", {
          $point: point
        });
      }
    }, {
      key: "ascending",
      value: function() {
        this._order = [];
        for (var _len = arguments.length, keys4 = new Array(_len), _key5 = 0; _key5 < _len; _key5++) {
          keys4[_key5] = arguments[_key5];
        }
        return this.addAscending.apply(this, keys4);
      }
    }, {
      key: "addAscending",
      value: function() {
        var _this9 = this;
        if (!this._order) {
          this._order = [];
        }
        for (var _len2 = arguments.length, keys4 = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {
          keys4[_key6] = arguments[_key6];
        }
        (0, _forEach2.default)(keys4).call(keys4, function(key) {
          var _context16;
          if ((0, _isArray2.default)(key)) {
            key = key.join();
          }
          _this9._order = (0, _concat2.default)(_context16 = _this9._order).call(_context16, key.replace(/\s/g, "").split(","));
        });
        return this;
      }
    }, {
      key: "descending",
      value: function() {
        this._order = [];
        for (var _len3 = arguments.length, keys4 = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {
          keys4[_key7] = arguments[_key7];
        }
        return this.addDescending.apply(this, keys4);
      }
    }, {
      key: "addDescending",
      value: function() {
        var _this10 = this;
        if (!this._order) {
          this._order = [];
        }
        for (var _len4 = arguments.length, keys4 = new Array(_len4), _key8 = 0; _key8 < _len4; _key8++) {
          keys4[_key8] = arguments[_key8];
        }
        (0, _forEach2.default)(keys4).call(keys4, function(key) {
          var _context17, _context18;
          if ((0, _isArray2.default)(key)) {
            key = key.join();
          }
          _this10._order = (0, _concat2.default)(_context17 = _this10._order).call(_context17, (0, _map2.default)(_context18 = key.replace(/\s/g, "").split(",")).call(_context18, function(k) {
            return "-" + k;
          }));
        });
        return this;
      }
    }, {
      key: "skip",
      value: function(n2) {
        if (typeof n2 !== "number" || n2 < 0) {
          throw new Error("You can only skip by a positive number");
        }
        this._skip = n2;
        return this;
      }
    }, {
      key: "limit",
      value: function(n2) {
        if (typeof n2 !== "number") {
          throw new Error("You can only set the limit to a numeric value");
        }
        this._limit = n2;
        return this;
      }
    }, {
      key: "withCount",
      value: function() {
        var includeCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (typeof includeCount !== "boolean") {
          throw new Error("You can only set withCount to a boolean value");
        }
        this._count = includeCount;
        return this;
      }
    }, {
      key: "include",
      value: function() {
        var _this11 = this;
        for (var _len5 = arguments.length, keys4 = new Array(_len5), _key9 = 0; _key9 < _len5; _key9++) {
          keys4[_key9] = arguments[_key9];
        }
        (0, _forEach2.default)(keys4).call(keys4, function(key) {
          if ((0, _isArray2.default)(key)) {
            var _context19;
            _this11._include = (0, _concat2.default)(_context19 = _this11._include).call(_context19, key);
          } else {
            _this11._include.push(key);
          }
        });
        return this;
      }
    }, {
      key: "includeAll",
      value: function() {
        return this.include("*");
      }
    }, {
      key: "select",
      value: function() {
        var _this12 = this;
        if (!this._select) {
          this._select = [];
        }
        for (var _len6 = arguments.length, keys4 = new Array(_len6), _key10 = 0; _key10 < _len6; _key10++) {
          keys4[_key10] = arguments[_key10];
        }
        (0, _forEach2.default)(keys4).call(keys4, function(key) {
          if ((0, _isArray2.default)(key)) {
            var _context20;
            _this12._select = (0, _concat2.default)(_context20 = _this12._select).call(_context20, key);
          } else {
            _this12._select.push(key);
          }
        });
        return this;
      }
    }, {
      key: "exclude",
      value: function() {
        var _this13 = this;
        for (var _len7 = arguments.length, keys4 = new Array(_len7), _key11 = 0; _key11 < _len7; _key11++) {
          keys4[_key11] = arguments[_key11];
        }
        (0, _forEach2.default)(keys4).call(keys4, function(key) {
          if ((0, _isArray2.default)(key)) {
            var _context21;
            _this13._exclude = (0, _concat2.default)(_context21 = _this13._exclude).call(_context21, key);
          } else {
            _this13._exclude.push(key);
          }
        });
        return this;
      }
    }, {
      key: "readPreference",
      value: function(_readPreference, includeReadPreference, subqueryReadPreference) {
        this._readPreference = _readPreference;
        this._includeReadPreference = includeReadPreference;
        this._subqueryReadPreference = subqueryReadPreference;
        return this;
      }
    }, {
      key: "subscribe",
      value: function() {
        var _subscribe = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee7(sessionToken) {
          var currentUser, liveQueryClient, subscription;
          return _regenerator2.default.wrap(function(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  _context22.next = 2;
                  return _CoreManager2.default.getUserController().currentUserAsync();
                case 2:
                  currentUser = _context22.sent;
                  if (!sessionToken) {
                    sessionToken = currentUser ? currentUser.getSessionToken() : void 0;
                  }
                  _context22.next = 6;
                  return _CoreManager2.default.getLiveQueryController().getDefaultLiveQueryClient();
                case 6:
                  liveQueryClient = _context22.sent;
                  if (liveQueryClient.shouldOpen()) {
                    liveQueryClient.open();
                  }
                  subscription = liveQueryClient.subscribe(this, sessionToken);
                  return _context22.abrupt("return", subscription.subscribePromise.then(function() {
                    return subscription;
                  }));
                case 10:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee7, this);
        }));
        return function() {
          return _subscribe.apply(this, arguments);
        };
      }()
    }, {
      key: "fromNetwork",
      value: function() {
        this._queriesLocalDatastore = false;
        this._localDatastorePinName = null;
        return this;
      }
    }, {
      key: "fromLocalDatastore",
      value: function() {
        return this.fromPinWithName(null);
      }
    }, {
      key: "fromPin",
      value: function() {
        return this.fromPinWithName(_LocalDatastoreUtils2.DEFAULT_PIN);
      }
    }, {
      key: "fromPinWithName",
      value: function(name) {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (localDatastore.checkIfEnabled()) {
          this._queriesLocalDatastore = true;
          this._localDatastorePinName = name;
        }
        return this;
      }
    }, {
      key: "cancel",
      value: function() {
        var _this14 = this;
        if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === "function") {
          this._xhrRequest.task._aborted = true;
          this._xhrRequest.task.abort();
          this._xhrRequest.task = null;
          this._xhrRequest.onchange = function() {
          };
          return this;
        }
        return this._xhrRequest.onchange = function() {
          return _this14.cancel();
        };
      }
    }, {
      key: "_setRequestTask",
      value: function(options) {
        var _this15 = this;
        options.requestTask = function(task2) {
          _this15._xhrRequest.task = task2;
          _this15._xhrRequest.onchange();
        };
      }
    }], [{
      key: "fromJSON",
      value: function(className, json) {
        var query = new ParseQuery3(className);
        return query.withJSON(json);
      }
    }, {
      key: "or",
      value: function() {
        for (var _len8 = arguments.length, queries = new Array(_len8), _key12 = 0; _key12 < _len8; _key12++) {
          queries[_key12] = arguments[_key12];
        }
        var className = _getClassNameFromQueries(queries);
        var query = new ParseQuery3(className);
        query._orQuery(queries);
        return query;
      }
    }, {
      key: "and",
      value: function() {
        for (var _len9 = arguments.length, queries = new Array(_len9), _key13 = 0; _key13 < _len9; _key13++) {
          queries[_key13] = arguments[_key13];
        }
        var className = _getClassNameFromQueries(queries);
        var query = new ParseQuery3(className);
        query._andQuery(queries);
        return query;
      }
    }, {
      key: "nor",
      value: function() {
        for (var _len10 = arguments.length, queries = new Array(_len10), _key14 = 0; _key14 < _len10; _key14++) {
          queries[_key14] = arguments[_key14];
        }
        var className = _getClassNameFromQueries(queries);
        var query = new ParseQuery3(className);
        query._norQuery(queries);
        return query;
      }
    }]);
    return ParseQuery3;
  }();
  var DefaultController = {
    find: function(className, params, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "classes/" + className, params, options);
    },
    aggregate: function(className, params, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "aggregate/" + className, params, options);
    }
  };
  _CoreManager2.default.setQueryController(DefaultController);
  var _default = ParseQuery2;
  exports.default = _default;
})(ParseQuery);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _ParseOp = ParseOp$1;
  _interopRequireDefault2(ParseObject);
  var _ParseQuery2 = _interopRequireDefault2(ParseQuery);
  var ParseRelation2 = /* @__PURE__ */ function() {
    function ParseRelation3(parent2, key) {
      (0, _classCallCheck22.default)(this, ParseRelation3);
      (0, _defineProperty22.default)(this, "parent", void 0);
      (0, _defineProperty22.default)(this, "key", void 0);
      (0, _defineProperty22.default)(this, "targetClassName", void 0);
      this.parent = parent2;
      this.key = key;
      this.targetClassName = null;
    }
    (0, _createClass22.default)(ParseRelation3, [{
      key: "_ensureParentAndKey",
      value: function(parent2, key) {
        this.key = this.key || key;
        if (this.key !== key) {
          throw new Error("Internal Error. Relation retrieved from two different keys.");
        }
        if (this.parent) {
          if (this.parent.className !== parent2.className) {
            throw new Error("Internal Error. Relation retrieved from two different Objects.");
          }
          if (this.parent.id) {
            if (this.parent.id !== parent2.id) {
              throw new Error("Internal Error. Relation retrieved from two different Objects.");
            }
          } else if (parent2.id) {
            this.parent = parent2;
          }
        } else {
          this.parent = parent2;
        }
      }
    }, {
      key: "add",
      value: function(objects) {
        if (!(0, _isArray2.default)(objects)) {
          objects = [objects];
        }
        var change = new _ParseOp.RelationOp(objects, []);
        var parent2 = this.parent;
        if (!parent2) {
          throw new Error("Cannot add to a Relation without a parent");
        }
        if (objects.length === 0) {
          return parent2;
        }
        parent2.set(this.key, change);
        this.targetClassName = change._targetClassName;
        return parent2;
      }
    }, {
      key: "remove",
      value: function(objects) {
        if (!(0, _isArray2.default)(objects)) {
          objects = [objects];
        }
        var change = new _ParseOp.RelationOp([], objects);
        if (!this.parent) {
          throw new Error("Cannot remove from a Relation without a parent");
        }
        if (objects.length === 0) {
          return;
        }
        this.parent.set(this.key, change);
        this.targetClassName = change._targetClassName;
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          __type: "Relation",
          className: this.targetClassName
        };
      }
    }, {
      key: "query",
      value: function query() {
        var query2;
        var parent2 = this.parent;
        if (!parent2) {
          throw new Error("Cannot construct a query for a Relation without a parent");
        }
        if (!this.targetClassName) {
          query2 = new _ParseQuery2.default(parent2.className);
          query2._extraOptions.redirectClassNameForKey = this.key;
        } else {
          query2 = new _ParseQuery2.default(this.targetClassName);
        }
        query2._addCondition("$relatedTo", "object", {
          __type: "Pointer",
          className: parent2.className,
          objectId: parent2.id
        });
        query2._addCondition("$relatedTo", "key", this.key);
        return query2;
      }
    }]);
    return ParseRelation3;
  }();
  var _default = ParseRelation2;
  exports.default = _default;
})(ParseRelation);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = canBeSerialized2;
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  function canBeSerialized2(obj) {
    if (!(obj instanceof _ParseObject2.default)) {
      return true;
    }
    var attributes = obj.attributes;
    for (var attr in attributes) {
      var val = attributes[attr];
      if (!canBeSerializedHelper(val)) {
        return false;
      }
    }
    return true;
  }
  function canBeSerializedHelper(value) {
    if ((0, _typeof22.default)(value) !== "object") {
      return true;
    }
    if (value instanceof _ParseRelation.default) {
      return true;
    }
    if (value instanceof _ParseObject2.default) {
      return !!value.id;
    }
    if (value instanceof _ParseFile.default) {
      if (value.url()) {
        return true;
      }
      return false;
    }
    if ((0, _isArray2.default)(value)) {
      for (var i2 = 0; i2 < value.length; i2++) {
        if (!canBeSerializedHelper(value[i2])) {
          return false;
        }
      }
      return true;
    }
    for (var k in value) {
      if (!canBeSerializedHelper(value[k])) {
        return false;
      }
    }
    return true;
  }
})(canBeSerialized);
var _escape = {};
(function(exports) {
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = escape2;
  var encoded = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "/": "&#x2F;",
    "'": "&#x27;",
    '"': "&quot;"
  };
  function escape2(str) {
    return str.replace(/[&<>\/'"]/g, function(char) {
      return encoded[char];
    });
  }
})(_escape);
var $$5 = _export;
var global$3 = global$V;
var apply = functionApply;
var isCallable = isCallable$l;
var userAgent = engineUserAgent;
var arraySlice = arraySlice$6;
var validateArgumentsLength = validateArgumentsLength$2;
var MSIE = /MSIE .\./.test(userAgent);
var Function$1 = global$3.Function;
var wrap = function(scheduler) {
  return function(handler, timeout) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
    var fn = isCallable(handler) ? handler : Function$1(handler);
    var args = boundArgs ? arraySlice(arguments, 2) : void 0;
    return scheduler(boundArgs ? function() {
      apply(fn, this, args);
    } : fn, timeout);
  };
};
$$5({ global: true, bind: true, forced: MSIE }, {
  setTimeout: wrap(global$3.setTimeout),
  setInterval: wrap(global$3.setInterval)
});
var path$4 = path$u;
var setInterval$2 = path$4.setInterval;
var setInterval$1 = setInterval$2;
var $$4 = _export;
var $findIndex = arrayIteration.findIndex;
var FIND_INDEX = "findIndex";
var SKIPS_HOLES = true;
if (FIND_INDEX in [])
  Array(1)[FIND_INDEX](function() {
    SKIPS_HOLES = false;
  });
$$4({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$4 = entryVirtual$j;
var findIndex$3 = entryVirtual$4("Array").findIndex;
var isPrototypeOf$4 = objectIsPrototypeOf;
var method$4 = findIndex$3;
var ArrayPrototype$4 = Array.prototype;
var findIndex$2 = function(it) {
  var own = it.findIndex;
  return it === ArrayPrototype$4 || isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.findIndex ? method$4 : own;
};
var parent$7 = findIndex$2;
var findIndex$1 = parent$7;
var findIndex2 = findIndex$1;
var StorageController = {
  async: 0,
  getItem: function(path2) {
    return localStorage.getItem(path2);
  },
  setItem: function(path2, value) {
    try {
      localStorage.setItem(path2, value);
    } catch (e2) {
      console.log(e2.message);
    }
  },
  removeItem: function(path2) {
    localStorage.removeItem(path2);
  },
  getAllKeys: function() {
    var keys4 = [];
    for (var i2 = 0; i2 < localStorage.length; i2 += 1) {
      keys4.push(localStorage.key(i2));
    }
    return keys4;
  },
  clear: function() {
    localStorage.clear();
  }
};
var StorageController_browser = StorageController;
var _interopRequireDefault$8 = interopRequireDefault.exports;
var _promise$5 = _interopRequireDefault$8(promise$3);
var _CoreManager$4 = _interopRequireDefault$8(CoreManager);
var Storage = {
  async: function() {
    var controller = _CoreManager$4.default.getStorageController();
    return !!controller.async;
  },
  getItem: function(path2) {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      throw new Error("Synchronous storage is not supported by the current storage controller");
    }
    return controller.getItem(path2);
  },
  getItemAsync: function(path2) {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      return controller.getItemAsync(path2);
    }
    return _promise$5.default.resolve(controller.getItem(path2));
  },
  setItem: function(path2, value) {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      throw new Error("Synchronous storage is not supported by the current storage controller");
    }
    return controller.setItem(path2, value);
  },
  setItemAsync: function(path2, value) {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      return controller.setItemAsync(path2, value);
    }
    return _promise$5.default.resolve(controller.setItem(path2, value));
  },
  removeItem: function(path2) {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      throw new Error("Synchronous storage is not supported by the current storage controller");
    }
    return controller.removeItem(path2);
  },
  removeItemAsync: function(path2) {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      return controller.removeItemAsync(path2);
    }
    return _promise$5.default.resolve(controller.removeItem(path2));
  },
  getAllKeys: function() {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      throw new Error("Synchronous storage is not supported by the current storage controller");
    }
    return controller.getAllKeys();
  },
  getAllKeysAsync: function() {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.async === 1) {
      return controller.getAllKeysAsync();
    }
    return _promise$5.default.resolve(controller.getAllKeys());
  },
  generatePath: function(path2) {
    if (!_CoreManager$4.default.get("APPLICATION_ID")) {
      throw new Error("You need to call Parse.initialize before using Parse.");
    }
    if (typeof path2 !== "string") {
      throw new Error("Tried to get a Storage path that was not a String.");
    }
    if (path2[0] === "/") {
      path2 = path2.substr(1);
    }
    return "Parse/" + _CoreManager$4.default.get("APPLICATION_ID") + "/" + path2;
  },
  _clear: function() {
    var controller = _CoreManager$4.default.getStorageController();
    if (controller.hasOwnProperty("clear")) {
      controller.clear();
    }
  }
};
var Storage_1 = Storage;
_CoreManager$4.default.setStorageController(StorageController_browser);
var _interopRequireDefault$7 = interopRequireDefault.exports;
var _find$1 = _interopRequireDefault$7(find3);
var _setInterval2 = _interopRequireDefault$7(setInterval$1);
var _toConsumableArray2$1 = _interopRequireDefault$7(toConsumableArray.exports);
var _findIndex = _interopRequireDefault$7(findIndex2);
var _splice = _interopRequireDefault$7(splice2);
var _stringify$3 = _interopRequireDefault$7(stringify2);
var _regenerator$2 = _interopRequireDefault$7(regenerator);
var _asyncToGenerator2$2 = _interopRequireDefault$7(asyncToGenerator.exports);
var _CoreManager$3 = _interopRequireDefault$7(CoreManager);
var _ParseObject = _interopRequireDefault$7(ParseObject);
var _ParseQuery$1 = _interopRequireDefault$7(ParseQuery);
var _Storage$2 = _interopRequireDefault$7(Storage_1);
var QUEUE_KEY = "Parse/Eventually/Queue";
var queueCache = [];
var dirtyCache = true;
var polling = void 0;
var EventuallyQueue = {
  save: function(object) {
    var serverOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this.enqueue("save", object, serverOptions);
  },
  destroy: function(object) {
    var serverOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this.enqueue("destroy", object, serverOptions);
  },
  generateQueueId: function(action, object) {
    object._getId();
    var className = object.className, id2 = object.id, _localId = object._localId;
    var uniqueId = object.get("hash") || _localId;
    return [action, className, id2, uniqueId].join("_");
  },
  enqueue: function(action, object, serverOptions) {
    var _this = this;
    return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee() {
      var queueData, queueId, index, prop;
      return _regenerator$2.default.wrap(function(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.getQueue();
            case 2:
              queueData = _context.sent;
              queueId = _this.generateQueueId(action, object);
              index = _this.queueItemExists(queueData, queueId);
              if (index > -1) {
                for (prop in queueData[index].object) {
                  if (typeof object.get(prop) === "undefined") {
                    object.set(prop, queueData[index].object[prop]);
                  }
                }
              } else {
                index = queueData.length;
              }
              queueData[index] = {
                queueId,
                action,
                object: object.toJSON(),
                serverOptions,
                id: object.id,
                className: object.className,
                hash: object.get("hash"),
                createdAt: new Date()
              };
              return _context.abrupt("return", _this.setQueue(queueData));
            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  store: function(data2) {
    return _Storage$2.default.setItemAsync(QUEUE_KEY, (0, _stringify$3.default)(data2));
  },
  load: function() {
    return _Storage$2.default.getItemAsync(QUEUE_KEY);
  },
  getQueue: function() {
    var _this2 = this;
    return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee2() {
      return _regenerator$2.default.wrap(function(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!dirtyCache) {
                _context2.next = 10;
                break;
              }
              _context2.t0 = JSON;
              _context2.next = 4;
              return _this2.load();
            case 4:
              _context2.t1 = _context2.sent;
              if (_context2.t1) {
                _context2.next = 7;
                break;
              }
              _context2.t1 = "[]";
            case 7:
              _context2.t2 = _context2.t1;
              queueCache = _context2.t0.parse.call(_context2.t0, _context2.t2);
              dirtyCache = false;
            case 10:
              return _context2.abrupt("return", queueCache);
            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  },
  setQueue: function(queue2) {
    queueCache = queue2;
    return this.store(queueCache);
  },
  remove: function(queueId) {
    var _this3 = this;
    return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee3() {
      var queueData, index;
      return _regenerator$2.default.wrap(function(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _this3.getQueue();
            case 2:
              queueData = _context3.sent;
              index = _this3.queueItemExists(queueData, queueId);
              if (!(index > -1)) {
                _context3.next = 8;
                break;
              }
              (0, _splice.default)(queueData).call(queueData, index, 1);
              _context3.next = 8;
              return _this3.setQueue(queueData);
            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  },
  clear: function() {
    queueCache = [];
    return this.store([]);
  },
  queueItemExists: function(queue2, queueId) {
    return (0, _findIndex.default)(queue2).call(queue2, function(data2) {
      return data2.queueId === queueId;
    });
  },
  length: function() {
    var _this4 = this;
    return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee4() {
      var queueData;
      return _regenerator$2.default.wrap(function(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return _this4.getQueue();
            case 2:
              queueData = _context4.sent;
              return _context4.abrupt("return", queueData.length);
            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }))();
  },
  sendQueue: function() {
    var _this5 = this;
    return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee5() {
      var queue2, queueData, i2, queueObject, id2, hash, className, ObjectType;
      return _regenerator$2.default.wrap(function(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return _this5.getQueue();
            case 2:
              queue2 = _context5.sent;
              queueData = (0, _toConsumableArray2$1.default)(queue2);
              if (!(queueData.length === 0)) {
                _context5.next = 6;
                break;
              }
              return _context5.abrupt("return", false);
            case 6:
              i2 = 0;
            case 7:
              if (!(i2 < queueData.length)) {
                _context5.next = 26;
                break;
              }
              queueObject = queueData[i2];
              id2 = queueObject.id, hash = queueObject.hash, className = queueObject.className;
              ObjectType = _ParseObject.default.extend(className);
              if (!id2) {
                _context5.next = 16;
                break;
              }
              _context5.next = 14;
              return _this5.process.byId(ObjectType, queueObject);
            case 14:
              _context5.next = 23;
              break;
            case 16:
              if (!hash) {
                _context5.next = 21;
                break;
              }
              _context5.next = 19;
              return _this5.process.byHash(ObjectType, queueObject);
            case 19:
              _context5.next = 23;
              break;
            case 21:
              _context5.next = 23;
              return _this5.process.create(ObjectType, queueObject);
            case 23:
              i2 += 1;
              _context5.next = 7;
              break;
            case 26:
              return _context5.abrupt("return", true);
            case 27:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }))();
  },
  sendQueueCallback: function(object, queueObject) {
    var _this6 = this;
    return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee6() {
      return _regenerator$2.default.wrap(function(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (object) {
                _context6.next = 2;
                break;
              }
              return _context6.abrupt("return", _this6.remove(queueObject.queueId));
            case 2:
              _context6.t0 = queueObject.action;
              _context6.next = _context6.t0 === "save" ? 5 : _context6.t0 === "destroy" ? 20 : 33;
              break;
            case 5:
              if (!(typeof object.updatedAt !== "undefined" && object.updatedAt > new Date(queueObject.object.createdAt))) {
                _context6.next = 7;
                break;
              }
              return _context6.abrupt("return", _this6.remove(queueObject.queueId));
            case 7:
              _context6.prev = 7;
              _context6.next = 10;
              return object.save(queueObject.object, queueObject.serverOptions);
            case 10:
              _context6.next = 12;
              return _this6.remove(queueObject.queueId);
            case 12:
              _context6.next = 19;
              break;
            case 14:
              _context6.prev = 14;
              _context6.t1 = _context6["catch"](7);
              if (!(_context6.t1.message !== 'XMLHttpRequest failed: "Unable to connect to the Parse API"')) {
                _context6.next = 19;
                break;
              }
              _context6.next = 19;
              return _this6.remove(queueObject.queueId);
            case 19:
              return _context6.abrupt("break", 33);
            case 20:
              _context6.prev = 20;
              _context6.next = 23;
              return object.destroy(queueObject.serverOptions);
            case 23:
              _context6.next = 25;
              return _this6.remove(queueObject.queueId);
            case 25:
              _context6.next = 32;
              break;
            case 27:
              _context6.prev = 27;
              _context6.t2 = _context6["catch"](20);
              if (!(_context6.t2.message !== 'XMLHttpRequest failed: "Unable to connect to the Parse API"')) {
                _context6.next = 32;
                break;
              }
              _context6.next = 32;
              return _this6.remove(queueObject.queueId);
            case 32:
              return _context6.abrupt("break", 33);
            case 33:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, null, [[7, 14], [20, 27]]);
    }))();
  },
  poll: function() {
    var _this7 = this;
    var ms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2e3;
    if (polling) {
      return;
    }
    polling = (0, _setInterval2.default)(function() {
      var RESTController2 = _CoreManager$3.default.getRESTController();
      RESTController2.request("GET", "health").then(function(_ref) {
        var status = _ref.status;
        if (status === "ok") {
          _this7.stopPoll();
          return _this7.sendQueue();
        }
      }).catch(function(e2) {
        return e2;
      });
    }, ms);
  },
  stopPoll: function() {
    clearInterval(polling);
    polling = void 0;
  },
  isPolling: function() {
    return !!polling;
  },
  _setPolling: function(flag) {
    polling = flag;
  },
  process: {
    create: function(ObjectType, queueObject) {
      var object = new ObjectType();
      return EventuallyQueue.sendQueueCallback(object, queueObject);
    },
    byId: function(ObjectType, queueObject) {
      return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee7() {
        var sessionToken, query, results;
        return _regenerator$2.default.wrap(function(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                sessionToken = queueObject.serverOptions.sessionToken;
                query = new _ParseQuery$1.default(ObjectType);
                query.equalTo("objectId", queueObject.id);
                _context7.next = 5;
                return (0, _find$1.default)(query).call(query, {
                  sessionToken
                });
              case 5:
                results = _context7.sent;
                return _context7.abrupt("return", EventuallyQueue.sendQueueCallback(results[0], queueObject));
              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }))();
    },
    byHash: function(ObjectType, queueObject) {
      return (0, _asyncToGenerator2$2.default)(/* @__PURE__ */ _regenerator$2.default.mark(function _callee8() {
        var sessionToken, query, results;
        return _regenerator$2.default.wrap(function(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                sessionToken = queueObject.serverOptions.sessionToken;
                query = new _ParseQuery$1.default(ObjectType);
                query.equalTo("hash", queueObject.hash);
                _context8.next = 5;
                return (0, _find$1.default)(query).call(query, {
                  sessionToken
                });
              case 5:
                results = _context8.sent;
                if (!(results.length > 0)) {
                  _context8.next = 8;
                  break;
                }
                return _context8.abrupt("return", EventuallyQueue.sendQueueCallback(results[0], queueObject));
              case 8:
                return _context8.abrupt("return", EventuallyQueue.process.create(ObjectType, queueObject));
              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    }
  }
};
var EventuallyQueue_1 = EventuallyQueue;
var parseDate = {};
var whitespaces$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
var uncurryThis$2 = functionUncurryThis;
var requireObjectCoercible = requireObjectCoercible$6;
var toString$2 = toString$a;
var whitespaces$1 = whitespaces$2;
var replace = uncurryThis$2("".replace);
var whitespace = "[" + whitespaces$1 + "]";
var ltrim = RegExp("^" + whitespace + whitespace + "*");
var rtrim = RegExp(whitespace + whitespace + "*$");
var createMethod$1 = function(TYPE) {
  return function($this) {
    var string = toString$2(requireObjectCoercible($this));
    if (TYPE & 1)
      string = replace(string, ltrim, "");
    if (TYPE & 2)
      string = replace(string, rtrim, "");
    return string;
  };
};
var stringTrim = {
  start: createMethod$1(1),
  end: createMethod$1(2),
  trim: createMethod$1(3)
};
var global$2 = global$V;
var fails$1 = fails$u;
var uncurryThis$1 = functionUncurryThis;
var toString$1 = toString$a;
var trim = stringTrim.trim;
var whitespaces = whitespaces$2;
var $parseInt$1 = global$2.parseInt;
var Symbol$1 = global$2.Symbol;
var ITERATOR = Symbol$1 && Symbol$1.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis$1(hex.exec);
var FORCED = $parseInt$1(whitespaces + "08") !== 8 || $parseInt$1(whitespaces + "0x16") !== 22 || ITERATOR && !fails$1(function() {
  $parseInt$1(Object(ITERATOR));
});
var numberParseInt = FORCED ? function parseInt2(string, radix) {
  var S = trim(toString$1(string));
  return $parseInt$1(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
} : $parseInt$1;
var $$3 = _export;
var $parseInt = numberParseInt;
$$3({ global: true, forced: parseInt != $parseInt }, {
  parseInt: $parseInt
});
var path$3 = path$u;
var _parseInt$2 = path$3.parseInt;
var parent$6 = _parseInt$2;
var _parseInt$1 = parent$6;
var _parseInt = _parseInt$1;
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = parseDate2;
  var _parseInt2 = _interopRequireDefault2(_parseInt);
  function parseDate2(iso8601) {
    var regexp = new RegExp("^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$");
    var match2 = regexp.exec(iso8601);
    if (!match2) {
      return null;
    }
    var year = (0, _parseInt2.default)(match2[1]) || 0;
    var month = ((0, _parseInt2.default)(match2[2]) || 1) - 1;
    var day = (0, _parseInt2.default)(match2[3]) || 0;
    var hour = (0, _parseInt2.default)(match2[4]) || 0;
    var minute = (0, _parseInt2.default)(match2[5]) || 0;
    var second = (0, _parseInt2.default)(match2[6]) || 0;
    var milli = (0, _parseInt2.default)(match2[8]) || 0;
    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));
  }
})(parseDate);
var SingleInstanceStateController = {};
var ObjectStateMutations = {};
var _interopRequireDefault$6 = interopRequireDefault.exports;
var _classCallCheck2 = _interopRequireDefault$6(classCallCheck.exports);
var _createClass2 = _interopRequireDefault$6(createClass.exports);
var _defineProperty2$1 = _interopRequireDefault$6(defineProperty$2.exports);
var _promiseUtils$1 = promiseUtils;
var TaskQueue = /* @__PURE__ */ function() {
  function TaskQueue2() {
    (0, _classCallCheck2.default)(this, TaskQueue2);
    (0, _defineProperty2$1.default)(this, "queue", void 0);
    this.queue = [];
  }
  (0, _createClass2.default)(TaskQueue2, [{
    key: "enqueue",
    value: function(task2) {
      var _this = this;
      var taskComplete = new _promiseUtils$1.resolvingPromise();
      this.queue.push({
        task: task2,
        _completion: taskComplete
      });
      if (this.queue.length === 1) {
        task2().then(function() {
          _this._dequeue();
          taskComplete.resolve();
        }, function(error) {
          _this._dequeue();
          taskComplete.reject(error);
        });
      }
      return taskComplete;
    }
  }, {
    key: "_dequeue",
    value: function() {
      var _this2 = this;
      this.queue.shift();
      if (this.queue.length) {
        var next2 = this.queue[0];
        next2.task().then(function() {
          _this2._dequeue();
          next2._completion.resolve();
        }, function(error) {
          _this2._dequeue();
          next2._completion.reject(error);
        });
      }
    }
  }]);
  return TaskQueue2;
}();
var TaskQueue_1 = TaskQueue;
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Object$defineProperties2 = defineProperties4;
  var _Object$getOwnPropertyDescriptors2 = getOwnPropertyDescriptors2;
  var _forEachInstanceProperty2 = forEach2;
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$4;
  var _filterInstanceProperty2 = filter3;
  var _Object$getOwnPropertySymbols2 = getOwnPropertySymbols3;
  var _Object$keys2 = keys$5;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.commitServerChanges = commitServerChanges;
  exports.defaultState = defaultState;
  exports.estimateAttribute = estimateAttribute;
  exports.estimateAttributes = estimateAttributes;
  exports.mergeFirstPendingState = mergeFirstPendingState;
  exports.popPendingState = popPendingState;
  exports.pushPendingState = pushPendingState;
  exports.setPendingOp = setPendingOp;
  exports.setServerData = setServerData;
  var _stringify2 = _interopRequireDefault2(stringify2);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _includes2 = _interopRequireDefault2(includes4);
  var _encode2 = _interopRequireDefault2(encode);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  var _TaskQueue = _interopRequireDefault2(TaskQueue_1);
  var _ParseOp = ParseOp$1;
  function ownKeys3(object, enumerableOnly) {
    var keys4 = _Object$keys2(object);
    if (_Object$getOwnPropertySymbols2) {
      var symbols = _Object$getOwnPropertySymbols2(object);
      if (enumerableOnly) {
        symbols = _filterInstanceProperty2(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor2(object, sym).enumerable;
        });
      }
      keys4.push.apply(keys4, symbols);
    }
    return keys4;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        var _context;
        _forEachInstanceProperty2(_context = ownKeys3(Object(source), true)).call(_context, function(key) {
          (0, _defineProperty22.default)(target, key, source[key]);
        });
      } else if (_Object$getOwnPropertyDescriptors2) {
        _Object$defineProperties2(target, _Object$getOwnPropertyDescriptors2(source));
      } else {
        var _context2;
        _forEachInstanceProperty2(_context2 = ownKeys3(Object(source))).call(_context2, function(key) {
          _Object$defineProperty2(target, key, _Object$getOwnPropertyDescriptor2(source, key));
        });
      }
    }
    return target;
  }
  function defaultState() {
    return {
      serverData: {},
      pendingOps: [{}],
      objectCache: {},
      tasks: new _TaskQueue.default(),
      existed: false
    };
  }
  function setServerData(serverData, attributes) {
    for (var _attr in attributes) {
      if (typeof attributes[_attr] !== "undefined") {
        serverData[_attr] = attributes[_attr];
      } else {
        delete serverData[_attr];
      }
    }
  }
  function setPendingOp(pendingOps, attr, op) {
    var last2 = pendingOps.length - 1;
    if (op) {
      pendingOps[last2][attr] = op;
    } else {
      delete pendingOps[last2][attr];
    }
  }
  function pushPendingState(pendingOps) {
    pendingOps.push({});
  }
  function popPendingState(pendingOps) {
    var first = pendingOps.shift();
    if (!pendingOps.length) {
      pendingOps[0] = {};
    }
    return first;
  }
  function mergeFirstPendingState(pendingOps) {
    var first = popPendingState(pendingOps);
    var next2 = pendingOps[0];
    for (var _attr2 in first) {
      if (next2[_attr2] && first[_attr2]) {
        var merged = next2[_attr2].mergeWith(first[_attr2]);
        if (merged) {
          next2[_attr2] = merged;
        }
      } else {
        next2[_attr2] = first[_attr2];
      }
    }
  }
  function estimateAttribute(serverData, pendingOps, className, id2, attr) {
    var value = serverData[attr];
    for (var i2 = 0; i2 < pendingOps.length; i2++) {
      if (pendingOps[i2][attr]) {
        if (pendingOps[i2][attr] instanceof _ParseOp.RelationOp) {
          if (id2) {
            value = pendingOps[i2][attr].applyTo(value, {
              className,
              id: id2
            }, attr);
          }
        } else {
          value = pendingOps[i2][attr].applyTo(value);
        }
      }
    }
    return value;
  }
  function estimateAttributes(serverData, pendingOps, className, id2) {
    var data2 = {};
    for (var attr in serverData) {
      data2[attr] = serverData[attr];
    }
    for (var i2 = 0; i2 < pendingOps.length; i2++) {
      for (attr in pendingOps[i2]) {
        if (pendingOps[i2][attr] instanceof _ParseOp.RelationOp) {
          if (id2) {
            data2[attr] = pendingOps[i2][attr].applyTo(data2[attr], {
              className,
              id: id2
            }, attr);
          }
        } else {
          if ((0, _includes2.default)(attr).call(attr, ".")) {
            var fields = attr.split(".");
            var first = fields[0];
            var last2 = fields[fields.length - 1];
            data2[first] = _objectSpread2({}, serverData[first]);
            var object = _objectSpread2({}, data2);
            for (var _i = 0; _i < fields.length - 1; _i++) {
              var key = fields[_i];
              if (!(key in object)) {
                object[key] = {};
              }
              object = object[key];
            }
            object[last2] = pendingOps[i2][attr].applyTo(object[last2]);
          } else {
            data2[attr] = pendingOps[i2][attr].applyTo(data2[attr]);
          }
        }
      }
    }
    return data2;
  }
  function nestedSet(obj, key, value) {
    var path2 = key.split(".");
    for (var i2 = 0; i2 < path2.length - 1; i2++) {
      if (!(path2[i2] in obj))
        obj[path2[i2]] = {};
      obj = obj[path2[i2]];
    }
    if (typeof value === "undefined") {
      delete obj[path2[path2.length - 1]];
    } else {
      obj[path2[path2.length - 1]] = value;
    }
  }
  function commitServerChanges(serverData, objectCache, changes) {
    for (var _attr3 in changes) {
      var val = changes[_attr3];
      nestedSet(serverData, _attr3, val);
      if (val && (0, _typeof22.default)(val) === "object" && !(val instanceof _ParseObject2.default) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {
        var json = (0, _encode2.default)(val, false, true);
        objectCache[_attr3] = (0, _stringify2.default)(json);
      }
    }
  }
})(ObjectStateMutations);
(function(exports) {
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$4;
  var _Object$defineProperty2 = defineProperty$a;
  var _typeof3 = _typeof$1.exports;
  var _WeakMap2 = weakMap;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.clearAllState = clearAllState;
  exports.commitServerChanges = commitServerChanges;
  exports.duplicateState = duplicateState;
  exports.enqueueTask = enqueueTask;
  exports.estimateAttribute = estimateAttribute;
  exports.estimateAttributes = estimateAttributes;
  exports.getObjectCache = getObjectCache;
  exports.getPendingOps = getPendingOps;
  exports.getServerData = getServerData;
  exports.getState = getState;
  exports.initializeState = initializeState;
  exports.mergeFirstPendingState = mergeFirstPendingState;
  exports.popPendingState = popPendingState;
  exports.pushPendingState = pushPendingState;
  exports.removeState = removeState;
  exports.setPendingOp = setPendingOp;
  exports.setServerData = setServerData;
  var ObjectStateMutations$1 = _interopRequireWildcard2(ObjectStateMutations);
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof _WeakMap2 !== "function")
      return null;
    var cacheBabelInterop = new _WeakMap2();
    var cacheNodeInterop = new _WeakMap2();
    return (_getRequireWildcardCache2 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache2(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = _Object$defineProperty2 && _Object$getOwnPropertyDescriptor2 ? _Object$getOwnPropertyDescriptor2(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          _Object$defineProperty2(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var objectState = {};
  function getState(obj) {
    var classData = objectState[obj.className];
    if (classData) {
      return classData[obj.id] || null;
    }
    return null;
  }
  function initializeState(obj, initial) {
    var state = getState(obj);
    if (state) {
      return state;
    }
    if (!objectState[obj.className]) {
      objectState[obj.className] = {};
    }
    if (!initial) {
      initial = ObjectStateMutations$1.defaultState();
    }
    state = objectState[obj.className][obj.id] = initial;
    return state;
  }
  function removeState(obj) {
    var state = getState(obj);
    if (state === null) {
      return null;
    }
    delete objectState[obj.className][obj.id];
    return state;
  }
  function getServerData(obj) {
    var state = getState(obj);
    if (state) {
      return state.serverData;
    }
    return {};
  }
  function setServerData(obj, attributes) {
    var serverData = initializeState(obj).serverData;
    ObjectStateMutations$1.setServerData(serverData, attributes);
  }
  function getPendingOps(obj) {
    var state = getState(obj);
    if (state) {
      return state.pendingOps;
    }
    return [{}];
  }
  function setPendingOp(obj, attr, op) {
    var pendingOps = initializeState(obj).pendingOps;
    ObjectStateMutations$1.setPendingOp(pendingOps, attr, op);
  }
  function pushPendingState(obj) {
    var pendingOps = initializeState(obj).pendingOps;
    ObjectStateMutations$1.pushPendingState(pendingOps);
  }
  function popPendingState(obj) {
    var pendingOps = initializeState(obj).pendingOps;
    return ObjectStateMutations$1.popPendingState(pendingOps);
  }
  function mergeFirstPendingState(obj) {
    var pendingOps = getPendingOps(obj);
    ObjectStateMutations$1.mergeFirstPendingState(pendingOps);
  }
  function getObjectCache(obj) {
    var state = getState(obj);
    if (state) {
      return state.objectCache;
    }
    return {};
  }
  function estimateAttribute(obj, attr) {
    var serverData = getServerData(obj);
    var pendingOps = getPendingOps(obj);
    return ObjectStateMutations$1.estimateAttribute(serverData, pendingOps, obj.className, obj.id, attr);
  }
  function estimateAttributes(obj) {
    var serverData = getServerData(obj);
    var pendingOps = getPendingOps(obj);
    return ObjectStateMutations$1.estimateAttributes(serverData, pendingOps, obj.className, obj.id);
  }
  function commitServerChanges(obj, changes) {
    var state = initializeState(obj);
    ObjectStateMutations$1.commitServerChanges(state.serverData, state.objectCache, changes);
  }
  function enqueueTask(obj, task2) {
    var state = initializeState(obj);
    return state.tasks.enqueue(task2);
  }
  function clearAllState() {
    objectState = {};
  }
  function duplicateState(source, dest) {
    dest.id = source.id;
  }
})(SingleInstanceStateController);
var UniqueInstanceStateController = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$4;
  var _Object$defineProperty2 = defineProperty$a;
  var _typeof3 = _typeof$1.exports;
  var _WeakMap2 = weakMap;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.clearAllState = clearAllState;
  exports.commitServerChanges = commitServerChanges;
  exports.duplicateState = duplicateState;
  exports.enqueueTask = enqueueTask;
  exports.estimateAttribute = estimateAttribute;
  exports.estimateAttributes = estimateAttributes;
  exports.getObjectCache = getObjectCache;
  exports.getPendingOps = getPendingOps;
  exports.getServerData = getServerData;
  exports.getState = getState;
  exports.initializeState = initializeState;
  exports.mergeFirstPendingState = mergeFirstPendingState;
  exports.popPendingState = popPendingState;
  exports.pushPendingState = pushPendingState;
  exports.removeState = removeState;
  exports.setPendingOp = setPendingOp;
  exports.setServerData = setServerData;
  var _weakMap = _interopRequireDefault2(weakMap);
  var ObjectStateMutations$1 = _interopRequireWildcard2(ObjectStateMutations);
  var _TaskQueue = _interopRequireDefault2(TaskQueue_1);
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof _WeakMap2 !== "function")
      return null;
    var cacheBabelInterop = new _WeakMap2();
    var cacheNodeInterop = new _WeakMap2();
    return (_getRequireWildcardCache2 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache2(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = _Object$defineProperty2 && _Object$getOwnPropertyDescriptor2 ? _Object$getOwnPropertyDescriptor2(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          _Object$defineProperty2(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  var objectState = new _weakMap.default();
  function getState(obj) {
    var classData = objectState.get(obj);
    return classData || null;
  }
  function initializeState(obj, initial) {
    var state = getState(obj);
    if (state) {
      return state;
    }
    if (!initial) {
      initial = {
        serverData: {},
        pendingOps: [{}],
        objectCache: {},
        tasks: new _TaskQueue.default(),
        existed: false
      };
    }
    state = initial;
    objectState.set(obj, state);
    return state;
  }
  function removeState(obj) {
    var state = getState(obj);
    if (state === null) {
      return null;
    }
    objectState.delete(obj);
    return state;
  }
  function getServerData(obj) {
    var state = getState(obj);
    if (state) {
      return state.serverData;
    }
    return {};
  }
  function setServerData(obj, attributes) {
    var serverData = initializeState(obj).serverData;
    ObjectStateMutations$1.setServerData(serverData, attributes);
  }
  function getPendingOps(obj) {
    var state = getState(obj);
    if (state) {
      return state.pendingOps;
    }
    return [{}];
  }
  function setPendingOp(obj, attr, op) {
    var pendingOps = initializeState(obj).pendingOps;
    ObjectStateMutations$1.setPendingOp(pendingOps, attr, op);
  }
  function pushPendingState(obj) {
    var pendingOps = initializeState(obj).pendingOps;
    ObjectStateMutations$1.pushPendingState(pendingOps);
  }
  function popPendingState(obj) {
    var pendingOps = initializeState(obj).pendingOps;
    return ObjectStateMutations$1.popPendingState(pendingOps);
  }
  function mergeFirstPendingState(obj) {
    var pendingOps = getPendingOps(obj);
    ObjectStateMutations$1.mergeFirstPendingState(pendingOps);
  }
  function getObjectCache(obj) {
    var state = getState(obj);
    if (state) {
      return state.objectCache;
    }
    return {};
  }
  function estimateAttribute(obj, attr) {
    var serverData = getServerData(obj);
    var pendingOps = getPendingOps(obj);
    return ObjectStateMutations$1.estimateAttribute(serverData, pendingOps, obj.className, obj.id, attr);
  }
  function estimateAttributes(obj) {
    var serverData = getServerData(obj);
    var pendingOps = getPendingOps(obj);
    return ObjectStateMutations$1.estimateAttributes(serverData, pendingOps, obj.className, obj.id);
  }
  function commitServerChanges(obj, changes) {
    var state = initializeState(obj);
    ObjectStateMutations$1.commitServerChanges(state.serverData, state.objectCache, changes);
  }
  function enqueueTask(obj, task2) {
    var state = initializeState(obj);
    return state.tasks.enqueue(task2);
  }
  function duplicateState(source, dest) {
    var oldState = initializeState(source);
    var newState = initializeState(dest);
    for (var key in oldState.serverData) {
      newState.serverData[key] = oldState.serverData[key];
    }
    for (var index = 0; index < oldState.pendingOps.length; index++) {
      for (var _key in oldState.pendingOps[index]) {
        newState.pendingOps[index][_key] = oldState.pendingOps[index][_key];
      }
    }
    for (var _key2 in oldState.objectCache) {
      newState.objectCache[_key2] = oldState.objectCache[_key2];
    }
    newState.existed = oldState.existed;
  }
  function clearAllState() {
    objectState = new _weakMap.default();
  }
})(UniqueInstanceStateController);
var unsavedChildren = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = unsavedChildren2;
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _concat2 = _interopRequireDefault2(concat$1);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  function unsavedChildren2(obj, allowDeepUnsaved) {
    var encountered = {
      objects: {},
      files: []
    };
    var identifier = obj.className + ":" + obj._getId();
    encountered.objects[identifier] = obj.dirty() ? obj : true;
    var attributes = obj.attributes;
    for (var attr in attributes) {
      if ((0, _typeof22.default)(attributes[attr]) === "object") {
        traverse2(attributes[attr], encountered, false, !!allowDeepUnsaved);
      }
    }
    var unsaved = [];
    for (var id2 in encountered.objects) {
      if (id2 !== identifier && encountered.objects[id2] !== true) {
        unsaved.push(encountered.objects[id2]);
      }
    }
    return (0, _concat2.default)(unsaved).call(unsaved, encountered.files);
  }
  function traverse2(obj, encountered, shouldThrow, allowDeepUnsaved) {
    if (obj instanceof _ParseObject2.default) {
      if (!obj.id && shouldThrow) {
        throw new Error("Cannot create a pointer to an unsaved Object.");
      }
      var _identifier = obj.className + ":" + obj._getId();
      if (!encountered.objects[_identifier]) {
        encountered.objects[_identifier] = obj.dirty() ? obj : true;
        var attributes = obj.attributes;
        for (var attr in attributes) {
          if ((0, _typeof22.default)(attributes[attr]) === "object") {
            traverse2(attributes[attr], encountered, !allowDeepUnsaved, allowDeepUnsaved);
          }
        }
      }
      return;
    }
    if (obj instanceof _ParseFile.default) {
      var _context;
      if (!obj.url() && (0, _indexOf2.default)(_context = encountered.files).call(_context, obj) < 0) {
        encountered.files.push(obj);
      }
      return;
    }
    if (obj instanceof _ParseRelation.default) {
      return;
    }
    if ((0, _isArray2.default)(obj)) {
      (0, _forEach2.default)(obj).call(obj, function(el) {
        if ((0, _typeof22.default)(el) === "object") {
          traverse2(el, encountered, shouldThrow, allowDeepUnsaved);
        }
      });
    }
    for (var k in obj) {
      if ((0, _typeof22.default)(obj[k]) === "object") {
        traverse2(obj[k], encountered, shouldThrow, allowDeepUnsaved);
      }
    }
  }
})(unsavedChildren);
var rngBrowser = { exports: {} };
var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  var rnds = new Array(16);
  rngBrowser.exports = function mathRNG() {
    for (var i2 = 0, r2; i2 < 16; i2++) {
      if ((i2 & 3) === 0)
        r2 = Math.random() * 4294967296;
      rnds[i2] = r2 >>> ((i2 & 3) << 3) & 255;
    }
    return rnds;
  };
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex[i$1] = (i$1 + 256).toString(16).substr(1);
}
function bytesToUuid$1(buf, offset) {
  var i2 = offset || 0;
  var bth = byteToHex;
  return [
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]]
  ].join("");
}
var bytesToUuid_1 = bytesToUuid$1;
var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;
function v4(options, buf, offset) {
  var i2 = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i2 + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid(rnds);
}
var v4_1 = v4;
var uuid = null;
uuid = v4_1;
var uuid_1 = uuid;
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _typeof3 = _typeof$1.exports;
  var _WeakMap2 = weakMap;
  var _Array$isArray22 = isArray$4;
  var _getIteratorMethod2 = getIteratorMethod$1;
  var _Symbol2 = symbol;
  var _Array$from3 = from$3;
  var _sliceInstanceProperty3 = slice$3;
  var _Object$defineProperty2 = defineProperty$a;
  var _Object$defineProperties2 = defineProperties4;
  var _Object$getOwnPropertyDescriptors2 = getOwnPropertyDescriptors2;
  var _forEachInstanceProperty2 = forEach2;
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$4;
  var _filterInstanceProperty2 = filter3;
  var _Object$getOwnPropertySymbols2 = getOwnPropertySymbols3;
  var _Object$keys2 = keys$5;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _map2 = _interopRequireDefault2(map$1);
  var _find2 = _interopRequireDefault2(find3);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$a);
  var _create = _interopRequireDefault2(create4);
  var _promise2 = _interopRequireDefault2(promise$3);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _regenerator2 = _interopRequireDefault2(regenerator);
  var _asyncToGenerator22 = _interopRequireDefault2(asyncToGenerator.exports);
  var _concat2 = _interopRequireDefault2(concat$1);
  var _getPrototypeOf = _interopRequireDefault2(getPrototypeOf2);
  var _includes2 = _interopRequireDefault2(includes4);
  var _stringify2 = _interopRequireDefault2(stringify2);
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _keys4 = _interopRequireDefault2(keys$5);
  var _freeze = _interopRequireDefault2(freeze2);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty3 = _interopRequireDefault2(defineProperty$2.exports);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _canBeSerialized = _interopRequireDefault2(canBeSerialized);
  var _decode2 = _interopRequireDefault2(decode$2);
  var _encode2 = _interopRequireDefault2(encode);
  var _escape2 = _interopRequireDefault2(_escape);
  var _EventuallyQueue2 = _interopRequireDefault2(EventuallyQueue_1);
  var _ParseACL = _interopRequireDefault2(ParseACL);
  var _parseDate = _interopRequireDefault2(parseDate);
  var _ParseError2 = _interopRequireDefault2(ParseError$1);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _promiseUtils2 = promiseUtils;
  var _LocalDatastoreUtils2 = LocalDatastoreUtils;
  var _ParseOp = ParseOp$1;
  var _ParseQuery2 = _interopRequireDefault2(ParseQuery);
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  var SingleInstanceStateController$1 = _interopRequireWildcard2(SingleInstanceStateController);
  var _unique = _interopRequireDefault2(unique);
  var UniqueInstanceStateController$1 = _interopRequireWildcard2(UniqueInstanceStateController);
  var _unsavedChildren = _interopRequireDefault2(unsavedChildren);
  function _getRequireWildcardCache2(nodeInterop) {
    if (typeof _WeakMap2 !== "function")
      return null;
    var cacheBabelInterop = new _WeakMap2();
    var cacheNodeInterop = new _WeakMap2();
    return (_getRequireWildcardCache2 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }
    var cache = _getRequireWildcardCache2(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = _Object$defineProperty2 && _Object$getOwnPropertyDescriptor2 ? _Object$getOwnPropertyDescriptor2(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          _Object$defineProperty2(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
  function _createForOfIteratorHelper2(o2, allowArrayLike) {
    var it = typeof _Symbol2 !== "undefined" && _getIteratorMethod2(o2) || o2["@@iterator"];
    if (!it) {
      if (_Array$isArray22(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
        if (it)
          o2 = it;
        var i2 = 0;
        var F = function() {
        };
        return {
          s: F,
          n: function() {
            if (i2 >= o2.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o2[i2++]
            };
          },
          e: function(_e) {
            throw _e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
      s: function() {
        it = it.call(o2);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      }
    };
  }
  function _unsupportedIterableToArray2(o2, minLen) {
    var _context18;
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray2(o2, minLen);
    var n2 = _sliceInstanceProperty3(_context18 = Object.prototype.toString.call(o2)).call(_context18, 8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return _Array$from3(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o2, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function ownKeys3(object, enumerableOnly) {
    var keys4 = _Object$keys2(object);
    if (_Object$getOwnPropertySymbols2) {
      var symbols = _Object$getOwnPropertySymbols2(object);
      if (enumerableOnly) {
        symbols = _filterInstanceProperty2(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor2(object, sym).enumerable;
        });
      }
      keys4.push.apply(keys4, symbols);
    }
    return keys4;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        var _context16;
        _forEachInstanceProperty2(_context16 = ownKeys3(Object(source), true)).call(_context16, function(key) {
          (0, _defineProperty3.default)(target, key, source[key]);
        });
      } else if (_Object$getOwnPropertyDescriptors2) {
        _Object$defineProperties2(target, _Object$getOwnPropertyDescriptors2(source));
      } else {
        var _context17;
        _forEachInstanceProperty2(_context17 = ownKeys3(Object(source))).call(_context17, function(key) {
          _Object$defineProperty2(target, key, _Object$getOwnPropertyDescriptor2(source, key));
        });
      }
    }
    return target;
  }
  var uuidv42 = uuid_1;
  var classMap = {};
  var objectCount = 0;
  var singleInstance = !_CoreManager2.default.get("IS_NODE");
  if (singleInstance) {
    _CoreManager2.default.setObjectStateController(SingleInstanceStateController$1);
  } else {
    _CoreManager2.default.setObjectStateController(UniqueInstanceStateController$1);
  }
  function getServerUrlPath() {
    var serverUrl = _CoreManager2.default.get("SERVER_URL");
    if (serverUrl[serverUrl.length - 1] !== "/") {
      serverUrl += "/";
    }
    var url = serverUrl.replace(/https?:\/\//, "");
    return url.substr((0, _indexOf2.default)(url).call(url, "/"));
  }
  var ParseObject2 = /* @__PURE__ */ function() {
    function ParseObject3(className, attributes, options) {
      (0, _classCallCheck22.default)(this, ParseObject3);
      (0, _defineProperty3.default)(this, "id", void 0);
      (0, _defineProperty3.default)(this, "_localId", void 0);
      (0, _defineProperty3.default)(this, "_objCount", void 0);
      (0, _defineProperty3.default)(this, "className", void 0);
      if (typeof this.initialize === "function") {
        this.initialize.apply(this, arguments);
      }
      var toSet = null;
      this._objCount = objectCount++;
      if (typeof className === "string") {
        this.className = className;
        if (attributes && (0, _typeof22.default)(attributes) === "object") {
          toSet = attributes;
        }
      } else if (className && (0, _typeof22.default)(className) === "object") {
        this.className = className.className;
        toSet = {};
        for (var _attr in className) {
          if (_attr !== "className") {
            toSet[_attr] = className[_attr];
          }
        }
        if (attributes && (0, _typeof22.default)(attributes) === "object") {
          options = attributes;
        }
      }
      if (toSet && !this.set(toSet, options)) {
        throw new Error("Can't create an invalid Parse Object");
      }
    }
    (0, _createClass22.default)(ParseObject3, [{
      key: "attributes",
      get: function() {
        var stateController = _CoreManager2.default.getObjectStateController();
        return (0, _freeze.default)(stateController.estimateAttributes(this._getStateIdentifier()));
      }
    }, {
      key: "createdAt",
      get: function() {
        return this._getServerData().createdAt;
      }
    }, {
      key: "updatedAt",
      get: function() {
        return this._getServerData().updatedAt;
      }
    }, {
      key: "_getId",
      value: function() {
        if (typeof this.id === "string") {
          return this.id;
        }
        if (typeof this._localId === "string") {
          return this._localId;
        }
        var localId = "local" + uuidv42();
        this._localId = localId;
        return localId;
      }
    }, {
      key: "_getStateIdentifier",
      value: function() {
        if (singleInstance) {
          var id2 = this.id;
          if (!id2) {
            id2 = this._getId();
          }
          return {
            id: id2,
            className: this.className
          };
        } else {
          return this;
        }
      }
    }, {
      key: "_getServerData",
      value: function() {
        var stateController = _CoreManager2.default.getObjectStateController();
        return stateController.getServerData(this._getStateIdentifier());
      }
    }, {
      key: "_clearServerData",
      value: function() {
        var serverData = this._getServerData();
        var unset = {};
        for (var _attr2 in serverData) {
          unset[_attr2] = void 0;
        }
        var stateController = _CoreManager2.default.getObjectStateController();
        stateController.setServerData(this._getStateIdentifier(), unset);
      }
    }, {
      key: "_getPendingOps",
      value: function() {
        var stateController = _CoreManager2.default.getObjectStateController();
        return stateController.getPendingOps(this._getStateIdentifier());
      }
    }, {
      key: "_clearPendingOps",
      value: function(keysToClear) {
        var pending = this._getPendingOps();
        var latest = pending[pending.length - 1];
        var keys4 = keysToClear || (0, _keys4.default)(latest);
        (0, _forEach2.default)(keys4).call(keys4, function(key) {
          delete latest[key];
        });
      }
    }, {
      key: "_getDirtyObjectAttributes",
      value: function() {
        var attributes = this.attributes;
        var stateController = _CoreManager2.default.getObjectStateController();
        var objectCache = stateController.getObjectCache(this._getStateIdentifier());
        var dirty = {};
        for (var _attr3 in attributes) {
          var val = attributes[_attr3];
          if (val && (0, _typeof22.default)(val) === "object" && !(val instanceof ParseObject3) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {
            try {
              var json = (0, _encode2.default)(val, false, true);
              var stringified = (0, _stringify2.default)(json);
              if (objectCache[_attr3] !== stringified) {
                dirty[_attr3] = val;
              }
            } catch (e2) {
              dirty[_attr3] = val;
            }
          }
        }
        return dirty;
      }
    }, {
      key: "_toFullJSON",
      value: function(seen, offline) {
        var json = this.toJSON(seen, offline);
        json.__type = "Object";
        json.className = this.className;
        return json;
      }
    }, {
      key: "_getSaveJSON",
      value: function() {
        var pending = this._getPendingOps();
        var dirtyObjects = this._getDirtyObjectAttributes();
        var json = {};
        for (var attr in dirtyObjects) {
          var isDotNotation = false;
          for (var i2 = 0; i2 < pending.length; i2 += 1) {
            for (var field in pending[i2]) {
              if ((0, _includes2.default)(field).call(field, ".")) {
                var fieldName = field.split(".")[0];
                if (fieldName === attr) {
                  isDotNotation = true;
                  break;
                }
              }
            }
          }
          if (!isDotNotation) {
            json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();
          }
        }
        for (attr in pending[0]) {
          json[attr] = pending[0][attr].toJSON();
        }
        return json;
      }
    }, {
      key: "_getSaveParams",
      value: function() {
        var method2 = this.id ? "PUT" : "POST";
        var body = this._getSaveJSON();
        var path2 = "classes/" + this.className;
        if (_CoreManager2.default.get("ALLOW_CUSTOM_OBJECT_ID")) {
          if (!this.createdAt) {
            method2 = "POST";
            body.objectId = this.id;
          } else {
            method2 = "PUT";
            path2 += "/" + this.id;
          }
        } else if (this.id) {
          path2 += "/" + this.id;
        } else if (this.className === "_User") {
          path2 = "users";
        }
        return {
          method: method2,
          body,
          path: path2
        };
      }
    }, {
      key: "_finishFetch",
      value: function(serverData) {
        if (!this.id && serverData.objectId) {
          this.id = serverData.objectId;
        }
        var stateController = _CoreManager2.default.getObjectStateController();
        stateController.initializeState(this._getStateIdentifier());
        var decoded = {};
        for (var _attr4 in serverData) {
          if (_attr4 === "ACL") {
            decoded[_attr4] = new _ParseACL.default(serverData[_attr4]);
          } else if (_attr4 !== "objectId") {
            decoded[_attr4] = (0, _decode2.default)(serverData[_attr4]);
            if (decoded[_attr4] instanceof _ParseRelation.default) {
              decoded[_attr4]._ensureParentAndKey(this, _attr4);
            }
          }
        }
        if (decoded.createdAt && typeof decoded.createdAt === "string") {
          decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);
        }
        if (decoded.updatedAt && typeof decoded.updatedAt === "string") {
          decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);
        }
        if (!decoded.updatedAt && decoded.createdAt) {
          decoded.updatedAt = decoded.createdAt;
        }
        stateController.commitServerChanges(this._getStateIdentifier(), decoded);
      }
    }, {
      key: "_setExisted",
      value: function(existed) {
        var stateController = _CoreManager2.default.getObjectStateController();
        var state = stateController.getState(this._getStateIdentifier());
        if (state) {
          state.existed = existed;
        }
      }
    }, {
      key: "_migrateId",
      value: function(serverId) {
        if (this._localId && serverId) {
          if (singleInstance) {
            var stateController = _CoreManager2.default.getObjectStateController();
            var oldState = stateController.removeState(this._getStateIdentifier());
            this.id = serverId;
            delete this._localId;
            if (oldState) {
              stateController.initializeState(this._getStateIdentifier(), oldState);
            }
          } else {
            this.id = serverId;
            delete this._localId;
          }
        }
      }
    }, {
      key: "_handleSaveResponse",
      value: function(response, status) {
        var changes = {};
        var stateController = _CoreManager2.default.getObjectStateController();
        var pending = stateController.popPendingState(this._getStateIdentifier());
        for (var attr in pending) {
          if (pending[attr] instanceof _ParseOp.RelationOp) {
            changes[attr] = pending[attr].applyTo(void 0, this, attr);
          } else if (!(attr in response)) {
            changes[attr] = pending[attr].applyTo(void 0);
          }
        }
        for (attr in response) {
          if ((attr === "createdAt" || attr === "updatedAt") && typeof response[attr] === "string") {
            changes[attr] = (0, _parseDate.default)(response[attr]);
          } else if (attr === "ACL") {
            changes[attr] = new _ParseACL.default(response[attr]);
          } else if (attr !== "objectId") {
            var val = (0, _decode2.default)(response[attr]);
            if (val && (0, _getPrototypeOf.default)(val) === Object.prototype) {
              changes[attr] = _objectSpread2(_objectSpread2({}, this.attributes[attr]), val);
            } else {
              changes[attr] = val;
            }
            if (changes[attr] instanceof _ParseOp.UnsetOp) {
              changes[attr] = void 0;
            }
          }
        }
        if (changes.createdAt && !changes.updatedAt) {
          changes.updatedAt = changes.createdAt;
        }
        this._migrateId(response.objectId);
        if (status !== 201) {
          this._setExisted(true);
        }
        stateController.commitServerChanges(this._getStateIdentifier(), changes);
      }
    }, {
      key: "_handleSaveError",
      value: function() {
        var stateController = _CoreManager2.default.getObjectStateController();
        stateController.mergeFirstPendingState(this._getStateIdentifier());
      }
    }, {
      key: "initialize",
      value: function() {
      }
    }, {
      key: "toJSON",
      value: function(seen, offline) {
        var seenEntry = this.id ? this.className + ":" + this.id : this;
        seen = seen || [seenEntry];
        var json = {};
        var attrs = this.attributes;
        for (var _attr5 in attrs) {
          if ((_attr5 === "createdAt" || _attr5 === "updatedAt") && attrs[_attr5].toJSON) {
            json[_attr5] = attrs[_attr5].toJSON();
          } else {
            json[_attr5] = (0, _encode2.default)(attrs[_attr5], false, false, seen, offline);
          }
        }
        var pending = this._getPendingOps();
        for (var _attr6 in pending[0]) {
          json[_attr6] = pending[0][_attr6].toJSON(offline);
        }
        if (this.id) {
          json.objectId = this.id;
        }
        return json;
      }
    }, {
      key: "equals",
      value: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof ParseObject3 && this.className === other.className && this.id === other.id && typeof this.id !== "undefined";
      }
    }, {
      key: "dirty",
      value: function(attr) {
        if (!this.id) {
          return true;
        }
        var pendingOps = this._getPendingOps();
        var dirtyObjects = this._getDirtyObjectAttributes();
        if (attr) {
          if (dirtyObjects.hasOwnProperty(attr)) {
            return true;
          }
          for (var i2 = 0; i2 < pendingOps.length; i2++) {
            if (pendingOps[i2].hasOwnProperty(attr)) {
              return true;
            }
          }
          return false;
        }
        if ((0, _keys4.default)(pendingOps[0]).length !== 0) {
          return true;
        }
        if ((0, _keys4.default)(dirtyObjects).length !== 0) {
          return true;
        }
        return false;
      }
    }, {
      key: "dirtyKeys",
      value: function() {
        var pendingOps = this._getPendingOps();
        var keys4 = {};
        for (var i2 = 0; i2 < pendingOps.length; i2++) {
          for (var _attr7 in pendingOps[i2]) {
            keys4[_attr7] = true;
          }
        }
        var dirtyObjects = this._getDirtyObjectAttributes();
        for (var _attr8 in dirtyObjects) {
          keys4[_attr8] = true;
        }
        return (0, _keys4.default)(keys4);
      }
    }, {
      key: "isDataAvailable",
      value: function() {
        var serverData = this._getServerData();
        return !!(0, _keys4.default)(serverData).length;
      }
    }, {
      key: "toPointer",
      value: function() {
        if (!this.id) {
          throw new Error("Cannot create a pointer to an unsaved ParseObject");
        }
        return {
          __type: "Pointer",
          className: this.className,
          objectId: this.id
        };
      }
    }, {
      key: "toOfflinePointer",
      value: function() {
        if (!this._localId) {
          throw new Error("Cannot create a offline pointer to a saved ParseObject");
        }
        return {
          __type: "Object",
          className: this.className,
          _localId: this._localId
        };
      }
    }, {
      key: "get",
      value: function(attr) {
        return this.attributes[attr];
      }
    }, {
      key: "relation",
      value: function(attr) {
        var value = this.get(attr);
        if (value) {
          if (!(value instanceof _ParseRelation.default)) {
            throw new Error("Called relation() on non-relation field " + attr);
          }
          value._ensureParentAndKey(this, attr);
          return value;
        }
        return new _ParseRelation.default(this, attr);
      }
    }, {
      key: "escape",
      value: function(attr) {
        var val = this.attributes[attr];
        if (val == null) {
          return "";
        }
        if (typeof val !== "string") {
          if (typeof val.toString !== "function") {
            return "";
          }
          val = val.toString();
        }
        return (0, _escape2.default)(val);
      }
    }, {
      key: "has",
      value: function(attr) {
        var attributes = this.attributes;
        if (attributes.hasOwnProperty(attr)) {
          return attributes[attr] != null;
        }
        return false;
      }
    }, {
      key: "set",
      value: function(key, value, options) {
        var changes = {};
        var newOps = {};
        if (key && (0, _typeof22.default)(key) === "object") {
          changes = key;
          options = value;
        } else if (typeof key === "string") {
          changes[key] = value;
        } else {
          return this;
        }
        options = options || {};
        var readonly2 = [];
        if (typeof this.constructor.readOnlyAttributes === "function") {
          readonly2 = (0, _concat2.default)(readonly2).call(readonly2, this.constructor.readOnlyAttributes());
        }
        for (var k in changes) {
          if (k === "createdAt" || k === "updatedAt") {
            continue;
          }
          if ((0, _indexOf2.default)(readonly2).call(readonly2, k) > -1) {
            throw new Error("Cannot modify readonly attribute: " + k);
          }
          if (options.unset) {
            newOps[k] = new _ParseOp.UnsetOp();
          } else if (changes[k] instanceof _ParseOp.Op) {
            newOps[k] = changes[k];
          } else if (changes[k] && (0, _typeof22.default)(changes[k]) === "object" && typeof changes[k].__op === "string") {
            newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);
          } else if (k === "objectId" || k === "id") {
            if (typeof changes[k] === "string") {
              this.id = changes[k];
            }
          } else if (k === "ACL" && (0, _typeof22.default)(changes[k]) === "object" && !(changes[k] instanceof _ParseACL.default)) {
            newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));
          } else if (changes[k] instanceof _ParseRelation.default) {
            var relation = new _ParseRelation.default(this, k);
            relation.targetClassName = changes[k].targetClassName;
            newOps[k] = new _ParseOp.SetOp(relation);
          } else {
            newOps[k] = new _ParseOp.SetOp(changes[k]);
          }
        }
        var currentAttributes = this.attributes;
        var newValues = {};
        for (var _attr9 in newOps) {
          if (newOps[_attr9] instanceof _ParseOp.RelationOp) {
            newValues[_attr9] = newOps[_attr9].applyTo(currentAttributes[_attr9], this, _attr9);
          } else if (!(newOps[_attr9] instanceof _ParseOp.UnsetOp)) {
            newValues[_attr9] = newOps[_attr9].applyTo(currentAttributes[_attr9]);
          }
        }
        if (!options.ignoreValidation) {
          var validation = this.validate(newValues);
          if (validation) {
            if (typeof options.error === "function") {
              options.error(this, validation);
            }
            return false;
          }
        }
        var pendingOps = this._getPendingOps();
        var last2 = pendingOps.length - 1;
        var stateController = _CoreManager2.default.getObjectStateController();
        for (var _attr10 in newOps) {
          var nextOp = newOps[_attr10].mergeWith(pendingOps[last2][_attr10]);
          stateController.setPendingOp(this._getStateIdentifier(), _attr10, nextOp);
        }
        return this;
      }
    }, {
      key: "unset",
      value: function(attr, options) {
        options = options || {};
        options.unset = true;
        return this.set(attr, null, options);
      }
    }, {
      key: "increment",
      value: function(attr, amount) {
        if (typeof amount === "undefined") {
          amount = 1;
        }
        if (typeof amount !== "number") {
          throw new Error("Cannot increment by a non-numeric amount.");
        }
        return this.set(attr, new _ParseOp.IncrementOp(amount));
      }
    }, {
      key: "decrement",
      value: function(attr, amount) {
        if (typeof amount === "undefined") {
          amount = 1;
        }
        if (typeof amount !== "number") {
          throw new Error("Cannot decrement by a non-numeric amount.");
        }
        return this.set(attr, new _ParseOp.IncrementOp(amount * -1));
      }
    }, {
      key: "add",
      value: function(attr, item) {
        return this.set(attr, new _ParseOp.AddOp([item]));
      }
    }, {
      key: "addAll",
      value: function(attr, items) {
        return this.set(attr, new _ParseOp.AddOp(items));
      }
    }, {
      key: "addUnique",
      value: function(attr, item) {
        return this.set(attr, new _ParseOp.AddUniqueOp([item]));
      }
    }, {
      key: "addAllUnique",
      value: function(attr, items) {
        return this.set(attr, new _ParseOp.AddUniqueOp(items));
      }
    }, {
      key: "remove",
      value: function(attr, item) {
        return this.set(attr, new _ParseOp.RemoveOp([item]));
      }
    }, {
      key: "removeAll",
      value: function(attr, items) {
        return this.set(attr, new _ParseOp.RemoveOp(items));
      }
    }, {
      key: "op",
      value: function(attr) {
        var pending = this._getPendingOps();
        for (var i2 = pending.length; i2--; ) {
          if (pending[i2][attr]) {
            return pending[i2][attr];
          }
        }
      }
    }, {
      key: "clone",
      value: function clone() {
        var clone2 = new this.constructor(this.className);
        var attributes = this.attributes;
        if (typeof this.constructor.readOnlyAttributes === "function") {
          var readonly2 = this.constructor.readOnlyAttributes() || [];
          var copy = {};
          for (var a in attributes) {
            if ((0, _indexOf2.default)(readonly2).call(readonly2, a) < 0) {
              copy[a] = attributes[a];
            }
          }
          attributes = copy;
        }
        if (clone2.set) {
          clone2.set(attributes);
        }
        return clone2;
      }
    }, {
      key: "newInstance",
      value: function() {
        var clone = new this.constructor(this.className);
        clone.id = this.id;
        if (singleInstance) {
          return clone;
        }
        var stateController = _CoreManager2.default.getObjectStateController();
        if (stateController) {
          stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());
        }
        return clone;
      }
    }, {
      key: "isNew",
      value: function() {
        return !this.id;
      }
    }, {
      key: "existed",
      value: function() {
        if (!this.id) {
          return false;
        }
        var stateController = _CoreManager2.default.getObjectStateController();
        var state = stateController.getState(this._getStateIdentifier());
        if (state) {
          return state.existed;
        }
        return false;
      }
    }, {
      key: "exists",
      value: function() {
        var _exists = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee(options) {
          var query;
          return _regenerator2.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (this.id) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 2:
                  _context.prev = 2;
                  query = new _ParseQuery2.default(this.className);
                  _context.next = 6;
                  return query.get(this.id, options);
                case 6:
                  return _context.abrupt("return", true);
                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](2);
                  if (!(_context.t0.code === _ParseError2.default.OBJECT_NOT_FOUND)) {
                    _context.next = 13;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 13:
                  throw _context.t0;
                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[2, 9]]);
        }));
        return function() {
          return _exists.apply(this, arguments);
        };
      }()
    }, {
      key: "isValid",
      value: function() {
        return !this.validate(this.attributes);
      }
    }, {
      key: "validate",
      value: function(attrs) {
        if (attrs.hasOwnProperty("ACL") && !(attrs.ACL instanceof _ParseACL.default)) {
          return new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "ACL must be a Parse ACL.");
        }
        for (var _key in attrs) {
          if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(_key)) {
            return new _ParseError2.default(_ParseError2.default.INVALID_KEY_NAME);
          }
        }
        return false;
      }
    }, {
      key: "getACL",
      value: function() {
        var acl = this.get("ACL");
        if (acl instanceof _ParseACL.default) {
          return acl;
        }
        return null;
      }
    }, {
      key: "setACL",
      value: function(acl, options) {
        return this.set("ACL", acl, options);
      }
    }, {
      key: "revert",
      value: function() {
        var keysToRevert;
        for (var _len = arguments.length, keys4 = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
          keys4[_key2] = arguments[_key2];
        }
        if (keys4.length) {
          keysToRevert = [];
          var _iterator = _createForOfIteratorHelper2(keys4), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _key3 = _step.value;
              if (typeof _key3 === "string") {
                keysToRevert.push(_key3);
              } else {
                throw new Error("Parse.Object#revert expects either no, or a list of string, arguments.");
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        this._clearPendingOps(keysToRevert);
      }
    }, {
      key: "clear",
      value: function() {
        var attributes = this.attributes;
        var erasable = {};
        var readonly2 = ["createdAt", "updatedAt"];
        if (typeof this.constructor.readOnlyAttributes === "function") {
          readonly2 = (0, _concat2.default)(readonly2).call(readonly2, this.constructor.readOnlyAttributes());
        }
        for (var _attr11 in attributes) {
          if ((0, _indexOf2.default)(readonly2).call(readonly2, _attr11) < 0) {
            erasable[_attr11] = true;
          }
        }
        return this.set(erasable, {
          unset: true
        });
      }
    }, {
      key: "fetch",
      value: function(options) {
        options = options || {};
        var fetchOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          fetchOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          fetchOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          fetchOptions.context = options.context;
        }
        if (options.hasOwnProperty("include")) {
          fetchOptions.include = [];
          if ((0, _isArray2.default)(options.include)) {
            var _context2;
            (0, _forEach2.default)(_context2 = options.include).call(_context2, function(key) {
              if ((0, _isArray2.default)(key)) {
                var _context3;
                fetchOptions.include = (0, _concat2.default)(_context3 = fetchOptions.include).call(_context3, key);
              } else {
                fetchOptions.include.push(key);
              }
            });
          } else {
            fetchOptions.include.push(options.include);
          }
        }
        var controller = _CoreManager2.default.getObjectController();
        return controller.fetch(this, true, fetchOptions);
      }
    }, {
      key: "fetchWithInclude",
      value: function(keys4, options) {
        options = options || {};
        options.include = keys4;
        return this.fetch(options);
      }
    }, {
      key: "saveEventually",
      value: function() {
        var _saveEventually = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee2(options) {
          return _regenerator2.default.wrap(function(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.prev = 0;
                  _context4.next = 3;
                  return this.save(null, options);
                case 3:
                  _context4.next = 11;
                  break;
                case 5:
                  _context4.prev = 5;
                  _context4.t0 = _context4["catch"](0);
                  if (!(_context4.t0.message === 'XMLHttpRequest failed: "Unable to connect to the Parse API"')) {
                    _context4.next = 11;
                    break;
                  }
                  _context4.next = 10;
                  return _EventuallyQueue2.default.save(this, options);
                case 10:
                  _EventuallyQueue2.default.poll();
                case 11:
                  return _context4.abrupt("return", this);
                case 12:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee2, this, [[0, 5]]);
        }));
        return function() {
          return _saveEventually.apply(this, arguments);
        };
      }()
    }, {
      key: "save",
      value: function(arg1, arg2, arg3) {
        var _this = this;
        var attrs;
        var options;
        if ((0, _typeof22.default)(arg1) === "object" || typeof arg1 === "undefined") {
          attrs = arg1;
          if ((0, _typeof22.default)(arg2) === "object") {
            options = arg2;
          }
        } else {
          attrs = {};
          attrs[arg1] = arg2;
          options = arg3;
        }
        if (attrs) {
          var validation = this.validate(attrs);
          if (validation) {
            return _promise2.default.reject(validation);
          }
          this.set(attrs, options);
        }
        options = options || {};
        var saveOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          saveOptions.useMasterKey = !!options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken") && typeof options.sessionToken === "string") {
          saveOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("installationId") && typeof options.installationId === "string") {
          saveOptions.installationId = options.installationId;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          saveOptions.context = options.context;
        }
        var controller = _CoreManager2.default.getObjectController();
        var unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;
        return controller.save(unsaved, saveOptions).then(function() {
          return controller.save(_this, saveOptions);
        });
      }
    }, {
      key: "destroyEventually",
      value: function() {
        var _destroyEventually = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee3(options) {
          return _regenerator2.default.wrap(function(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.prev = 0;
                  _context5.next = 3;
                  return this.destroy(options);
                case 3:
                  _context5.next = 11;
                  break;
                case 5:
                  _context5.prev = 5;
                  _context5.t0 = _context5["catch"](0);
                  if (!(_context5.t0.message === 'XMLHttpRequest failed: "Unable to connect to the Parse API"')) {
                    _context5.next = 11;
                    break;
                  }
                  _context5.next = 10;
                  return _EventuallyQueue2.default.destroy(this, options);
                case 10:
                  _EventuallyQueue2.default.poll();
                case 11:
                  return _context5.abrupt("return", this);
                case 12:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee3, this, [[0, 5]]);
        }));
        return function() {
          return _destroyEventually.apply(this, arguments);
        };
      }()
    }, {
      key: "destroy",
      value: function(options) {
        options = options || {};
        var destroyOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          destroyOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          destroyOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          destroyOptions.context = options.context;
        }
        if (!this.id) {
          return _promise2.default.resolve();
        }
        return _CoreManager2.default.getObjectController().destroy(this, destroyOptions);
      }
    }, {
      key: "pin",
      value: function() {
        return ParseObject3.pinAllWithName(_LocalDatastoreUtils2.DEFAULT_PIN, [this]);
      }
    }, {
      key: "unPin",
      value: function() {
        return ParseObject3.unPinAllWithName(_LocalDatastoreUtils2.DEFAULT_PIN, [this]);
      }
    }, {
      key: "isPinned",
      value: function() {
        var _isPinned = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee4() {
          var localDatastore, objectKey, pin;
          return _regenerator2.default.wrap(function(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  localDatastore = _CoreManager2.default.getLocalDatastore();
                  if (localDatastore.isEnabled) {
                    _context6.next = 3;
                    break;
                  }
                  return _context6.abrupt("return", _promise2.default.reject("Parse.enableLocalDatastore() must be called first"));
                case 3:
                  objectKey = localDatastore.getKeyForObject(this);
                  _context6.next = 6;
                  return localDatastore.fromPinWithName(objectKey);
                case 6:
                  pin = _context6.sent;
                  return _context6.abrupt("return", pin.length > 0);
                case 8:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee4, this);
        }));
        return function() {
          return _isPinned.apply(this, arguments);
        };
      }()
    }, {
      key: "pinWithName",
      value: function(name) {
        return ParseObject3.pinAllWithName(name, [this]);
      }
    }, {
      key: "unPinWithName",
      value: function(name) {
        return ParseObject3.unPinAllWithName(name, [this]);
      }
    }, {
      key: "fetchFromLocalDatastore",
      value: function() {
        var _fetchFromLocalDatastore = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee5() {
          var localDatastore, objectKey, pinned, result;
          return _regenerator2.default.wrap(function(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  localDatastore = _CoreManager2.default.getLocalDatastore();
                  if (localDatastore.isEnabled) {
                    _context7.next = 3;
                    break;
                  }
                  throw new Error("Parse.enableLocalDatastore() must be called first");
                case 3:
                  objectKey = localDatastore.getKeyForObject(this);
                  _context7.next = 6;
                  return localDatastore._serializeObject(objectKey);
                case 6:
                  pinned = _context7.sent;
                  if (pinned) {
                    _context7.next = 9;
                    break;
                  }
                  throw new Error("Cannot fetch an unsaved ParseObject");
                case 9:
                  result = ParseObject3.fromJSON(pinned);
                  this._finishFetch(result.toJSON());
                  return _context7.abrupt("return", this);
                case 12:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee5, this);
        }));
        return function() {
          return _fetchFromLocalDatastore.apply(this, arguments);
        };
      }()
    }], [{
      key: "_getClassMap",
      value: function() {
        return classMap;
      }
    }, {
      key: "_clearAllState",
      value: function() {
        var stateController = _CoreManager2.default.getObjectStateController();
        stateController.clearAllState();
      }
    }, {
      key: "fetchAll",
      value: function(list) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var queryOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          queryOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          queryOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("include")) {
          queryOptions.include = ParseObject3.handleIncludeOptions(options);
        }
        return _CoreManager2.default.getObjectController().fetch(list, true, queryOptions);
      }
    }, {
      key: "fetchAllWithInclude",
      value: function(list, keys4, options) {
        options = options || {};
        options.include = keys4;
        return ParseObject3.fetchAll(list, options);
      }
    }, {
      key: "fetchAllIfNeededWithInclude",
      value: function(list, keys4, options) {
        options = options || {};
        options.include = keys4;
        return ParseObject3.fetchAllIfNeeded(list, options);
      }
    }, {
      key: "fetchAllIfNeeded",
      value: function(list, options) {
        options = options || {};
        var queryOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          queryOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          queryOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("include")) {
          queryOptions.include = ParseObject3.handleIncludeOptions(options);
        }
        return _CoreManager2.default.getObjectController().fetch(list, false, queryOptions);
      }
    }, {
      key: "handleIncludeOptions",
      value: function(options) {
        var include = [];
        if ((0, _isArray2.default)(options.include)) {
          var _context8;
          (0, _forEach2.default)(_context8 = options.include).call(_context8, function(key) {
            if ((0, _isArray2.default)(key)) {
              include = (0, _concat2.default)(include).call(include, key);
            } else {
              include.push(key);
            }
          });
        } else {
          include.push(options.include);
        }
        return include;
      }
    }, {
      key: "destroyAll",
      value: function(list) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var destroyOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          destroyOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          destroyOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("batchSize") && typeof options.batchSize === "number") {
          destroyOptions.batchSize = options.batchSize;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          destroyOptions.context = options.context;
        }
        return _CoreManager2.default.getObjectController().destroy(list, destroyOptions);
      }
    }, {
      key: "saveAll",
      value: function(list) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var saveOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          saveOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("sessionToken")) {
          saveOptions.sessionToken = options.sessionToken;
        }
        if (options.hasOwnProperty("batchSize") && typeof options.batchSize === "number") {
          saveOptions.batchSize = options.batchSize;
        }
        if (options.hasOwnProperty("context") && (0, _typeof22.default)(options.context) === "object") {
          saveOptions.context = options.context;
        }
        return _CoreManager2.default.getObjectController().save(list, saveOptions);
      }
    }, {
      key: "createWithoutData",
      value: function(id2) {
        var obj = new this();
        obj.id = id2;
        return obj;
      }
    }, {
      key: "fromJSON",
      value: function(json, override, dirty) {
        if (!json.className) {
          throw new Error("Cannot create an object without a className");
        }
        var constructor = classMap[json.className];
        var o2 = constructor ? new constructor(json.className) : new ParseObject3(json.className);
        var otherAttributes = {};
        for (var _attr12 in json) {
          if (_attr12 !== "className" && _attr12 !== "__type") {
            otherAttributes[_attr12] = json[_attr12];
            if (dirty) {
              o2.set(_attr12, json[_attr12]);
            }
          }
        }
        if (override) {
          if (otherAttributes.objectId) {
            o2.id = otherAttributes.objectId;
          }
          var preserved = null;
          if (typeof o2._preserveFieldsOnFetch === "function") {
            preserved = o2._preserveFieldsOnFetch();
          }
          o2._clearServerData();
          if (preserved) {
            o2._finishFetch(preserved);
          }
        }
        o2._finishFetch(otherAttributes);
        if (json.objectId) {
          o2._setExisted(true);
        }
        return o2;
      }
    }, {
      key: "registerSubclass",
      value: function(className, constructor) {
        if (typeof className !== "string") {
          throw new TypeError("The first argument must be a valid class name.");
        }
        if (typeof constructor === "undefined") {
          throw new TypeError("You must supply a subclass constructor.");
        }
        if (typeof constructor !== "function") {
          throw new TypeError("You must register the subclass constructor. Did you attempt to register an instance of the subclass?");
        }
        classMap[className] = constructor;
        if (!constructor.className) {
          constructor.className = className;
        }
      }
    }, {
      key: "unregisterSubclass",
      value: function(className) {
        if (typeof className !== "string") {
          throw new TypeError("The first argument must be a valid class name.");
        }
        delete classMap[className];
      }
    }, {
      key: "extend",
      value: function(className, protoProps, classProps) {
        if (typeof className !== "string") {
          if (className && typeof className.className === "string") {
            return ParseObject3.extend(className.className, className, protoProps);
          } else {
            throw new Error("Parse.Object.extend's first argument should be the className.");
          }
        }
        var adjustedClassName = className;
        if (adjustedClassName === "User" && _CoreManager2.default.get("PERFORM_USER_REWRITE")) {
          adjustedClassName = "_User";
        }
        var parentProto = ParseObject3.prototype;
        if (this.hasOwnProperty("__super__") && this.__super__) {
          parentProto = this.prototype;
        } else if (classMap[adjustedClassName]) {
          parentProto = classMap[adjustedClassName].prototype;
        }
        var ParseObjectSubclass = function(attributes, options) {
          this.className = adjustedClassName;
          this._objCount = objectCount++;
          if (typeof this.initialize === "function") {
            this.initialize.apply(this, arguments);
          }
          if (attributes && (0, _typeof22.default)(attributes) === "object") {
            if (!this.set(attributes || {}, options)) {
              throw new Error("Can't create an invalid Parse Object");
            }
          }
        };
        ParseObjectSubclass.className = adjustedClassName;
        ParseObjectSubclass.__super__ = parentProto;
        ParseObjectSubclass.prototype = (0, _create.default)(parentProto, {
          constructor: {
            value: ParseObjectSubclass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (protoProps) {
          for (var prop in protoProps) {
            if (prop !== "className") {
              (0, _defineProperty22.default)(ParseObjectSubclass.prototype, prop, {
                value: protoProps[prop],
                enumerable: false,
                writable: true,
                configurable: true
              });
            }
          }
        }
        if (classProps) {
          for (var _prop in classProps) {
            if (_prop !== "className") {
              (0, _defineProperty22.default)(ParseObjectSubclass, _prop, {
                value: classProps[_prop],
                enumerable: false,
                writable: true,
                configurable: true
              });
            }
          }
        }
        ParseObjectSubclass.extend = function(name, protoProps2, classProps2) {
          if (typeof name === "string") {
            return ParseObject3.extend.call(ParseObjectSubclass, name, protoProps2, classProps2);
          }
          return ParseObject3.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps2);
        };
        ParseObjectSubclass.createWithoutData = ParseObject3.createWithoutData;
        classMap[adjustedClassName] = ParseObjectSubclass;
        return ParseObjectSubclass;
      }
    }, {
      key: "enableSingleInstance",
      value: function() {
        singleInstance = true;
        _CoreManager2.default.setObjectStateController(SingleInstanceStateController$1);
      }
    }, {
      key: "disableSingleInstance",
      value: function() {
        singleInstance = false;
        _CoreManager2.default.setObjectStateController(UniqueInstanceStateController$1);
      }
    }, {
      key: "pinAll",
      value: function(objects) {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (!localDatastore.isEnabled) {
          return _promise2.default.reject("Parse.enableLocalDatastore() must be called first");
        }
        return ParseObject3.pinAllWithName(_LocalDatastoreUtils2.DEFAULT_PIN, objects);
      }
    }, {
      key: "pinAllWithName",
      value: function(name, objects) {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (!localDatastore.isEnabled) {
          return _promise2.default.reject("Parse.enableLocalDatastore() must be called first");
        }
        return localDatastore._handlePinAllWithName(name, objects);
      }
    }, {
      key: "unPinAll",
      value: function(objects) {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (!localDatastore.isEnabled) {
          return _promise2.default.reject("Parse.enableLocalDatastore() must be called first");
        }
        return ParseObject3.unPinAllWithName(_LocalDatastoreUtils2.DEFAULT_PIN, objects);
      }
    }, {
      key: "unPinAllWithName",
      value: function(name, objects) {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (!localDatastore.isEnabled) {
          return _promise2.default.reject("Parse.enableLocalDatastore() must be called first");
        }
        return localDatastore._handleUnPinAllWithName(name, objects);
      }
    }, {
      key: "unPinAllObjects",
      value: function() {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (!localDatastore.isEnabled) {
          return _promise2.default.reject("Parse.enableLocalDatastore() must be called first");
        }
        return localDatastore.unPinWithName(_LocalDatastoreUtils2.DEFAULT_PIN);
      }
    }, {
      key: "unPinAllObjectsWithName",
      value: function(name) {
        var localDatastore = _CoreManager2.default.getLocalDatastore();
        if (!localDatastore.isEnabled) {
          return _promise2.default.reject("Parse.enableLocalDatastore() must be called first");
        }
        return localDatastore.unPinWithName(_LocalDatastoreUtils2.PIN_PREFIX + name);
      }
    }]);
    return ParseObject3;
  }();
  var DefaultController = {
    fetch: function(target, forceFetch, options) {
      var localDatastore = _CoreManager2.default.getLocalDatastore();
      if ((0, _isArray2.default)(target)) {
        if (target.length < 1) {
          return _promise2.default.resolve([]);
        }
        var objs = [];
        var ids = [];
        var className = null;
        var results = [];
        var error = null;
        (0, _forEach2.default)(target).call(target, function(el) {
          if (error) {
            return;
          }
          if (!className) {
            className = el.className;
          }
          if (className !== el.className) {
            error = new _ParseError2.default(_ParseError2.default.INVALID_CLASS_NAME, "All objects should be of the same class");
          }
          if (!el.id) {
            error = new _ParseError2.default(_ParseError2.default.MISSING_OBJECT_ID, "All objects must have an ID");
          }
          if (forceFetch || !el.isDataAvailable()) {
            ids.push(el.id);
            objs.push(el);
          }
          results.push(el);
        });
        if (error) {
          return _promise2.default.reject(error);
        }
        var query = new _ParseQuery2.default(className);
        query.containedIn("objectId", ids);
        if (options && options.include) {
          query.include(options.include);
        }
        query._limit = ids.length;
        return (0, _find2.default)(query).call(query, options).then(/* @__PURE__ */ function() {
          var _ref = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee6(objects) {
            var idMap, i2, obj, _i, _obj, id2, _iterator2, _step2, object;
            return _regenerator2.default.wrap(function(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    idMap = {};
                    (0, _forEach2.default)(objects).call(objects, function(o2) {
                      idMap[o2.id] = o2;
                    });
                    i2 = 0;
                  case 3:
                    if (!(i2 < objs.length)) {
                      _context9.next = 11;
                      break;
                    }
                    obj = objs[i2];
                    if (!(!obj || !obj.id || !idMap[obj.id])) {
                      _context9.next = 8;
                      break;
                    }
                    if (!forceFetch) {
                      _context9.next = 8;
                      break;
                    }
                    return _context9.abrupt("return", _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OBJECT_NOT_FOUND, "All objects must exist on the server.")));
                  case 8:
                    i2++;
                    _context9.next = 3;
                    break;
                  case 11:
                    if (!singleInstance) {
                      for (_i = 0; _i < results.length; _i++) {
                        _obj = results[_i];
                        if (_obj && _obj.id && idMap[_obj.id]) {
                          id2 = _obj.id;
                          _obj._finishFetch(idMap[id2].toJSON());
                          results[_i] = idMap[id2];
                        }
                      }
                    }
                    _iterator2 = _createForOfIteratorHelper2(results);
                    _context9.prev = 13;
                    _iterator2.s();
                  case 15:
                    if ((_step2 = _iterator2.n()).done) {
                      _context9.next = 21;
                      break;
                    }
                    object = _step2.value;
                    _context9.next = 19;
                    return localDatastore._updateObjectIfPinned(object);
                  case 19:
                    _context9.next = 15;
                    break;
                  case 21:
                    _context9.next = 26;
                    break;
                  case 23:
                    _context9.prev = 23;
                    _context9.t0 = _context9["catch"](13);
                    _iterator2.e(_context9.t0);
                  case 26:
                    _context9.prev = 26;
                    _iterator2.f();
                    return _context9.finish(26);
                  case 29:
                    return _context9.abrupt("return", _promise2.default.resolve(results));
                  case 30:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee6, null, [[13, 23, 26, 29]]);
          }));
          return function() {
            return _ref.apply(this, arguments);
          };
        }());
      } else if (target instanceof ParseObject2) {
        if (!target.id) {
          return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.MISSING_OBJECT_ID, "Object does not have an ID"));
        }
        var RESTController2 = _CoreManager2.default.getRESTController();
        var params = {};
        if (options && options.include) {
          params.include = options.include.join();
        }
        return RESTController2.request("GET", "classes/" + target.className + "/" + target._getId(), params, options).then(/* @__PURE__ */ function() {
          var _ref2 = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee7(response) {
            return _regenerator2.default.wrap(function(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    target._clearPendingOps();
                    target._clearServerData();
                    target._finishFetch(response);
                    _context10.next = 5;
                    return localDatastore._updateObjectIfPinned(target);
                  case 5:
                    return _context10.abrupt("return", target);
                  case 6:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee7);
          }));
          return function() {
            return _ref2.apply(this, arguments);
          };
        }());
      }
      return _promise2.default.resolve();
    },
    destroy: function(target, options) {
      return (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee10() {
        var batchSize, localDatastore, RESTController2, batches, deleteCompleted, errors;
        return _regenerator2.default.wrap(function(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                batchSize = options && options.batchSize ? options.batchSize : _CoreManager2.default.get("REQUEST_BATCH_SIZE");
                localDatastore = _CoreManager2.default.getLocalDatastore();
                RESTController2 = _CoreManager2.default.getRESTController();
                if (!(0, _isArray2.default)(target)) {
                  _context13.next = 15;
                  break;
                }
                if (!(target.length < 1)) {
                  _context13.next = 6;
                  break;
                }
                return _context13.abrupt("return", _promise2.default.resolve([]));
              case 6:
                batches = [[]];
                (0, _forEach2.default)(target).call(target, function(obj) {
                  if (!obj.id) {
                    return;
                  }
                  batches[batches.length - 1].push(obj);
                  if (batches[batches.length - 1].length >= batchSize) {
                    batches.push([]);
                  }
                });
                if (batches[batches.length - 1].length === 0) {
                  batches.pop();
                }
                deleteCompleted = _promise2.default.resolve();
                errors = [];
                (0, _forEach2.default)(batches).call(batches, function(batch) {
                  deleteCompleted = deleteCompleted.then(function() {
                    return RESTController2.request("POST", "batch", {
                      requests: (0, _map2.default)(batch).call(batch, function(obj) {
                        return {
                          method: "DELETE",
                          path: getServerUrlPath() + "classes/" + obj.className + "/" + obj._getId(),
                          body: {}
                        };
                      })
                    }, options).then(function(results) {
                      for (var i2 = 0; i2 < results.length; i2++) {
                        if (results[i2] && results[i2].hasOwnProperty("error")) {
                          var err = new _ParseError2.default(results[i2].error.code, results[i2].error.error);
                          err.object = batch[i2];
                          errors.push(err);
                        }
                      }
                    });
                  });
                });
                return _context13.abrupt("return", deleteCompleted.then(/* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee8() {
                  var aggregate, _iterator3, _step3, object;
                  return _regenerator2.default.wrap(function(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          if (!errors.length) {
                            _context11.next = 4;
                            break;
                          }
                          aggregate = new _ParseError2.default(_ParseError2.default.AGGREGATE_ERROR);
                          aggregate.errors = errors;
                          return _context11.abrupt("return", _promise2.default.reject(aggregate));
                        case 4:
                          _iterator3 = _createForOfIteratorHelper2(target);
                          _context11.prev = 5;
                          _iterator3.s();
                        case 7:
                          if ((_step3 = _iterator3.n()).done) {
                            _context11.next = 13;
                            break;
                          }
                          object = _step3.value;
                          _context11.next = 11;
                          return localDatastore._destroyObjectIfPinned(object);
                        case 11:
                          _context11.next = 7;
                          break;
                        case 13:
                          _context11.next = 18;
                          break;
                        case 15:
                          _context11.prev = 15;
                          _context11.t0 = _context11["catch"](5);
                          _iterator3.e(_context11.t0);
                        case 18:
                          _context11.prev = 18;
                          _iterator3.f();
                          return _context11.finish(18);
                        case 21:
                          return _context11.abrupt("return", _promise2.default.resolve(target));
                        case 22:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee8, null, [[5, 15, 18, 21]]);
                }))));
              case 15:
                if (!(target instanceof ParseObject2)) {
                  _context13.next = 17;
                  break;
                }
                return _context13.abrupt("return", RESTController2.request("DELETE", "classes/" + target.className + "/" + target._getId(), {}, options).then(/* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee9() {
                  return _regenerator2.default.wrap(function(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          _context12.next = 2;
                          return localDatastore._destroyObjectIfPinned(target);
                        case 2:
                          return _context12.abrupt("return", _promise2.default.resolve(target));
                        case 3:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  }, _callee9);
                }))));
              case 17:
                return _context13.abrupt("return", _promise2.default.resolve(target));
              case 18:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee10);
      }))();
    },
    save: function(target, options) {
      var batchSize = options && options.batchSize ? options.batchSize : _CoreManager2.default.get("REQUEST_BATCH_SIZE");
      var localDatastore = _CoreManager2.default.getLocalDatastore();
      var mapIdForPin = {};
      var RESTController2 = _CoreManager2.default.getRESTController();
      var stateController = _CoreManager2.default.getObjectStateController();
      var allowCustomObjectId = _CoreManager2.default.get("ALLOW_CUSTOM_OBJECT_ID");
      options = options || {};
      options.returnStatus = options.returnStatus || true;
      if ((0, _isArray2.default)(target)) {
        if (target.length < 1) {
          return _promise2.default.resolve([]);
        }
        var unsaved = (0, _concat2.default)(target).call(target);
        for (var i2 = 0; i2 < target.length; i2++) {
          if (target[i2] instanceof ParseObject2) {
            unsaved = (0, _concat2.default)(unsaved).call(unsaved, (0, _unsavedChildren.default)(target[i2], true));
          }
        }
        unsaved = (0, _unique.default)(unsaved);
        var filesSaved = [];
        var pending = [];
        (0, _forEach2.default)(unsaved).call(unsaved, function(el) {
          if (el instanceof _ParseFile.default) {
            filesSaved.push(el.save(options));
          } else if (el instanceof ParseObject2) {
            if (allowCustomObjectId && !el.id) {
              throw new _ParseError2.default(_ParseError2.default.MISSING_OBJECT_ID, "objectId must not be empty, null or undefined");
            }
            pending.push(el);
          }
        });
        return _promise2.default.all(filesSaved).then(function() {
          var objectError = null;
          return (0, _promiseUtils2.continueWhile)(function() {
            return pending.length > 0;
          }, function() {
            var batch = [];
            var nextPending = [];
            (0, _forEach2.default)(pending).call(pending, function(el) {
              if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {
                batch.push(el);
              } else {
                nextPending.push(el);
              }
            });
            pending = nextPending;
            if (batch.length < 1) {
              return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Tried to save a batch with a cycle."));
            }
            var batchReturned = new _promiseUtils2.resolvingPromise();
            var batchReady = [];
            var batchTasks = [];
            (0, _forEach2.default)(batch).call(batch, function(obj, index) {
              var ready = new _promiseUtils2.resolvingPromise();
              batchReady.push(ready);
              stateController.pushPendingState(obj._getStateIdentifier());
              batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function() {
                ready.resolve();
                return batchReturned.then(function(responses) {
                  if (responses[index].hasOwnProperty("success")) {
                    var objectId = responses[index].success.objectId;
                    var status = responses[index]._status;
                    delete responses[index]._status;
                    mapIdForPin[objectId] = obj._localId;
                    obj._handleSaveResponse(responses[index].success, status);
                  } else {
                    if (!objectError && responses[index].hasOwnProperty("error")) {
                      var serverError = responses[index].error;
                      objectError = new _ParseError2.default(serverError.code, serverError.error);
                      pending = [];
                    }
                    obj._handleSaveError();
                  }
                });
              }));
            });
            (0, _promiseUtils2.when)(batchReady).then(function() {
              return RESTController2.request("POST", "batch", {
                requests: (0, _map2.default)(batch).call(batch, function(obj) {
                  var params = obj._getSaveParams();
                  params.path = getServerUrlPath() + params.path;
                  return params;
                })
              }, options);
            }).then(batchReturned.resolve, function(error) {
              batchReturned.reject(new _ParseError2.default(_ParseError2.default.INCORRECT_TYPE, error.message));
            });
            return (0, _promiseUtils2.when)(batchTasks);
          }).then(/* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee11() {
            var _iterator4, _step4, object;
            return _regenerator2.default.wrap(function(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    if (!objectError) {
                      _context14.next = 2;
                      break;
                    }
                    return _context14.abrupt("return", _promise2.default.reject(objectError));
                  case 2:
                    _iterator4 = _createForOfIteratorHelper2(target);
                    _context14.prev = 3;
                    _iterator4.s();
                  case 5:
                    if ((_step4 = _iterator4.n()).done) {
                      _context14.next = 13;
                      break;
                    }
                    object = _step4.value;
                    _context14.next = 9;
                    return localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);
                  case 9:
                    _context14.next = 11;
                    return localDatastore._updateObjectIfPinned(object);
                  case 11:
                    _context14.next = 5;
                    break;
                  case 13:
                    _context14.next = 18;
                    break;
                  case 15:
                    _context14.prev = 15;
                    _context14.t0 = _context14["catch"](3);
                    _iterator4.e(_context14.t0);
                  case 18:
                    _context14.prev = 18;
                    _iterator4.f();
                    return _context14.finish(18);
                  case 21:
                    return _context14.abrupt("return", _promise2.default.resolve(target));
                  case 22:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee11, null, [[3, 15, 18, 21]]);
          })));
        });
      } else if (target instanceof ParseObject2) {
        if (allowCustomObjectId && !target.id) {
          throw new _ParseError2.default(_ParseError2.default.MISSING_OBJECT_ID, "objectId must not be empty, null or undefined");
        }
        target._getId();
        var localId = target._localId;
        var targetCopy = target;
        var task2 = function() {
          var params = targetCopy._getSaveParams();
          return RESTController2.request(params.method, params.path, params.body, options).then(function(response) {
            var status = response._status;
            delete response._status;
            targetCopy._handleSaveResponse(response, status);
          }, function(error) {
            targetCopy._handleSaveError();
            return _promise2.default.reject(error);
          });
        };
        stateController.pushPendingState(target._getStateIdentifier());
        return stateController.enqueueTask(target._getStateIdentifier(), task2).then(/* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee12() {
          return _regenerator2.default.wrap(function(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  _context15.next = 2;
                  return localDatastore._updateLocalIdForObject(localId, target);
                case 2:
                  _context15.next = 4;
                  return localDatastore._updateObjectIfPinned(target);
                case 4:
                  return _context15.abrupt("return", target);
                case 5:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee12);
        })), function(error) {
          return _promise2.default.reject(error);
        });
      }
      return _promise2.default.resolve();
    }
  };
  _CoreManager2.default.setObjectController(DefaultController);
  var _default = ParseObject2;
  exports.default = _default;
})(ParseObject);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _get2 = _interopRequireDefault2(get$7.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _ParseACL = _interopRequireDefault2(ParseACL);
  var _ParseError2 = _interopRequireDefault2(ParseError$1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var ParseRole2 = /* @__PURE__ */ function(_ParseObject3) {
    (0, _inherits2.default)(ParseRole3, _ParseObject3);
    var _super = _createSuper(ParseRole3);
    function ParseRole3(name, acl) {
      var _this;
      (0, _classCallCheck22.default)(this, ParseRole3);
      _this = _super.call(this, "_Role");
      if (typeof name === "string" && acl instanceof _ParseACL.default) {
        _this.setName(name);
        _this.setACL(acl);
      }
      return _this;
    }
    (0, _createClass22.default)(ParseRole3, [{
      key: "getName",
      value: function() {
        var name = this.get("name");
        if (name == null || typeof name === "string") {
          return name;
        }
        return "";
      }
    }, {
      key: "setName",
      value: function(name, options) {
        return this.set("name", name, options);
      }
    }, {
      key: "getUsers",
      value: function() {
        return this.relation("users");
      }
    }, {
      key: "getRoles",
      value: function() {
        return this.relation("roles");
      }
    }, {
      key: "validate",
      value: function(attrs, options) {
        var isInvalid = (0, _get2.default)((0, _getPrototypeOf2.default)(ParseRole3.prototype), "validate", this).call(this, attrs, options);
        if (isInvalid) {
          return isInvalid;
        }
        if ("name" in attrs && attrs.name !== this.getName()) {
          var newName = attrs.name;
          if (this.id && this.id !== attrs.objectId) {
            return new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "A role's name can only be set before it has been saved.");
          }
          if (typeof newName !== "string") {
            return new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "A role's name must be a String.");
          }
          if (!/^[0-9a-zA-Z\-_ ]+$/.test(newName)) {
            return new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "A role's name can be only contain alphanumeric characters, _, -, and spaces.");
          }
        }
        return false;
      }
    }]);
    return ParseRole3;
  }(_ParseObject2.default);
  _ParseObject2.default.registerSubclass("_Role", ParseRole2);
  var _default = ParseRole2;
  exports.default = _default;
})(ParseRole);
var ParseUser = {};
var isRevocableSession = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = isRevocableSession2;
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  function isRevocableSession2(token) {
    return (0, _indexOf2.default)(token).call(token, "r:") > -1;
  }
})(isRevocableSession);
var ParseSession = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _promise2 = _interopRequireDefault2(promise$3);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _isRevocableSession = _interopRequireDefault2(isRevocableSession);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseUser = _interopRequireDefault2(ParseUser);
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var ParseSession2 = /* @__PURE__ */ function(_ParseObject3) {
    (0, _inherits2.default)(ParseSession3, _ParseObject3);
    var _super = _createSuper(ParseSession3);
    function ParseSession3(attributes) {
      var _this;
      (0, _classCallCheck22.default)(this, ParseSession3);
      _this = _super.call(this, "_Session");
      if (attributes && (0, _typeof22.default)(attributes) === "object") {
        if (!_this.set(attributes || {})) {
          throw new Error("Can't create an invalid Session");
        }
      }
      return _this;
    }
    (0, _createClass22.default)(ParseSession3, [{
      key: "getSessionToken",
      value: function() {
        var token = this.get("sessionToken");
        if (typeof token === "string") {
          return token;
        }
        return "";
      }
    }], [{
      key: "readOnlyAttributes",
      value: function() {
        return ["createdWith", "expiresAt", "installationId", "restricted", "sessionToken", "user"];
      }
    }, {
      key: "current",
      value: function(options) {
        options = options || {};
        var controller = _CoreManager2.default.getSessionController();
        var sessionOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          sessionOptions.useMasterKey = options.useMasterKey;
        }
        return _ParseUser.default.currentAsync().then(function(user) {
          if (!user) {
            return _promise2.default.reject("There is no current user.");
          }
          sessionOptions.sessionToken = user.getSessionToken();
          return controller.getSession(sessionOptions);
        });
      }
    }, {
      key: "isCurrentSessionRevocable",
      value: function() {
        var currentUser = _ParseUser.default.current();
        if (currentUser) {
          return (0, _isRevocableSession.default)(currentUser.getSessionToken() || "");
        }
        return false;
      }
    }]);
    return ParseSession3;
  }(_ParseObject2.default);
  _ParseObject2.default.registerSubclass("_Session", ParseSession2);
  var DefaultController = {
    getSession: function(options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      var session = new ParseSession2();
      return RESTController2.request("GET", "sessions/me", {}, options).then(function(sessionData) {
        session._finishFetch(sessionData);
        session._setExisted(true);
        return session;
      });
    }
  };
  _CoreManager2.default.setSessionController(DefaultController);
  var _default = ParseSession2;
  exports.default = _default;
})(ParseSession);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _stringify2 = _interopRequireDefault2(stringify2);
  var _defineProperty = _interopRequireDefault2(defineProperty$a);
  var _regenerator2 = _interopRequireDefault2(regenerator);
  var _asyncToGenerator22 = _interopRequireDefault2(asyncToGenerator.exports);
  var _promise2 = _interopRequireDefault2(promise$3);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _get2 = _interopRequireDefault2(get$7.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _isRevocableSession = _interopRequireDefault2(isRevocableSession);
  var _ParseError2 = _interopRequireDefault2(ParseError$1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseSession = _interopRequireDefault2(ParseSession);
  var _Storage2 = _interopRequireDefault2(Storage_1);
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var CURRENT_USER_KEY = "currentUser";
  var canUseCurrentUser = !_CoreManager2.default.get("IS_NODE");
  var currentUserCacheMatchesDisk = false;
  var currentUserCache = null;
  var authProviders = {};
  var ParseUser2 = /* @__PURE__ */ function(_ParseObject3) {
    (0, _inherits2.default)(ParseUser3, _ParseObject3);
    var _super = _createSuper(ParseUser3);
    function ParseUser3(attributes) {
      var _this;
      (0, _classCallCheck22.default)(this, ParseUser3);
      _this = _super.call(this, "_User");
      if (attributes && (0, _typeof22.default)(attributes) === "object") {
        if (!_this.set(attributes || {})) {
          throw new Error("Can't create an invalid Parse User");
        }
      }
      return _this;
    }
    (0, _createClass22.default)(ParseUser3, [{
      key: "_upgradeToRevocableSession",
      value: function(options) {
        options = options || {};
        var upgradeOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          upgradeOptions.useMasterKey = options.useMasterKey;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.upgradeToRevocableSession(this, upgradeOptions);
      }
    }, {
      key: "linkWith",
      value: function(provider, options) {
        var _this2 = this;
        var saveOpts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || "";
        var authType;
        if (typeof provider === "string") {
          authType = provider;
          if (authProviders[provider]) {
            provider = authProviders[provider];
          } else {
            var authProvider = {
              restoreAuthentication: function() {
                return true;
              },
              getAuthType: function() {
                return authType;
              }
            };
            authProviders[authProvider.getAuthType()] = authProvider;
            provider = authProvider;
          }
        } else {
          authType = provider.getAuthType();
        }
        if (options && options.hasOwnProperty("authData")) {
          var authData = this.get("authData") || {};
          if ((0, _typeof22.default)(authData) !== "object") {
            throw new Error("Invalid type: authData field should be an object");
          }
          authData[authType] = options.authData;
          var controller = _CoreManager2.default.getUserController();
          return controller.linkWith(this, authData, saveOpts);
        } else {
          return new _promise2.default(function(resolve3, reject2) {
            provider.authenticate({
              success: function(provider2, result) {
                var opts = {};
                opts.authData = result;
                _this2.linkWith(provider2, opts, saveOpts).then(function() {
                  resolve3(_this2);
                }, function(error) {
                  reject2(error);
                });
              },
              error: function(provider2, _error) {
                reject2(_error);
              }
            });
          });
        }
      }
    }, {
      key: "_linkWith",
      value: function(provider, options) {
        var saveOpts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.linkWith(provider, options, saveOpts);
      }
    }, {
      key: "_synchronizeAuthData",
      value: function(provider) {
        if (!this.isCurrent() || !provider) {
          return;
        }
        var authType;
        if (typeof provider === "string") {
          authType = provider;
          provider = authProviders[authType];
        } else {
          authType = provider.getAuthType();
        }
        var authData = this.get("authData");
        if (!provider || !authData || (0, _typeof22.default)(authData) !== "object") {
          return;
        }
        var success = provider.restoreAuthentication(authData[authType]);
        if (!success) {
          this._unlinkFrom(provider);
        }
      }
    }, {
      key: "_synchronizeAllAuthData",
      value: function() {
        var authData = this.get("authData");
        if ((0, _typeof22.default)(authData) !== "object") {
          return;
        }
        for (var _key in authData) {
          this._synchronizeAuthData(_key);
        }
      }
    }, {
      key: "_cleanupAuthData",
      value: function() {
        if (!this.isCurrent()) {
          return;
        }
        var authData = this.get("authData");
        if ((0, _typeof22.default)(authData) !== "object") {
          return;
        }
        for (var _key2 in authData) {
          if (!authData[_key2]) {
            delete authData[_key2];
          }
        }
      }
    }, {
      key: "_unlinkFrom",
      value: function(provider, options) {
        var _this3 = this;
        return this.linkWith(provider, {
          authData: null
        }, options).then(function() {
          _this3._synchronizeAuthData(provider);
          return _promise2.default.resolve(_this3);
        });
      }
    }, {
      key: "_isLinked",
      value: function(provider) {
        var authType;
        if (typeof provider === "string") {
          authType = provider;
        } else {
          authType = provider.getAuthType();
        }
        var authData = this.get("authData") || {};
        if ((0, _typeof22.default)(authData) !== "object") {
          return false;
        }
        return !!authData[authType];
      }
    }, {
      key: "_logOutWithAll",
      value: function() {
        var authData = this.get("authData");
        if ((0, _typeof22.default)(authData) !== "object") {
          return;
        }
        for (var _key3 in authData) {
          this._logOutWith(_key3);
        }
      }
    }, {
      key: "_logOutWith",
      value: function(provider) {
        if (!this.isCurrent()) {
          return;
        }
        if (typeof provider === "string") {
          provider = authProviders[provider];
        }
        if (provider && provider.deauthenticate) {
          provider.deauthenticate();
        }
      }
    }, {
      key: "_preserveFieldsOnFetch",
      value: function() {
        return {
          sessionToken: this.get("sessionToken")
        };
      }
    }, {
      key: "isCurrent",
      value: function() {
        var current = ParseUser3.current();
        return !!current && current.id === this.id;
      }
    }, {
      key: "isCurrentAsync",
      value: function() {
        var _isCurrentAsync = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee() {
          var current;
          return _regenerator2.default.wrap(function(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return ParseUser3.currentAsync();
                case 2:
                  current = _context.sent;
                  return _context.abrupt("return", !!current && current.id === this.id);
                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        return function() {
          return _isCurrentAsync.apply(this, arguments);
        };
      }()
    }, {
      key: "getUsername",
      value: function() {
        var username = this.get("username");
        if (username == null || typeof username === "string") {
          return username;
        }
        return "";
      }
    }, {
      key: "setUsername",
      value: function(username) {
        var authData = this.get("authData");
        if (authData && (0, _typeof22.default)(authData) === "object" && authData.hasOwnProperty("anonymous")) {
          authData.anonymous = null;
        }
        this.set("username", username);
      }
    }, {
      key: "setPassword",
      value: function(password) {
        this.set("password", password);
      }
    }, {
      key: "getEmail",
      value: function() {
        var email = this.get("email");
        if (email == null || typeof email === "string") {
          return email;
        }
        return "";
      }
    }, {
      key: "setEmail",
      value: function(email) {
        return this.set("email", email);
      }
    }, {
      key: "getSessionToken",
      value: function() {
        var token = this.get("sessionToken");
        if (token == null || typeof token === "string") {
          return token;
        }
        return "";
      }
    }, {
      key: "authenticated",
      value: function() {
        var current = ParseUser3.current();
        return !!this.get("sessionToken") && !!current && current.id === this.id;
      }
    }, {
      key: "signUp",
      value: function(attrs, options) {
        options = options || {};
        var signupOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          signupOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("installationId")) {
          signupOptions.installationId = options.installationId;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.signUp(this, attrs, signupOptions);
      }
    }, {
      key: "logIn",
      value: function(options) {
        options = options || {};
        var loginOptions = {
          usePost: true
        };
        if (options.hasOwnProperty("useMasterKey")) {
          loginOptions.useMasterKey = options.useMasterKey;
        }
        if (options.hasOwnProperty("installationId")) {
          loginOptions.installationId = options.installationId;
        }
        if (options.hasOwnProperty("usePost")) {
          loginOptions.usePost = options.usePost;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.logIn(this, loginOptions);
      }
    }, {
      key: "save",
      value: function() {
        var _save = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee2() {
          var _len, args, _key4, current, _args2 = arguments;
          return _regenerator2.default.wrap(function(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  for (_len = _args2.length, args = new Array(_len), _key4 = 0; _key4 < _len; _key4++) {
                    args[_key4] = _args2[_key4];
                  }
                  _context2.next = 3;
                  return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser3.prototype), "save", this).apply(this, args);
                case 3:
                  _context2.next = 5;
                  return this.isCurrentAsync();
                case 5:
                  current = _context2.sent;
                  if (!current) {
                    _context2.next = 8;
                    break;
                  }
                  return _context2.abrupt("return", _CoreManager2.default.getUserController().updateUserOnDisk(this));
                case 8:
                  return _context2.abrupt("return", this);
                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        return function() {
          return _save.apply(this, arguments);
        };
      }()
    }, {
      key: "destroy",
      value: function() {
        var _destroy = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee3() {
          var _len2, args, _key5, current, _args3 = arguments;
          return _regenerator2.default.wrap(function(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  for (_len2 = _args3.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {
                    args[_key5] = _args3[_key5];
                  }
                  _context3.next = 3;
                  return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser3.prototype), "destroy", this).apply(this, args);
                case 3:
                  _context3.next = 5;
                  return this.isCurrentAsync();
                case 5:
                  current = _context3.sent;
                  if (!current) {
                    _context3.next = 8;
                    break;
                  }
                  return _context3.abrupt("return", _CoreManager2.default.getUserController().removeUserFromDisk());
                case 8:
                  return _context3.abrupt("return", this);
                case 9:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));
        return function() {
          return _destroy.apply(this, arguments);
        };
      }()
    }, {
      key: "fetch",
      value: function() {
        var _fetch = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee4() {
          var _len3, args, _key6, current, _args4 = arguments;
          return _regenerator2.default.wrap(function(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  for (_len3 = _args4.length, args = new Array(_len3), _key6 = 0; _key6 < _len3; _key6++) {
                    args[_key6] = _args4[_key6];
                  }
                  _context4.next = 3;
                  return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser3.prototype), "fetch", this).apply(this, args);
                case 3:
                  _context4.next = 5;
                  return this.isCurrentAsync();
                case 5:
                  current = _context4.sent;
                  if (!current) {
                    _context4.next = 8;
                    break;
                  }
                  return _context4.abrupt("return", _CoreManager2.default.getUserController().updateUserOnDisk(this));
                case 8:
                  return _context4.abrupt("return", this);
                case 9:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));
        return function() {
          return _fetch.apply(this, arguments);
        };
      }()
    }, {
      key: "fetchWithInclude",
      value: function() {
        var _fetchWithInclude = (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee5() {
          var _len4, args, _key7, current, _args5 = arguments;
          return _regenerator2.default.wrap(function(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  for (_len4 = _args5.length, args = new Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {
                    args[_key7] = _args5[_key7];
                  }
                  _context5.next = 3;
                  return (0, _get2.default)((0, _getPrototypeOf2.default)(ParseUser3.prototype), "fetchWithInclude", this).apply(this, args);
                case 3:
                  _context5.next = 5;
                  return this.isCurrentAsync();
                case 5:
                  current = _context5.sent;
                  if (!current) {
                    _context5.next = 8;
                    break;
                  }
                  return _context5.abrupt("return", _CoreManager2.default.getUserController().updateUserOnDisk(this));
                case 8:
                  return _context5.abrupt("return", this);
                case 9:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));
        return function() {
          return _fetchWithInclude.apply(this, arguments);
        };
      }()
    }, {
      key: "verifyPassword",
      value: function(password, options) {
        var username = this.getUsername() || "";
        return ParseUser3.verifyPassword(username, password, options);
      }
    }], [{
      key: "readOnlyAttributes",
      value: function() {
        return ["sessionToken"];
      }
    }, {
      key: "extend",
      value: function(protoProps, classProps) {
        if (protoProps) {
          for (var _prop in protoProps) {
            if (_prop !== "className") {
              (0, _defineProperty.default)(ParseUser3.prototype, _prop, {
                value: protoProps[_prop],
                enumerable: false,
                writable: true,
                configurable: true
              });
            }
          }
        }
        if (classProps) {
          for (var _prop2 in classProps) {
            if (_prop2 !== "className") {
              (0, _defineProperty.default)(ParseUser3, _prop2, {
                value: classProps[_prop2],
                enumerable: false,
                writable: true,
                configurable: true
              });
            }
          }
        }
        return ParseUser3;
      }
    }, {
      key: "current",
      value: function() {
        if (!canUseCurrentUser) {
          return null;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.currentUser();
      }
    }, {
      key: "currentAsync",
      value: function() {
        if (!canUseCurrentUser) {
          return _promise2.default.resolve(null);
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.currentUserAsync();
      }
    }, {
      key: "signUp",
      value: function(username, password, attrs, options) {
        attrs = attrs || {};
        attrs.username = username;
        attrs.password = password;
        var user = new this(attrs);
        return user.signUp({}, options);
      }
    }, {
      key: "logIn",
      value: function(username, password, options) {
        if (typeof username !== "string") {
          return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Username must be a string."));
        } else if (typeof password !== "string") {
          return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Password must be a string."));
        }
        var user = new this();
        user._finishFetch({
          username,
          password
        });
        return user.logIn(options);
      }
    }, {
      key: "become",
      value: function(sessionToken, options) {
        if (!canUseCurrentUser) {
          throw new Error("It is not memory-safe to become a user in a server environment");
        }
        options = options || {};
        var becomeOptions = {
          sessionToken
        };
        if (options.hasOwnProperty("useMasterKey")) {
          becomeOptions.useMasterKey = options.useMasterKey;
        }
        var controller = _CoreManager2.default.getUserController();
        var user = new this();
        return controller.become(user, becomeOptions);
      }
    }, {
      key: "me",
      value: function(sessionToken) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var controller = _CoreManager2.default.getUserController();
        var meOptions = {
          sessionToken
        };
        if (options.useMasterKey) {
          meOptions.useMasterKey = options.useMasterKey;
        }
        var user = new this();
        return controller.me(user, meOptions);
      }
    }, {
      key: "hydrate",
      value: function(userJSON) {
        var controller = _CoreManager2.default.getUserController();
        var user = new this();
        return controller.hydrate(user, userJSON);
      }
    }, {
      key: "logInWith",
      value: function(provider, options, saveOpts) {
        var user = new this();
        return user.linkWith(provider, options, saveOpts);
      }
    }, {
      key: "logOut",
      value: function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var controller = _CoreManager2.default.getUserController();
        return controller.logOut(options);
      }
    }, {
      key: "requestPasswordReset",
      value: function(email, options) {
        options = options || {};
        var requestOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          requestOptions.useMasterKey = options.useMasterKey;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.requestPasswordReset(email, requestOptions);
      }
    }, {
      key: "requestEmailVerification",
      value: function(email, options) {
        options = options || {};
        var requestOptions = {};
        if (options.hasOwnProperty("useMasterKey")) {
          requestOptions.useMasterKey = options.useMasterKey;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.requestEmailVerification(email, requestOptions);
      }
    }, {
      key: "verifyPassword",
      value: function(username, password, options) {
        if (typeof username !== "string") {
          return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Username must be a string."));
        }
        if (typeof password !== "string") {
          return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Password must be a string."));
        }
        options = options || {};
        var verificationOption = {};
        if (options.hasOwnProperty("useMasterKey")) {
          verificationOption.useMasterKey = options.useMasterKey;
        }
        var controller = _CoreManager2.default.getUserController();
        return controller.verifyPassword(username, password, verificationOption);
      }
    }, {
      key: "allowCustomUserClass",
      value: function(isAllowed) {
        _CoreManager2.default.set("PERFORM_USER_REWRITE", !isAllowed);
      }
    }, {
      key: "enableRevocableSession",
      value: function(options) {
        options = options || {};
        _CoreManager2.default.set("FORCE_REVOCABLE_SESSION", true);
        if (canUseCurrentUser) {
          var current = ParseUser3.current();
          if (current) {
            return current._upgradeToRevocableSession(options);
          }
        }
        return _promise2.default.resolve();
      }
    }, {
      key: "enableUnsafeCurrentUser",
      value: function() {
        canUseCurrentUser = true;
      }
    }, {
      key: "disableUnsafeCurrentUser",
      value: function() {
        canUseCurrentUser = false;
      }
    }, {
      key: "_registerAuthenticationProvider",
      value: function(provider) {
        authProviders[provider.getAuthType()] = provider;
        ParseUser3.currentAsync().then(function(current) {
          if (current) {
            current._synchronizeAuthData(provider.getAuthType());
          }
        });
      }
    }, {
      key: "_logInWith",
      value: function(provider, options, saveOpts) {
        var user = new this();
        return user.linkWith(provider, options, saveOpts);
      }
    }, {
      key: "_clearCache",
      value: function() {
        currentUserCache = null;
        currentUserCacheMatchesDisk = false;
      }
    }, {
      key: "_setCurrentUserCache",
      value: function(user) {
        currentUserCache = user;
      }
    }]);
    return ParseUser3;
  }(_ParseObject2.default);
  _ParseObject2.default.registerSubclass("_User", ParseUser2);
  var DefaultController = {
    updateUserOnDisk: function(user) {
      var path2 = _Storage2.default.generatePath(CURRENT_USER_KEY);
      var json = user.toJSON();
      delete json.password;
      json.className = "_User";
      var userData = (0, _stringify2.default)(json);
      if (_CoreManager2.default.get("ENCRYPTED_USER")) {
        var crypto2 = _CoreManager2.default.getCryptoController();
        userData = crypto2.encrypt(json, _CoreManager2.default.get("ENCRYPTED_KEY"));
      }
      return _Storage2.default.setItemAsync(path2, userData).then(function() {
        return user;
      });
    },
    removeUserFromDisk: function() {
      var path2 = _Storage2.default.generatePath(CURRENT_USER_KEY);
      currentUserCacheMatchesDisk = true;
      currentUserCache = null;
      return _Storage2.default.removeItemAsync(path2);
    },
    setCurrentUser: function(user) {
      currentUserCache = user;
      user._cleanupAuthData();
      user._synchronizeAllAuthData();
      return DefaultController.updateUserOnDisk(user);
    },
    currentUser: function() {
      if (currentUserCache) {
        return currentUserCache;
      }
      if (currentUserCacheMatchesDisk) {
        return null;
      }
      if (_Storage2.default.async()) {
        throw new Error("Cannot call currentUser() when using a platform with an async storage system. Call currentUserAsync() instead.");
      }
      var path2 = _Storage2.default.generatePath(CURRENT_USER_KEY);
      var userData = _Storage2.default.getItem(path2);
      currentUserCacheMatchesDisk = true;
      if (!userData) {
        currentUserCache = null;
        return null;
      }
      if (_CoreManager2.default.get("ENCRYPTED_USER")) {
        var crypto2 = _CoreManager2.default.getCryptoController();
        userData = crypto2.decrypt(userData, _CoreManager2.default.get("ENCRYPTED_KEY"));
      }
      userData = JSON.parse(userData);
      if (!userData.className) {
        userData.className = "_User";
      }
      if (userData._id) {
        if (userData.objectId !== userData._id) {
          userData.objectId = userData._id;
        }
        delete userData._id;
      }
      if (userData._sessionToken) {
        userData.sessionToken = userData._sessionToken;
        delete userData._sessionToken;
      }
      var current = _ParseObject2.default.fromJSON(userData);
      currentUserCache = current;
      current._synchronizeAllAuthData();
      return current;
    },
    currentUserAsync: function() {
      if (currentUserCache) {
        return _promise2.default.resolve(currentUserCache);
      }
      if (currentUserCacheMatchesDisk) {
        return _promise2.default.resolve(null);
      }
      var path2 = _Storage2.default.generatePath(CURRENT_USER_KEY);
      return _Storage2.default.getItemAsync(path2).then(function(userData) {
        currentUserCacheMatchesDisk = true;
        if (!userData) {
          currentUserCache = null;
          return _promise2.default.resolve(null);
        }
        if (_CoreManager2.default.get("ENCRYPTED_USER")) {
          var crypto2 = _CoreManager2.default.getCryptoController();
          userData = crypto2.decrypt(userData.toString(), _CoreManager2.default.get("ENCRYPTED_KEY"));
        }
        userData = JSON.parse(userData);
        if (!userData.className) {
          userData.className = "_User";
        }
        if (userData._id) {
          if (userData.objectId !== userData._id) {
            userData.objectId = userData._id;
          }
          delete userData._id;
        }
        if (userData._sessionToken) {
          userData.sessionToken = userData._sessionToken;
          delete userData._sessionToken;
        }
        var current = _ParseObject2.default.fromJSON(userData);
        currentUserCache = current;
        current._synchronizeAllAuthData();
        return _promise2.default.resolve(current);
      });
    },
    signUp: function(user, attrs, options) {
      var username = attrs && attrs.username || user.get("username");
      var password = attrs && attrs.password || user.get("password");
      if (!username || !username.length) {
        return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Cannot sign up user with an empty username."));
      }
      if (!password || !password.length) {
        return _promise2.default.reject(new _ParseError2.default(_ParseError2.default.OTHER_CAUSE, "Cannot sign up user with an empty password."));
      }
      return user.save(attrs, options).then(function() {
        user._finishFetch({
          password: void 0
        });
        if (canUseCurrentUser) {
          return DefaultController.setCurrentUser(user);
        }
        return user;
      });
    },
    logIn: function(user, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      var stateController = _CoreManager2.default.getObjectStateController();
      var auth = {
        username: user.get("username"),
        password: user.get("password")
      };
      return RESTController2.request(options.usePost ? "POST" : "GET", "login", auth, options).then(function(response) {
        user._migrateId(response.objectId);
        user._setExisted(true);
        stateController.setPendingOp(user._getStateIdentifier(), "username", void 0);
        stateController.setPendingOp(user._getStateIdentifier(), "password", void 0);
        response.password = void 0;
        user._finishFetch(response);
        if (!canUseCurrentUser) {
          return _promise2.default.resolve(user);
        }
        return DefaultController.setCurrentUser(user);
      });
    },
    become: function(user, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "users/me", {}, options).then(function(response) {
        user._finishFetch(response);
        user._setExisted(true);
        return DefaultController.setCurrentUser(user);
      });
    },
    hydrate: function(user, userJSON) {
      user._finishFetch(userJSON);
      user._setExisted(true);
      if (userJSON.sessionToken && canUseCurrentUser) {
        return DefaultController.setCurrentUser(user);
      } else {
        return _promise2.default.resolve(user);
      }
    },
    me: function(user, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "users/me", {}, options).then(function(response) {
        user._finishFetch(response);
        user._setExisted(true);
        return user;
      });
    },
    logOut: function(options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      if (options.sessionToken) {
        return RESTController2.request("POST", "logout", {}, options);
      }
      return DefaultController.currentUserAsync().then(function(currentUser) {
        var path2 = _Storage2.default.generatePath(CURRENT_USER_KEY);
        var promise2 = _Storage2.default.removeItemAsync(path2);
        if (currentUser !== null) {
          var currentSession = currentUser.getSessionToken();
          if (currentSession && (0, _isRevocableSession.default)(currentSession)) {
            promise2 = promise2.then(function() {
              return RESTController2.request("POST", "logout", {}, {
                sessionToken: currentSession
              });
            });
          }
          currentUser._logOutWithAll();
          currentUser._finishFetch({
            sessionToken: void 0
          });
        }
        currentUserCacheMatchesDisk = true;
        currentUserCache = null;
        return promise2;
      });
    },
    requestPasswordReset: function(email, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("POST", "requestPasswordReset", {
        email
      }, options);
    },
    upgradeToRevocableSession: function(user, options) {
      return (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee6() {
        var token, RESTController2, result, session, current;
        return _regenerator2.default.wrap(function(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                token = user.getSessionToken();
                if (token) {
                  _context6.next = 3;
                  break;
                }
                return _context6.abrupt("return", _promise2.default.reject(new _ParseError2.default(_ParseError2.default.SESSION_MISSING, "Cannot upgrade a user with no session token")));
              case 3:
                options.sessionToken = token;
                RESTController2 = _CoreManager2.default.getRESTController();
                _context6.next = 7;
                return RESTController2.request("POST", "upgradeToRevocableSession", {}, options);
              case 7:
                result = _context6.sent;
                session = new _ParseSession.default();
                session._finishFetch(result);
                user._finishFetch({
                  sessionToken: session.getSessionToken()
                });
                _context6.next = 13;
                return user.isCurrentAsync();
              case 13:
                current = _context6.sent;
                if (!current) {
                  _context6.next = 16;
                  break;
                }
                return _context6.abrupt("return", DefaultController.setCurrentUser(user));
              case 16:
                return _context6.abrupt("return", _promise2.default.resolve(user));
              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }))();
    },
    linkWith: function(user, authData, options) {
      return user.save({
        authData
      }, options).then(function() {
        if (canUseCurrentUser) {
          return DefaultController.setCurrentUser(user);
        }
        return user;
      });
    },
    verifyPassword: function(username, password, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "verifyPassword", {
        username,
        password
      }, options);
    },
    requestEmailVerification: function(email, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("POST", "verificationEmailRequest", {
        email
      }, options);
    }
  };
  _CoreManager2.default.setUserController(DefaultController);
  var _default = ParseUser2;
  exports.default = _default;
})(ParseUser);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _keys4 = _interopRequireDefault2(keys$5);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _ParseRole = _interopRequireDefault2(ParseRole);
  var _ParseUser = _interopRequireDefault2(ParseUser);
  var PUBLIC_KEY = "*";
  var ParseACL2 = /* @__PURE__ */ function() {
    function ParseACL3(arg1) {
      (0, _classCallCheck22.default)(this, ParseACL3);
      (0, _defineProperty22.default)(this, "permissionsById", void 0);
      this.permissionsById = {};
      if (arg1 && (0, _typeof22.default)(arg1) === "object") {
        if (arg1 instanceof _ParseUser.default) {
          this.setReadAccess(arg1, true);
          this.setWriteAccess(arg1, true);
        } else {
          for (var _userId in arg1) {
            var accessList = arg1[_userId];
            this.permissionsById[_userId] = {};
            for (var _permission in accessList) {
              var allowed = accessList[_permission];
              if (_permission !== "read" && _permission !== "write") {
                throw new TypeError("Tried to create an ACL with an invalid permission type.");
              }
              if (typeof allowed !== "boolean") {
                throw new TypeError("Tried to create an ACL with an invalid permission value.");
              }
              this.permissionsById[_userId][_permission] = allowed;
            }
          }
        }
      } else if (typeof arg1 === "function") {
        throw new TypeError("ParseACL constructed with a function. Did you forget ()?");
      }
    }
    (0, _createClass22.default)(ParseACL3, [{
      key: "toJSON",
      value: function() {
        var permissions = {};
        for (var p2 in this.permissionsById) {
          permissions[p2] = this.permissionsById[p2];
        }
        return permissions;
      }
    }, {
      key: "equals",
      value: function(other) {
        if (!(other instanceof ParseACL3)) {
          return false;
        }
        var users = (0, _keys4.default)(this.permissionsById);
        var otherUsers = (0, _keys4.default)(other.permissionsById);
        if (users.length !== otherUsers.length) {
          return false;
        }
        for (var u2 in this.permissionsById) {
          if (!other.permissionsById[u2]) {
            return false;
          }
          if (this.permissionsById[u2].read !== other.permissionsById[u2].read) {
            return false;
          }
          if (this.permissionsById[u2].write !== other.permissionsById[u2].write) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "_setAccess",
      value: function(accessType, userId, allowed) {
        if (userId instanceof _ParseUser.default) {
          userId = userId.id;
        } else if (userId instanceof _ParseRole.default) {
          var name = userId.getName();
          if (!name) {
            throw new TypeError("Role must have a name");
          }
          userId = "role:" + name;
        }
        if (typeof userId !== "string") {
          throw new TypeError("userId must be a string.");
        }
        if (typeof allowed !== "boolean") {
          throw new TypeError("allowed must be either true or false.");
        }
        var permissions = this.permissionsById[userId];
        if (!permissions) {
          if (!allowed) {
            return;
          } else {
            permissions = {};
            this.permissionsById[userId] = permissions;
          }
        }
        if (allowed) {
          this.permissionsById[userId][accessType] = true;
        } else {
          delete permissions[accessType];
          if ((0, _keys4.default)(permissions).length === 0) {
            delete this.permissionsById[userId];
          }
        }
      }
    }, {
      key: "_getAccess",
      value: function(accessType, userId) {
        if (userId instanceof _ParseUser.default) {
          userId = userId.id;
          if (!userId) {
            throw new Error("Cannot get access for a ParseUser without an ID");
          }
        } else if (userId instanceof _ParseRole.default) {
          var name = userId.getName();
          if (!name) {
            throw new TypeError("Role must have a name");
          }
          userId = "role:" + name;
        }
        var permissions = this.permissionsById[userId];
        if (!permissions) {
          return false;
        }
        return !!permissions[accessType];
      }
    }, {
      key: "setReadAccess",
      value: function(userId, allowed) {
        this._setAccess("read", userId, allowed);
      }
    }, {
      key: "getReadAccess",
      value: function(userId) {
        return this._getAccess("read", userId);
      }
    }, {
      key: "setWriteAccess",
      value: function(userId, allowed) {
        this._setAccess("write", userId, allowed);
      }
    }, {
      key: "getWriteAccess",
      value: function(userId) {
        return this._getAccess("write", userId);
      }
    }, {
      key: "setPublicReadAccess",
      value: function(allowed) {
        this.setReadAccess(PUBLIC_KEY, allowed);
      }
    }, {
      key: "getPublicReadAccess",
      value: function() {
        return this.getReadAccess(PUBLIC_KEY);
      }
    }, {
      key: "setPublicWriteAccess",
      value: function(allowed) {
        this.setWriteAccess(PUBLIC_KEY, allowed);
      }
    }, {
      key: "getPublicWriteAccess",
      value: function() {
        return this.getWriteAccess(PUBLIC_KEY);
      }
    }, {
      key: "getRoleReadAccess",
      value: function(role) {
        if (role instanceof _ParseRole.default) {
          role = role.getName();
        }
        if (typeof role !== "string") {
          throw new TypeError("role must be a ParseRole or a String");
        }
        return this.getReadAccess("role:" + role);
      }
    }, {
      key: "getRoleWriteAccess",
      value: function(role) {
        if (role instanceof _ParseRole.default) {
          role = role.getName();
        }
        if (typeof role !== "string") {
          throw new TypeError("role must be a ParseRole or a String");
        }
        return this.getWriteAccess("role:" + role);
      }
    }, {
      key: "setRoleReadAccess",
      value: function(role, allowed) {
        if (role instanceof _ParseRole.default) {
          role = role.getName();
        }
        if (typeof role !== "string") {
          throw new TypeError("role must be a ParseRole or a String");
        }
        this.setReadAccess("role:" + role, allowed);
      }
    }, {
      key: "setRoleWriteAccess",
      value: function(role, allowed) {
        if (role instanceof _ParseRole.default) {
          role = role.getName();
        }
        if (typeof role !== "string") {
          throw new TypeError("role must be a ParseRole or a String");
        }
        this.setWriteAccess("role:" + role, allowed);
      }
    }]);
    return ParseACL3;
  }();
  var _default = ParseACL2;
  exports.default = _default;
})(ParseACL);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = decode2;
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  _interopRequireDefault2(ParseACL);
  var _ParseFile = _interopRequireDefault2(ParseFile);
  var _ParseGeoPoint = _interopRequireDefault2(ParseGeoPoint$1);
  var _ParsePolygon = _interopRequireDefault2(ParsePolygon$1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseOp = ParseOp$1;
  var _ParseRelation = _interopRequireDefault2(ParseRelation);
  function decode2(value) {
    if (value === null || (0, _typeof22.default)(value) !== "object" || value instanceof Date) {
      return value;
    }
    if ((0, _isArray2.default)(value)) {
      var dup = [];
      (0, _forEach2.default)(value).call(value, function(v, i2) {
        dup[i2] = decode2(v);
      });
      return dup;
    }
    if (typeof value.__op === "string") {
      return (0, _ParseOp.opFromJSON)(value);
    }
    if (value.__type === "Pointer" && value.className) {
      return _ParseObject2.default.fromJSON(value);
    }
    if (value.__type === "Object" && value.className) {
      return _ParseObject2.default.fromJSON(value);
    }
    if (value.__type === "Relation") {
      var relation = new _ParseRelation.default(null, null);
      relation.targetClassName = value.className;
      return relation;
    }
    if (value.__type === "Date") {
      return new Date(value.iso);
    }
    if (value.__type === "File") {
      return _ParseFile.default.fromJSON(value);
    }
    if (value.__type === "GeoPoint") {
      return new _ParseGeoPoint.default({
        latitude: value.latitude,
        longitude: value.longitude
      });
    }
    if (value.__type === "Polygon") {
      return new _ParsePolygon.default(value.coordinates);
    }
    var copy = {};
    for (var k in value) {
      copy[k] = decode2(value[k]);
    }
    return copy;
  }
})(decode$2);
var aes = { exports: {} };
var core = { exports: {} };
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory();
    }
  })(commonjsGlobal, function() {
    var CryptoJS = CryptoJS || function(Math2, undefined$1) {
      var crypto2;
      if (typeof window !== "undefined" && window.crypto) {
        crypto2 = window.crypto;
      }
      if (typeof self !== "undefined" && self.crypto) {
        crypto2 = self.crypto;
      }
      if (typeof globalThis !== "undefined" && globalThis.crypto) {
        crypto2 = globalThis.crypto;
      }
      if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
        crypto2 = window.msCrypto;
      }
      if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
        crypto2 = commonjsGlobal.crypto;
      }
      if (!crypto2 && typeof commonjsRequire === "function") {
        try {
          crypto2 = require("crypto");
        } catch (err) {
        }
      }
      var cryptoSecureRandomInt = function() {
        if (crypto2) {
          if (typeof crypto2.getRandomValues === "function") {
            try {
              return crypto2.getRandomValues(new Uint32Array(1))[0];
            } catch (err) {
            }
          }
          if (typeof crypto2.randomBytes === "function") {
            try {
              return crypto2.randomBytes(4).readInt32LE();
            } catch (err) {
            }
          }
        }
        throw new Error("Native crypto module could not be used to get secure random number.");
      };
      var create5 = Object.create || function() {
        function F() {
        }
        return function(obj) {
          var subtype;
          F.prototype = obj;
          subtype = new F();
          F.prototype = null;
          return subtype;
        };
      }();
      var C = {};
      var C_lib = C.lib = {};
      var Base = C_lib.Base = function() {
        return {
          extend: function(overrides) {
            var subtype = create5(this);
            if (overrides) {
              subtype.mixIn(overrides);
            }
            if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
              subtype.init = function() {
                subtype.$super.init.apply(this, arguments);
              };
            }
            subtype.init.prototype = subtype;
            subtype.$super = this;
            return subtype;
          },
          create: function() {
            var instance = this.extend();
            instance.init.apply(instance, arguments);
            return instance;
          },
          init: function() {
          },
          mixIn: function(properties) {
            for (var propertyName in properties) {
              if (properties.hasOwnProperty(propertyName)) {
                this[propertyName] = properties[propertyName];
              }
            }
            if (properties.hasOwnProperty("toString")) {
              this.toString = properties.toString;
            }
          },
          clone: function() {
            return this.init.prototype.extend(this);
          }
        };
      }();
      var WordArray = C_lib.WordArray = Base.extend({
        init: function(words, sigBytes) {
          words = this.words = words || [];
          if (sigBytes != undefined$1) {
            this.sigBytes = sigBytes;
          } else {
            this.sigBytes = words.length * 4;
          }
        },
        toString: function(encoder) {
          return (encoder || Hex).stringify(this);
        },
        concat: function(wordArray) {
          var thisWords = this.words;
          var thatWords = wordArray.words;
          var thisSigBytes = this.sigBytes;
          var thatSigBytes = wordArray.sigBytes;
          this.clamp();
          if (thisSigBytes % 4) {
            for (var i2 = 0; i2 < thatSigBytes; i2++) {
              var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
            }
          } else {
            for (var j = 0; j < thatSigBytes; j += 4) {
              thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
            }
          }
          this.sigBytes += thatSigBytes;
          return this;
        },
        clamp: function() {
          var words = this.words;
          var sigBytes = this.sigBytes;
          words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
          words.length = Math2.ceil(sigBytes / 4);
        },
        clone: function() {
          var clone = Base.clone.call(this);
          clone.words = this.words.slice(0);
          return clone;
        },
        random: function(nBytes) {
          var words = [];
          for (var i2 = 0; i2 < nBytes; i2 += 4) {
            words.push(cryptoSecureRandomInt());
          }
          return new WordArray.init(words, nBytes);
        }
      });
      var C_enc = C.enc = {};
      var Hex = C_enc.Hex = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var hexChars = [];
          for (var i2 = 0; i2 < sigBytes; i2++) {
            var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
            hexChars.push((bite >>> 4).toString(16));
            hexChars.push((bite & 15).toString(16));
          }
          return hexChars.join("");
        },
        parse: function(hexStr) {
          var hexStrLength = hexStr.length;
          var words = [];
          for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
            words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
          }
          return new WordArray.init(words, hexStrLength / 2);
        }
      };
      var Latin1 = C_enc.Latin1 = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var latin1Chars = [];
          for (var i2 = 0; i2 < sigBytes; i2++) {
            var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
            latin1Chars.push(String.fromCharCode(bite));
          }
          return latin1Chars.join("");
        },
        parse: function(latin1Str) {
          var latin1StrLength = latin1Str.length;
          var words = [];
          for (var i2 = 0; i2 < latin1StrLength; i2++) {
            words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
          }
          return new WordArray.init(words, latin1StrLength);
        }
      };
      var Utf8 = C_enc.Utf8 = {
        stringify: function(wordArray) {
          try {
            return decodeURIComponent(escape(Latin1.stringify(wordArray)));
          } catch (e2) {
            throw new Error("Malformed UTF-8 data");
          }
        },
        parse: function(utf8Str) {
          return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
      };
      var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        reset: function() {
          this._data = new WordArray.init();
          this._nDataBytes = 0;
        },
        _append: function(data2) {
          if (typeof data2 == "string") {
            data2 = Utf8.parse(data2);
          }
          this._data.concat(data2);
          this._nDataBytes += data2.sigBytes;
        },
        _process: function(doFlush) {
          var processedWords;
          var data2 = this._data;
          var dataWords = data2.words;
          var dataSigBytes = data2.sigBytes;
          var blockSize = this.blockSize;
          var blockSizeBytes = blockSize * 4;
          var nBlocksReady = dataSigBytes / blockSizeBytes;
          if (doFlush) {
            nBlocksReady = Math2.ceil(nBlocksReady);
          } else {
            nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
          }
          var nWordsReady = nBlocksReady * blockSize;
          var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
          if (nWordsReady) {
            for (var offset = 0; offset < nWordsReady; offset += blockSize) {
              this._doProcessBlock(dataWords, offset);
            }
            processedWords = dataWords.splice(0, nWordsReady);
            data2.sigBytes -= nBytesReady;
          }
          return new WordArray.init(processedWords, nBytesReady);
        },
        clone: function() {
          var clone = Base.clone.call(this);
          clone._data = this._data.clone();
          return clone;
        },
        _minBufferSize: 0
      });
      C_lib.Hasher = BufferedBlockAlgorithm.extend({
        cfg: Base.extend(),
        init: function(cfg) {
          this.cfg = this.cfg.extend(cfg);
          this.reset();
        },
        reset: function() {
          BufferedBlockAlgorithm.reset.call(this);
          this._doReset();
        },
        update: function(messageUpdate) {
          this._append(messageUpdate);
          this._process();
          return this;
        },
        finalize: function(messageUpdate) {
          if (messageUpdate) {
            this._append(messageUpdate);
          }
          var hash = this._doFinalize();
          return hash;
        },
        blockSize: 512 / 32,
        _createHelper: function(hasher) {
          return function(message, cfg) {
            return new hasher.init(cfg).finalize(message);
          };
        },
        _createHmacHelper: function(hasher) {
          return function(message, key) {
            return new C_algo.HMAC.init(hasher, key).finalize(message);
          };
        }
      });
      var C_algo = C.algo = {};
      return C;
    }(Math);
    return CryptoJS;
  });
})(core);
var encBase64 = { exports: {} };
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var C_enc = C.enc;
      C_enc.Base64 = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var map3 = this._map;
          wordArray.clamp();
          var base64Chars = [];
          for (var i2 = 0; i2 < sigBytes; i2 += 3) {
            var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
            var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
            var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
            var triplet = byte1 << 16 | byte2 << 8 | byte3;
            for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
              base64Chars.push(map3.charAt(triplet >>> 6 * (3 - j) & 63));
            }
          }
          var paddingChar = map3.charAt(64);
          if (paddingChar) {
            while (base64Chars.length % 4) {
              base64Chars.push(paddingChar);
            }
          }
          return base64Chars.join("");
        },
        parse: function(base64Str) {
          var base64StrLength = base64Str.length;
          var map3 = this._map;
          var reverseMap = this._reverseMap;
          if (!reverseMap) {
            reverseMap = this._reverseMap = [];
            for (var j = 0; j < map3.length; j++) {
              reverseMap[map3.charCodeAt(j)] = j;
            }
          }
          var paddingChar = map3.charAt(64);
          if (paddingChar) {
            var paddingIndex = base64Str.indexOf(paddingChar);
            if (paddingIndex !== -1) {
              base64StrLength = paddingIndex;
            }
          }
          return parseLoop(base64Str, base64StrLength, reverseMap);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };
      function parseLoop(base64Str, base64StrLength, reverseMap) {
        var words = [];
        var nBytes = 0;
        for (var i2 = 0; i2 < base64StrLength; i2++) {
          if (i2 % 4) {
            var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
            var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
            var bitsCombined = bits1 | bits2;
            words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
            nBytes++;
          }
        }
        return WordArray.create(words, nBytes);
      }
    })();
    return CryptoJS.enc.Base64;
  });
})(encBase64);
var md5 = { exports: {} };
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(Math2) {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C.algo;
      var T = [];
      (function() {
        for (var i2 = 0; i2 < 64; i2++) {
          T[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
        }
      })();
      var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function() {
          this._hash = new WordArray.init([
            1732584193,
            4023233417,
            2562383102,
            271733878
          ]);
        },
        _doProcessBlock: function(M, offset) {
          for (var i2 = 0; i2 < 16; i2++) {
            var offset_i = offset + i2;
            var M_offset_i = M[offset_i];
            M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
          }
          var H = this._hash.words;
          var M_offset_0 = M[offset + 0];
          var M_offset_1 = M[offset + 1];
          var M_offset_2 = M[offset + 2];
          var M_offset_3 = M[offset + 3];
          var M_offset_4 = M[offset + 4];
          var M_offset_5 = M[offset + 5];
          var M_offset_6 = M[offset + 6];
          var M_offset_7 = M[offset + 7];
          var M_offset_8 = M[offset + 8];
          var M_offset_9 = M[offset + 9];
          var M_offset_10 = M[offset + 10];
          var M_offset_11 = M[offset + 11];
          var M_offset_12 = M[offset + 12];
          var M_offset_13 = M[offset + 13];
          var M_offset_14 = M[offset + 14];
          var M_offset_15 = M[offset + 15];
          var a = H[0];
          var b = H[1];
          var c = H[2];
          var d = H[3];
          a = FF2(a, b, c, d, M_offset_0, 7, T[0]);
          d = FF2(d, a, b, c, M_offset_1, 12, T[1]);
          c = FF2(c, d, a, b, M_offset_2, 17, T[2]);
          b = FF2(b, c, d, a, M_offset_3, 22, T[3]);
          a = FF2(a, b, c, d, M_offset_4, 7, T[4]);
          d = FF2(d, a, b, c, M_offset_5, 12, T[5]);
          c = FF2(c, d, a, b, M_offset_6, 17, T[6]);
          b = FF2(b, c, d, a, M_offset_7, 22, T[7]);
          a = FF2(a, b, c, d, M_offset_8, 7, T[8]);
          d = FF2(d, a, b, c, M_offset_9, 12, T[9]);
          c = FF2(c, d, a, b, M_offset_10, 17, T[10]);
          b = FF2(b, c, d, a, M_offset_11, 22, T[11]);
          a = FF2(a, b, c, d, M_offset_12, 7, T[12]);
          d = FF2(d, a, b, c, M_offset_13, 12, T[13]);
          c = FF2(c, d, a, b, M_offset_14, 17, T[14]);
          b = FF2(b, c, d, a, M_offset_15, 22, T[15]);
          a = GG(a, b, c, d, M_offset_1, 5, T[16]);
          d = GG(d, a, b, c, M_offset_6, 9, T[17]);
          c = GG(c, d, a, b, M_offset_11, 14, T[18]);
          b = GG(b, c, d, a, M_offset_0, 20, T[19]);
          a = GG(a, b, c, d, M_offset_5, 5, T[20]);
          d = GG(d, a, b, c, M_offset_10, 9, T[21]);
          c = GG(c, d, a, b, M_offset_15, 14, T[22]);
          b = GG(b, c, d, a, M_offset_4, 20, T[23]);
          a = GG(a, b, c, d, M_offset_9, 5, T[24]);
          d = GG(d, a, b, c, M_offset_14, 9, T[25]);
          c = GG(c, d, a, b, M_offset_3, 14, T[26]);
          b = GG(b, c, d, a, M_offset_8, 20, T[27]);
          a = GG(a, b, c, d, M_offset_13, 5, T[28]);
          d = GG(d, a, b, c, M_offset_2, 9, T[29]);
          c = GG(c, d, a, b, M_offset_7, 14, T[30]);
          b = GG(b, c, d, a, M_offset_12, 20, T[31]);
          a = HH(a, b, c, d, M_offset_5, 4, T[32]);
          d = HH(d, a, b, c, M_offset_8, 11, T[33]);
          c = HH(c, d, a, b, M_offset_11, 16, T[34]);
          b = HH(b, c, d, a, M_offset_14, 23, T[35]);
          a = HH(a, b, c, d, M_offset_1, 4, T[36]);
          d = HH(d, a, b, c, M_offset_4, 11, T[37]);
          c = HH(c, d, a, b, M_offset_7, 16, T[38]);
          b = HH(b, c, d, a, M_offset_10, 23, T[39]);
          a = HH(a, b, c, d, M_offset_13, 4, T[40]);
          d = HH(d, a, b, c, M_offset_0, 11, T[41]);
          c = HH(c, d, a, b, M_offset_3, 16, T[42]);
          b = HH(b, c, d, a, M_offset_6, 23, T[43]);
          a = HH(a, b, c, d, M_offset_9, 4, T[44]);
          d = HH(d, a, b, c, M_offset_12, 11, T[45]);
          c = HH(c, d, a, b, M_offset_15, 16, T[46]);
          b = HH(b, c, d, a, M_offset_2, 23, T[47]);
          a = II(a, b, c, d, M_offset_0, 6, T[48]);
          d = II(d, a, b, c, M_offset_7, 10, T[49]);
          c = II(c, d, a, b, M_offset_14, 15, T[50]);
          b = II(b, c, d, a, M_offset_5, 21, T[51]);
          a = II(a, b, c, d, M_offset_12, 6, T[52]);
          d = II(d, a, b, c, M_offset_3, 10, T[53]);
          c = II(c, d, a, b, M_offset_10, 15, T[54]);
          b = II(b, c, d, a, M_offset_1, 21, T[55]);
          a = II(a, b, c, d, M_offset_8, 6, T[56]);
          d = II(d, a, b, c, M_offset_15, 10, T[57]);
          c = II(c, d, a, b, M_offset_6, 15, T[58]);
          b = II(b, c, d, a, M_offset_13, 21, T[59]);
          a = II(a, b, c, d, M_offset_4, 6, T[60]);
          d = II(d, a, b, c, M_offset_11, 10, T[61]);
          c = II(c, d, a, b, M_offset_2, 15, T[62]);
          b = II(b, c, d, a, M_offset_9, 21, T[63]);
          H[0] = H[0] + a | 0;
          H[1] = H[1] + b | 0;
          H[2] = H[2] + c | 0;
          H[3] = H[3] + d | 0;
        },
        _doFinalize: function() {
          var data2 = this._data;
          var dataWords = data2.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data2.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
          var nBitsTotalL = nBitsTotal;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
          data2.sigBytes = (dataWords.length + 1) * 4;
          this._process();
          var hash = this._hash;
          var H = hash.words;
          for (var i2 = 0; i2 < 4; i2++) {
            var H_i = H[i2];
            H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
          }
          return hash;
        },
        clone: function() {
          var clone = Hasher.clone.call(this);
          clone._hash = this._hash.clone();
          return clone;
        }
      });
      function FF2(a, b, c, d, x, s, t2) {
        var n2 = a + (b & c | ~b & d) + x + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      }
      function GG(a, b, c, d, x, s, t2) {
        var n2 = a + (b & d | c & ~d) + x + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      }
      function HH(a, b, c, d, x, s, t2) {
        var n2 = a + (b ^ c ^ d) + x + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      }
      function II(a, b, c, d, x, s, t2) {
        var n2 = a + (c ^ (b | ~d)) + x + t2;
        return (n2 << s | n2 >>> 32 - s) + b;
      }
      C.MD5 = Hasher._createHelper(MD5);
      C.HmacMD5 = Hasher._createHmacHelper(MD5);
    })(Math);
    return CryptoJS.MD5;
  });
})(md5);
var evpkdf = { exports: {} };
var sha1 = { exports: {} };
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C.algo;
      var W = [];
      var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function() {
          this._hash = new WordArray.init([
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
          ]);
        },
        _doProcessBlock: function(M, offset) {
          var H = this._hash.words;
          var a = H[0];
          var b = H[1];
          var c = H[2];
          var d = H[3];
          var e2 = H[4];
          for (var i2 = 0; i2 < 80; i2++) {
            if (i2 < 16) {
              W[i2] = M[offset + i2] | 0;
            } else {
              var n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
              W[i2] = n2 << 1 | n2 >>> 31;
            }
            var t2 = (a << 5 | a >>> 27) + e2 + W[i2];
            if (i2 < 20) {
              t2 += (b & c | ~b & d) + 1518500249;
            } else if (i2 < 40) {
              t2 += (b ^ c ^ d) + 1859775393;
            } else if (i2 < 60) {
              t2 += (b & c | b & d | c & d) - 1894007588;
            } else {
              t2 += (b ^ c ^ d) - 899497514;
            }
            e2 = d;
            d = c;
            c = b << 30 | b >>> 2;
            b = a;
            a = t2;
          }
          H[0] = H[0] + a | 0;
          H[1] = H[1] + b | 0;
          H[2] = H[2] + c | 0;
          H[3] = H[3] + d | 0;
          H[4] = H[4] + e2 | 0;
        },
        _doFinalize: function() {
          var data2 = this._data;
          var dataWords = data2.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data2.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
          data2.sigBytes = dataWords.length * 4;
          this._process();
          return this._hash;
        },
        clone: function() {
          var clone = Hasher.clone.call(this);
          clone._hash = this._hash.clone();
          return clone;
        }
      });
      C.SHA1 = Hasher._createHelper(SHA1);
      C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
    })();
    return CryptoJS.SHA1;
  });
})(sha1);
var hmac = { exports: {} };
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var Base = C_lib.Base;
      var C_enc = C.enc;
      var Utf8 = C_enc.Utf8;
      var C_algo = C.algo;
      C_algo.HMAC = Base.extend({
        init: function(hasher, key) {
          hasher = this._hasher = new hasher.init();
          if (typeof key == "string") {
            key = Utf8.parse(key);
          }
          var hasherBlockSize = hasher.blockSize;
          var hasherBlockSizeBytes = hasherBlockSize * 4;
          if (key.sigBytes > hasherBlockSizeBytes) {
            key = hasher.finalize(key);
          }
          key.clamp();
          var oKey = this._oKey = key.clone();
          var iKey = this._iKey = key.clone();
          var oKeyWords = oKey.words;
          var iKeyWords = iKey.words;
          for (var i2 = 0; i2 < hasherBlockSize; i2++) {
            oKeyWords[i2] ^= 1549556828;
            iKeyWords[i2] ^= 909522486;
          }
          oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
          this.reset();
        },
        reset: function() {
          var hasher = this._hasher;
          hasher.reset();
          hasher.update(this._iKey);
        },
        update: function(messageUpdate) {
          this._hasher.update(messageUpdate);
          return this;
        },
        finalize: function(messageUpdate) {
          var hasher = this._hasher;
          var innerHash = hasher.finalize(messageUpdate);
          hasher.reset();
          var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
          return hmac2;
        }
      });
    })();
  });
})(hmac);
(function(module, exports) {
  (function(root, factory, undef) {
    {
      module.exports = factory(core.exports, sha1.exports, hmac.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var Base = C_lib.Base;
      var WordArray = C_lib.WordArray;
      var C_algo = C.algo;
      var MD5 = C_algo.MD5;
      var EvpKDF = C_algo.EvpKDF = Base.extend({
        cfg: Base.extend({
          keySize: 128 / 32,
          hasher: MD5,
          iterations: 1
        }),
        init: function(cfg) {
          this.cfg = this.cfg.extend(cfg);
        },
        compute: function(password, salt) {
          var block;
          var cfg = this.cfg;
          var hasher = cfg.hasher.create();
          var derivedKey = WordArray.create();
          var derivedKeyWords = derivedKey.words;
          var keySize = cfg.keySize;
          var iterations = cfg.iterations;
          while (derivedKeyWords.length < keySize) {
            if (block) {
              hasher.update(block);
            }
            block = hasher.update(password).finalize(salt);
            hasher.reset();
            for (var i2 = 1; i2 < iterations; i2++) {
              block = hasher.finalize(block);
              hasher.reset();
            }
            derivedKey.concat(block);
          }
          derivedKey.sigBytes = keySize * 4;
          return derivedKey;
        }
      });
      C.EvpKDF = function(password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
      };
    })();
    return CryptoJS.EvpKDF;
  });
})(evpkdf);
var cipherCore = { exports: {} };
(function(module, exports) {
  (function(root, factory, undef) {
    {
      module.exports = factory(core.exports, evpkdf.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    CryptoJS.lib.Cipher || function(undefined$1) {
      var C = CryptoJS;
      var C_lib = C.lib;
      var Base = C_lib.Base;
      var WordArray = C_lib.WordArray;
      var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
      var C_enc = C.enc;
      C_enc.Utf8;
      var Base64 = C_enc.Base64;
      var C_algo = C.algo;
      var EvpKDF = C_algo.EvpKDF;
      var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        cfg: Base.extend(),
        createEncryptor: function(key, cfg) {
          return this.create(this._ENC_XFORM_MODE, key, cfg);
        },
        createDecryptor: function(key, cfg) {
          return this.create(this._DEC_XFORM_MODE, key, cfg);
        },
        init: function(xformMode, key, cfg) {
          this.cfg = this.cfg.extend(cfg);
          this._xformMode = xformMode;
          this._key = key;
          this.reset();
        },
        reset: function() {
          BufferedBlockAlgorithm.reset.call(this);
          this._doReset();
        },
        process: function(dataUpdate) {
          this._append(dataUpdate);
          return this._process();
        },
        finalize: function(dataUpdate) {
          if (dataUpdate) {
            this._append(dataUpdate);
          }
          var finalProcessedData = this._doFinalize();
          return finalProcessedData;
        },
        keySize: 128 / 32,
        ivSize: 128 / 32,
        _ENC_XFORM_MODE: 1,
        _DEC_XFORM_MODE: 2,
        _createHelper: function() {
          function selectCipherStrategy(key) {
            if (typeof key == "string") {
              return PasswordBasedCipher;
            } else {
              return SerializableCipher;
            }
          }
          return function(cipher) {
            return {
              encrypt: function(message, key, cfg) {
                return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
              },
              decrypt: function(ciphertext, key, cfg) {
                return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
              }
            };
          };
        }()
      });
      C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function() {
          var finalProcessedBlocks = this._process(true);
          return finalProcessedBlocks;
        },
        blockSize: 1
      });
      var C_mode = C.mode = {};
      var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        createEncryptor: function(cipher, iv) {
          return this.Encryptor.create(cipher, iv);
        },
        createDecryptor: function(cipher, iv) {
          return this.Decryptor.create(cipher, iv);
        },
        init: function(cipher, iv) {
          this._cipher = cipher;
          this._iv = iv;
        }
      });
      var CBC = C_mode.CBC = function() {
        var CBC2 = BlockCipherMode.extend();
        CBC2.Encryptor = CBC2.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            xorBlock.call(this, words, offset, blockSize);
            cipher.encryptBlock(words, offset);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CBC2.Decryptor = CBC2.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            cipher.decryptBlock(words, offset);
            xorBlock.call(this, words, offset, blockSize);
            this._prevBlock = thisBlock;
          }
        });
        function xorBlock(words, offset, blockSize) {
          var block;
          var iv = this._iv;
          if (iv) {
            block = iv;
            this._iv = undefined$1;
          } else {
            block = this._prevBlock;
          }
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset + i2] ^= block[i2];
          }
        }
        return CBC2;
      }();
      var C_pad = C.pad = {};
      var Pkcs7 = C_pad.Pkcs7 = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
          var paddingWords = [];
          for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
            paddingWords.push(paddingWord);
          }
          var padding = WordArray.create(paddingWords, nPaddingBytes);
          data2.concat(padding);
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      C_lib.BlockCipher = Cipher.extend({
        cfg: Cipher.cfg.extend({
          mode: CBC,
          padding: Pkcs7
        }),
        reset: function() {
          var modeCreator;
          Cipher.reset.call(this);
          var cfg = this.cfg;
          var iv = cfg.iv;
          var mode = cfg.mode;
          if (this._xformMode == this._ENC_XFORM_MODE) {
            modeCreator = mode.createEncryptor;
          } else {
            modeCreator = mode.createDecryptor;
            this._minBufferSize = 1;
          }
          if (this._mode && this._mode.__creator == modeCreator) {
            this._mode.init(this, iv && iv.words);
          } else {
            this._mode = modeCreator.call(mode, this, iv && iv.words);
            this._mode.__creator = modeCreator;
          }
        },
        _doProcessBlock: function(words, offset) {
          this._mode.processBlock(words, offset);
        },
        _doFinalize: function() {
          var finalProcessedBlocks;
          var padding = this.cfg.padding;
          if (this._xformMode == this._ENC_XFORM_MODE) {
            padding.pad(this._data, this.blockSize);
            finalProcessedBlocks = this._process(true);
          } else {
            finalProcessedBlocks = this._process(true);
            padding.unpad(finalProcessedBlocks);
          }
          return finalProcessedBlocks;
        },
        blockSize: 128 / 32
      });
      var CipherParams = C_lib.CipherParams = Base.extend({
        init: function(cipherParams) {
          this.mixIn(cipherParams);
        },
        toString: function(formatter) {
          return (formatter || this.formatter).stringify(this);
        }
      });
      var C_format = C.format = {};
      var OpenSSLFormatter = C_format.OpenSSL = {
        stringify: function(cipherParams) {
          var wordArray;
          var ciphertext = cipherParams.ciphertext;
          var salt = cipherParams.salt;
          if (salt) {
            wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
          } else {
            wordArray = ciphertext;
          }
          return wordArray.toString(Base64);
        },
        parse: function(openSSLStr) {
          var salt;
          var ciphertext = Base64.parse(openSSLStr);
          var ciphertextWords = ciphertext.words;
          if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
            salt = WordArray.create(ciphertextWords.slice(2, 4));
            ciphertextWords.splice(0, 4);
            ciphertext.sigBytes -= 16;
          }
          return CipherParams.create({ ciphertext, salt });
        }
      };
      var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        cfg: Base.extend({
          format: OpenSSLFormatter
        }),
        encrypt: function(cipher, message, key, cfg) {
          cfg = this.cfg.extend(cfg);
          var encryptor = cipher.createEncryptor(key, cfg);
          var ciphertext = encryptor.finalize(message);
          var cipherCfg = encryptor.cfg;
          return CipherParams.create({
            ciphertext,
            key,
            iv: cipherCfg.iv,
            algorithm: cipher,
            mode: cipherCfg.mode,
            padding: cipherCfg.padding,
            blockSize: cipher.blockSize,
            formatter: cfg.format
          });
        },
        decrypt: function(cipher, ciphertext, key, cfg) {
          cfg = this.cfg.extend(cfg);
          ciphertext = this._parse(ciphertext, cfg.format);
          var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
          return plaintext;
        },
        _parse: function(ciphertext, format) {
          if (typeof ciphertext == "string") {
            return format.parse(ciphertext, this);
          } else {
            return ciphertext;
          }
        }
      });
      var C_kdf = C.kdf = {};
      var OpenSSLKdf = C_kdf.OpenSSL = {
        execute: function(password, keySize, ivSize, salt) {
          if (!salt) {
            salt = WordArray.random(64 / 8);
          }
          var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
          var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
          key.sigBytes = keySize * 4;
          return CipherParams.create({ key, iv, salt });
        }
      };
      var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        cfg: SerializableCipher.cfg.extend({
          kdf: OpenSSLKdf
        }),
        encrypt: function(cipher, message, password, cfg) {
          cfg = this.cfg.extend(cfg);
          var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
          cfg.iv = derivedParams.iv;
          var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
          ciphertext.mixIn(derivedParams);
          return ciphertext;
        },
        decrypt: function(cipher, ciphertext, password, cfg) {
          cfg = this.cfg.extend(cfg);
          ciphertext = this._parse(ciphertext, cfg.format);
          var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
          cfg.iv = derivedParams.iv;
          var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
          return plaintext;
        }
      });
    }();
  });
})(cipherCore);
(function(module, exports) {
  (function(root, factory, undef) {
    {
      module.exports = factory(core.exports, encBase64.exports, md5.exports, evpkdf.exports, cipherCore.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var BlockCipher = C_lib.BlockCipher;
      var C_algo = C.algo;
      var SBOX = [];
      var INV_SBOX = [];
      var SUB_MIX_0 = [];
      var SUB_MIX_1 = [];
      var SUB_MIX_2 = [];
      var SUB_MIX_3 = [];
      var INV_SUB_MIX_0 = [];
      var INV_SUB_MIX_1 = [];
      var INV_SUB_MIX_2 = [];
      var INV_SUB_MIX_3 = [];
      (function() {
        var d = [];
        for (var i2 = 0; i2 < 256; i2++) {
          if (i2 < 128) {
            d[i2] = i2 << 1;
          } else {
            d[i2] = i2 << 1 ^ 283;
          }
        }
        var x = 0;
        var xi = 0;
        for (var i2 = 0; i2 < 256; i2++) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          SBOX[x] = sx;
          INV_SBOX[sx] = x;
          var x2 = d[x];
          var x4 = d[x2];
          var x8 = d[x4];
          var t2 = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
          SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
          SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
          SUB_MIX_3[x] = t2;
          var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
          INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
          INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
          INV_SUB_MIX_3[sx] = t2;
          if (!x) {
            x = xi = 1;
          } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
          }
        }
      })();
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var AES2 = C_algo.AES = BlockCipher.extend({
        _doReset: function() {
          var t2;
          if (this._nRounds && this._keyPriorReset === this._key) {
            return;
          }
          var key = this._keyPriorReset = this._key;
          var keyWords = key.words;
          var keySize = key.sigBytes / 4;
          var nRounds = this._nRounds = keySize + 6;
          var ksRows = (nRounds + 1) * 4;
          var keySchedule = this._keySchedule = [];
          for (var ksRow = 0; ksRow < ksRows; ksRow++) {
            if (ksRow < keySize) {
              keySchedule[ksRow] = keyWords[ksRow];
            } else {
              t2 = keySchedule[ksRow - 1];
              if (!(ksRow % keySize)) {
                t2 = t2 << 8 | t2 >>> 24;
                t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                t2 ^= RCON[ksRow / keySize | 0] << 24;
              } else if (keySize > 6 && ksRow % keySize == 4) {
                t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
              }
              keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
            }
          }
          var invKeySchedule = this._invKeySchedule = [];
          for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
            var ksRow = ksRows - invKsRow;
            if (invKsRow % 4) {
              var t2 = keySchedule[ksRow];
            } else {
              var t2 = keySchedule[ksRow - 4];
            }
            if (invKsRow < 4 || ksRow <= 4) {
              invKeySchedule[invKsRow] = t2;
            } else {
              invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
            }
          }
        },
        encryptBlock: function(M, offset) {
          this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },
        decryptBlock: function(M, offset) {
          var t2 = M[offset + 1];
          M[offset + 1] = M[offset + 3];
          M[offset + 3] = t2;
          this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
          var t2 = M[offset + 1];
          M[offset + 1] = M[offset + 3];
          M[offset + 3] = t2;
        },
        _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
          var nRounds = this._nRounds;
          var s0 = M[offset] ^ keySchedule[0];
          var s1 = M[offset + 1] ^ keySchedule[1];
          var s2 = M[offset + 2] ^ keySchedule[2];
          var s3 = M[offset + 3] ^ keySchedule[3];
          var ksRow = 4;
          for (var round = 1; round < nRounds; round++) {
            var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
            var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
            var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
            var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
            s0 = t0;
            s1 = t1;
            s2 = t2;
            s3 = t3;
          }
          var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
          var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
          var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
          var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
          M[offset] = t0;
          M[offset + 1] = t1;
          M[offset + 2] = t2;
          M[offset + 3] = t3;
        },
        keySize: 256 / 32
      });
      C.AES = BlockCipher._createHelper(AES2);
    })();
    return CryptoJS.AES;
  });
})(aes);
var encUtf8 = { exports: {} };
(function(module, exports) {
  (function(root, factory) {
    {
      module.exports = factory(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    return CryptoJS.enc.Utf8;
  });
})(encUtf8);
var _interopRequireDefault$5 = interopRequireDefault.exports;
var _stringify$2 = _interopRequireDefault$5(stringify2);
var AES;
var ENC;
AES = aes.exports;
ENC = encUtf8.exports;
var CryptoController = {
  encrypt: function(obj, secretKey) {
    var encrypted = AES.encrypt((0, _stringify$2.default)(obj), secretKey);
    return encrypted.toString();
  },
  decrypt: function(encryptedText, secretKey) {
    var decryptedStr = AES.decrypt(encryptedText, secretKey).toString(ENC);
    return decryptedStr;
  }
};
var CryptoController_1 = CryptoController;
var _interopRequireDefault$4 = interopRequireDefault.exports;
var _promise$4 = _interopRequireDefault$4(promise$3);
var _Storage$1 = _interopRequireDefault$4(Storage_1);
var uuidv4$1 = uuid_1;
var iidCache = null;
var InstallationController = {
  currentInstallationId: function() {
    if (typeof iidCache === "string") {
      return _promise$4.default.resolve(iidCache);
    }
    var path2 = _Storage$1.default.generatePath("installationId");
    return _Storage$1.default.getItemAsync(path2).then(function(iid) {
      if (!iid) {
        iid = uuidv4$1();
        return _Storage$1.default.setItemAsync(path2, iid).then(function() {
          iidCache = iid;
          return iid;
        });
      }
      iidCache = iid;
      return iid;
    });
  },
  _clearCache: function() {
    iidCache = null;
  },
  _setInstallationIdCache: function(iid) {
    iidCache = iid;
  }
};
var InstallationController_1 = InstallationController;
var path$2 = path$u;
var setTimeout$2 = path$2.setTimeout;
var setTimeout$1 = setTimeout$2;
var _interopRequireDefault$3 = interopRequireDefault.exports;
var _Object$defineProperty$1 = defineProperty$a;
var _Object$defineProperties = defineProperties4;
var _Object$getOwnPropertyDescriptors = getOwnPropertyDescriptors2;
var _forEachInstanceProperty = forEach2;
var _Object$getOwnPropertyDescriptor$1 = getOwnPropertyDescriptor$4;
var _filterInstanceProperty = filter3;
var _Object$getOwnPropertySymbols = getOwnPropertySymbols3;
var _Object$keys = keys$5;
var _defineProperty2 = _interopRequireDefault$3(defineProperty$2.exports);
var _typeof2 = _interopRequireDefault$3(_typeof$1.exports);
var _setTimeout2 = _interopRequireDefault$3(setTimeout$1);
var _includes$1 = _interopRequireDefault$3(includes4);
var _stringify$1 = _interopRequireDefault$3(stringify2);
var _promise$3 = _interopRequireDefault$3(promise$3);
var _CoreManager$2 = _interopRequireDefault$3(CoreManager);
var _ParseError = _interopRequireDefault$3(ParseError$1);
var _promiseUtils = promiseUtils;
function ownKeys2(object, enumerableOnly) {
  var keys4 = _Object$keys(object);
  if (_Object$getOwnPropertySymbols) {
    var symbols = _Object$getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = _filterInstanceProperty(symbols).call(symbols, function(sym) {
        return _Object$getOwnPropertyDescriptor$1(object, sym).enumerable;
      });
    }
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      var _context4;
      _forEachInstanceProperty(_context4 = ownKeys2(Object(source), true)).call(_context4, function(key) {
        (0, _defineProperty2.default)(target, key, source[key]);
      });
    } else if (_Object$getOwnPropertyDescriptors) {
      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));
    } else {
      var _context5;
      _forEachInstanceProperty(_context5 = ownKeys2(Object(source))).call(_context5, function(key) {
        _Object$defineProperty$1(target, key, _Object$getOwnPropertyDescriptor$1(source, key));
      });
    }
  }
  return target;
}
var uuidv4 = uuid_1;
var XHR = null;
if (typeof XMLHttpRequest !== "undefined") {
  XHR = XMLHttpRequest;
}
var useXDomainRequest = false;
if (typeof XDomainRequest !== "undefined" && !("withCredentials" in new XMLHttpRequest())) {
  useXDomainRequest = true;
}
function ajaxIE9(method2, url, data2, headers, options) {
  return new _promise$3.default(function(resolve3, reject2) {
    var xdr = new XDomainRequest();
    xdr.onload = function() {
      var response;
      try {
        response = JSON.parse(xdr.responseText);
      } catch (e2) {
        reject2(e2);
      }
      if (response) {
        resolve3({
          response
        });
      }
    };
    xdr.onerror = xdr.ontimeout = function() {
      var fakeResponse = {
        responseText: (0, _stringify$1.default)({
          code: _ParseError.default.X_DOMAIN_REQUEST,
          error: "IE's XDomainRequest does not supply error info."
        })
      };
      reject2(fakeResponse);
    };
    xdr.onprogress = function() {
      if (options && typeof options.progress === "function") {
        options.progress(xdr.responseText);
      }
    };
    xdr.open(method2, url);
    xdr.send(data2);
    if (options && typeof options.requestTask === "function") {
      options.requestTask(xdr);
    }
  });
}
var RESTController = {
  ajax: function(method2, url, data2, headers, options) {
    var _context;
    if (useXDomainRequest) {
      return ajaxIE9(method2, url, data2, headers, options);
    }
    var promise2 = (0, _promiseUtils.resolvingPromise)();
    var isIdempotent = _CoreManager$2.default.get("IDEMPOTENCY") && (0, _includes$1.default)(_context = ["POST", "PUT"]).call(_context, method2);
    var requestId = isIdempotent ? uuidv4() : "";
    var attempts = 0;
    var dispatch2 = function dispatch3() {
      if (XHR == null) {
        throw new Error("Cannot make a request: No definition of XMLHttpRequest was found.");
      }
      var handled = false;
      var xhr = new XHR();
      xhr.onreadystatechange = function() {
        if (xhr.readyState !== 4 || handled || xhr._aborted) {
          return;
        }
        handled = true;
        if (xhr.status >= 200 && xhr.status < 300) {
          var response;
          try {
            response = JSON.parse(xhr.responseText);
            if (typeof xhr.getResponseHeader === "function") {
              var _context2, _context3;
              if ((0, _includes$1.default)(_context2 = xhr.getAllResponseHeaders() || "").call(_context2, "x-parse-job-status-id: ")) {
                response = xhr.getResponseHeader("x-parse-job-status-id");
              }
              if ((0, _includes$1.default)(_context3 = xhr.getAllResponseHeaders() || "").call(_context3, "x-parse-push-status-id: ")) {
                response = xhr.getResponseHeader("x-parse-push-status-id");
              }
            }
          } catch (e2) {
            promise2.reject(e2.toString());
          }
          if (response) {
            promise2.resolve({
              response,
              status: xhr.status,
              xhr
            });
          }
        } else if (xhr.status >= 500 || xhr.status === 0) {
          if (++attempts < _CoreManager$2.default.get("REQUEST_ATTEMPT_LIMIT")) {
            var delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));
            (0, _setTimeout2.default)(dispatch3, delay);
          } else if (xhr.status === 0) {
            promise2.reject("Unable to connect to the Parse API");
          } else {
            promise2.reject(xhr);
          }
        } else {
          promise2.reject(xhr);
        }
      };
      headers = headers || {};
      if (typeof headers["Content-Type"] !== "string") {
        headers["Content-Type"] = "text/plain";
      }
      if (_CoreManager$2.default.get("IS_NODE")) {
        headers["User-Agent"] = "Parse/" + _CoreManager$2.default.get("VERSION") + " (NodeJS " + process.versions.node + ")";
      }
      if (isIdempotent) {
        headers["X-Parse-Request-Id"] = requestId;
      }
      if (_CoreManager$2.default.get("SERVER_AUTH_TYPE") && _CoreManager$2.default.get("SERVER_AUTH_TOKEN")) {
        headers["Authorization"] = _CoreManager$2.default.get("SERVER_AUTH_TYPE") + " " + _CoreManager$2.default.get("SERVER_AUTH_TOKEN");
      }
      var customHeaders = _CoreManager$2.default.get("REQUEST_HEADERS");
      for (var key in customHeaders) {
        headers[key] = customHeaders[key];
      }
      function handleProgress(type, event) {
        if (options && typeof options.progress === "function") {
          if (event.lengthComputable) {
            options.progress(event.loaded / event.total, event.loaded, event.total, {
              type
            });
          } else {
            options.progress(null, null, null, {
              type
            });
          }
        }
      }
      xhr.onprogress = function(event) {
        handleProgress("download", event);
      };
      if (xhr.upload) {
        xhr.upload.onprogress = function(event) {
          handleProgress("upload", event);
        };
      }
      xhr.open(method2, url, true);
      for (var h2 in headers) {
        xhr.setRequestHeader(h2, headers[h2]);
      }
      xhr.onabort = function() {
        promise2.resolve({
          response: {
            results: []
          },
          status: 0,
          xhr
        });
      };
      xhr.send(data2);
      if (options && typeof options.requestTask === "function") {
        options.requestTask(xhr);
      }
    };
    dispatch2();
    return promise2;
  },
  request: function(method2, path2, data2, options) {
    options = options || {};
    var url = _CoreManager$2.default.get("SERVER_URL");
    if (url[url.length - 1] !== "/") {
      url += "/";
    }
    url += path2;
    var payload = {};
    if (data2 && (0, _typeof2.default)(data2) === "object") {
      for (var k in data2) {
        payload[k] = data2[k];
      }
    }
    var context = options.context;
    if (context !== void 0) {
      payload._context = context;
    }
    if (method2 !== "POST") {
      payload._method = method2;
      method2 = "POST";
    }
    payload._ApplicationId = _CoreManager$2.default.get("APPLICATION_ID");
    var jsKey = _CoreManager$2.default.get("JAVASCRIPT_KEY");
    if (jsKey) {
      payload._JavaScriptKey = jsKey;
    }
    payload._ClientVersion = _CoreManager$2.default.get("VERSION");
    var useMasterKey = options.useMasterKey;
    if (typeof useMasterKey === "undefined") {
      useMasterKey = _CoreManager$2.default.get("USE_MASTER_KEY");
    }
    if (useMasterKey) {
      if (_CoreManager$2.default.get("MASTER_KEY")) {
        delete payload._JavaScriptKey;
        payload._MasterKey = _CoreManager$2.default.get("MASTER_KEY");
      } else {
        throw new Error("Cannot use the Master Key, it has not been provided.");
      }
    }
    if (_CoreManager$2.default.get("FORCE_REVOCABLE_SESSION")) {
      payload._RevocableSession = "1";
    }
    var installationId = options.installationId;
    var installationIdPromise;
    if (installationId && typeof installationId === "string") {
      installationIdPromise = _promise$3.default.resolve(installationId);
    } else {
      var installationController = _CoreManager$2.default.getInstallationController();
      installationIdPromise = installationController.currentInstallationId();
    }
    return installationIdPromise.then(function(iid) {
      payload._InstallationId = iid;
      var userController = _CoreManager$2.default.getUserController();
      if (options && typeof options.sessionToken === "string") {
        return _promise$3.default.resolve(options.sessionToken);
      } else if (userController) {
        return userController.currentUserAsync().then(function(user) {
          if (user) {
            return _promise$3.default.resolve(user.getSessionToken());
          }
          return _promise$3.default.resolve(null);
        });
      }
      return _promise$3.default.resolve(null);
    }).then(function(token) {
      if (token) {
        payload._SessionToken = token;
      }
      var payloadString = (0, _stringify$1.default)(payload);
      return RESTController.ajax(method2, url, payloadString, {}, options).then(function(_ref) {
        var response = _ref.response, status = _ref.status;
        if (options.returnStatus) {
          return _objectSpread(_objectSpread({}, response), {}, {
            _status: status
          });
        } else {
          return response;
        }
      });
    }).catch(RESTController.handleError);
  },
  handleError: function(response) {
    var error;
    if (response && response.responseText) {
      try {
        var errorJSON = JSON.parse(response.responseText);
        error = new _ParseError.default(errorJSON.code, errorJSON.error);
      } catch (e2) {
        error = new _ParseError.default(_ParseError.default.INVALID_JSON, "Received an error with invalid JSON from Parse: " + response.responseText);
      }
    } else {
      var message = response.message ? response.message : response;
      error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, "XMLHttpRequest failed: " + (0, _stringify$1.default)(message));
    }
    return _promise$3.default.reject(error);
  },
  _setXHR: function(xhr) {
    XHR = xhr;
  },
  _getXHR: function() {
    return XHR;
  }
};
var RESTController_1 = RESTController;
var Analytics = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.track = track2;
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  function track2(name, dimensions) {
    name = name || "";
    name = name.replace(/^\s*/, "");
    name = name.replace(/\s*$/, "");
    if (name.length === 0) {
      throw new TypeError("A name for the custom event must be provided");
    }
    for (var _key in dimensions) {
      if (typeof _key !== "string" || typeof dimensions[_key] !== "string") {
        throw new TypeError('track() dimensions expects keys and values of type "string".');
      }
    }
    return _CoreManager2.default.getAnalyticsController().track(name, dimensions);
  }
  var DefaultController = {
    track: function(name, dimensions) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("POST", "events/" + name, {
        dimensions
      });
    }
  };
  _CoreManager2.default.setAnalyticsController(DefaultController);
})(Analytics);
var AnonymousUtils = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ParseUser = _interopRequireDefault2(ParseUser);
  var uuidv42 = uuid_1;
  var registered = false;
  var AnonymousUtils2 = {
    isLinked: function(user) {
      var provider = this._getAuthProvider();
      return user._isLinked(provider.getAuthType());
    },
    logIn: function(options) {
      var provider = this._getAuthProvider();
      return _ParseUser.default.logInWith(provider.getAuthType(), provider.getAuthData(), options);
    },
    link: function(user, options) {
      var provider = this._getAuthProvider();
      return user.linkWith(provider.getAuthType(), provider.getAuthData(), options);
    },
    isRegistered: function() {
      return registered;
    },
    _getAuthProvider: function() {
      var provider = {
        restoreAuthentication: function() {
          return true;
        },
        getAuthType: function() {
          return "anonymous";
        },
        getAuthData: function() {
          return {
            authData: {
              id: uuidv42()
            }
          };
        }
      };
      if (!registered) {
        _ParseUser.default._registerAuthenticationProvider(provider);
        registered = true;
      }
      return provider;
    }
  };
  var _default = AnonymousUtils2;
  exports.default = _default;
})(AnonymousUtils);
var Cloud = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.getJobStatus = getJobStatus;
  exports.getJobsData = getJobsData;
  exports.run = run2;
  exports.startJob = startJob;
  var _promise2 = _interopRequireDefault2(promise$3);
  var _keys4 = _interopRequireDefault2(keys$5);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _decode2 = _interopRequireDefault2(decode$2);
  var _encode2 = _interopRequireDefault2(encode);
  var _ParseError2 = _interopRequireDefault2(ParseError$1);
  var _ParseQuery2 = _interopRequireDefault2(ParseQuery);
  _interopRequireDefault2(ParseObject);
  function run2(name, data2, options) {
    options = options || {};
    if (typeof name !== "string" || name.length === 0) {
      throw new TypeError("Cloud function name must be a string.");
    }
    var requestOptions = {};
    if (options.useMasterKey) {
      requestOptions.useMasterKey = options.useMasterKey;
    }
    if (options.sessionToken) {
      requestOptions.sessionToken = options.sessionToken;
    }
    if (options.context && (0, _typeof22.default)(options.context) === "object") {
      requestOptions.context = options.context;
    }
    return _CoreManager2.default.getCloudController().run(name, data2, requestOptions);
  }
  function getJobsData() {
    return _CoreManager2.default.getCloudController().getJobsData({
      useMasterKey: true
    });
  }
  function startJob(name, data2) {
    if (typeof name !== "string" || name.length === 0) {
      throw new TypeError("Cloud job name must be a string.");
    }
    return _CoreManager2.default.getCloudController().startJob(name, data2, {
      useMasterKey: true
    });
  }
  function getJobStatus(jobStatusId) {
    var query = new _ParseQuery2.default("_JobStatus");
    return query.get(jobStatusId, {
      useMasterKey: true
    });
  }
  var DefaultController = {
    run: function(name, data2, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      var payload = (0, _encode2.default)(data2, true);
      var request = RESTController2.request("POST", "functions/" + name, payload, options);
      return request.then(function(res) {
        if ((0, _typeof22.default)(res) === "object" && (0, _keys4.default)(res).length > 0 && !res.hasOwnProperty("result")) {
          throw new _ParseError2.default(_ParseError2.default.INVALID_JSON, "The server returned an invalid response.");
        }
        var decoded = (0, _decode2.default)(res);
        if (decoded && decoded.hasOwnProperty("result")) {
          return _promise2.default.resolve(decoded.result);
        }
        return _promise2.default.resolve(void 0);
      });
    },
    getJobsData: function(options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "cloud_code/jobs/data", null, options);
    },
    startJob: function(name, data2, options) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      var payload = (0, _encode2.default)(data2, true);
      return RESTController2.request("POST", "jobs/" + name, payload, options);
    }
  };
  _CoreManager2.default.setCloudController(DefaultController);
})(Cloud);
var ParseCLP = {};
var DESCRIPTORS = descriptors;
var uncurryThis = functionUncurryThis;
var call = functionCall;
var fails = fails$u;
var objectKeys = objectKeys$4;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$1 = toObject$c;
var IndexedObject$1 = indexedObject;
var $assign = Object.assign;
var defineProperty5 = Object.defineProperty;
var concat2 = uncurryThis([].concat);
var objectAssign = !$assign || fails(function() {
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty5({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty5(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A = {};
  var B = {};
  var symbol2 = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol2] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol2] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
}) ? function assign(target, source) {
  var T = toObject$1(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols4 = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable4 = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject$1(arguments[index++]);
    var keys4 = getOwnPropertySymbols4 ? concat2(objectKeys(S), getOwnPropertySymbols4(S)) : objectKeys(S);
    var length = keys4.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys4[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable4, S, key))
        T[key] = S[key];
    }
  }
  return T;
} : $assign;
var $$2 = _export;
var assign$4 = objectAssign;
$$2({ target: "Object", stat: true, forced: Object.assign !== assign$4 }, {
  assign: assign$4
});
var path$1 = path$u;
var assign$3 = path$1.Object.assign;
var parent$5 = assign$3;
var assign$2 = parent$5;
var assign$1 = assign$2;
var entryVirtual$3 = entryVirtual$j;
var entries$4 = entryVirtual$3("Array").entries;
var parent$4 = entries$4;
var entries$3 = parent$4;
var classof$1 = classof$d;
var hasOwn$1 = hasOwnProperty_1;
var isPrototypeOf$3 = objectIsPrototypeOf;
var method$3 = entries$3;
var ArrayPrototype$3 = Array.prototype;
var DOMIterables$1 = {
  DOMTokenList: true,
  NodeList: true
};
var entries$2 = function(it) {
  var own = it.entries;
  return it === ArrayPrototype$3 || isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.entries || hasOwn$1(DOMIterables$1, classof$1(it)) ? method$3 : own;
};
var entries$1 = entries$2;
var $$1 = _export;
var $every = arrayIteration.every;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$5;
var STRICT_METHOD$1 = arrayMethodIsStrict$1("every");
$$1({ target: "Array", proto: true, forced: !STRICT_METHOD$1 }, {
  every: function every2(callbackfn) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$2 = entryVirtual$j;
var every$3 = entryVirtual$2("Array").every;
var isPrototypeOf$2 = objectIsPrototypeOf;
var method$2 = every$3;
var ArrayPrototype$2 = Array.prototype;
var every$2 = function(it) {
  var own = it.every;
  return it === ArrayPrototype$2 || isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.every ? method$2 : own;
};
var parent$3 = every$2;
var every$1 = parent$3;
var every3 = every$1;
var map2 = map$8;
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Object$defineProperties2 = defineProperties4;
  var _Object$getOwnPropertyDescriptors2 = getOwnPropertyDescriptors2;
  var _forEachInstanceProperty2 = forEach2;
  var _Object$getOwnPropertyDescriptor2 = getOwnPropertyDescriptor$4;
  var _filterInstanceProperty2 = filter3;
  var _Object$getOwnPropertySymbols2 = getOwnPropertySymbols3;
  var _Object$keys2 = keys$5;
  var _Array$isArray22 = isArray$4;
  var _getIteratorMethod2 = getIteratorMethod$1;
  var _Symbol2 = symbol;
  var _Array$from3 = from$3;
  var _sliceInstanceProperty22 = slice$3;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _isArray2 = _interopRequireDefault2(isArray$4);
  var _keys4 = _interopRequireDefault2(keys$5);
  var _slice2 = _interopRequireDefault2(slice$3);
  var _assign = _interopRequireDefault2(assign$1);
  var _slicedToArray22 = _interopRequireDefault2(slicedToArray.exports);
  var _entries = _interopRequireDefault2(entries$1);
  var _every = _interopRequireDefault2(every3);
  var _includes2 = _interopRequireDefault2(includes4);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _map2 = _interopRequireDefault2(map2);
  var _ParseRole = _interopRequireDefault2(ParseRole);
  var _ParseUser = _interopRequireDefault2(ParseUser);
  function ownKeys3(object, enumerableOnly) {
    var keys4 = _Object$keys2(object);
    if (_Object$getOwnPropertySymbols2) {
      var symbols = _Object$getOwnPropertySymbols2(object);
      if (enumerableOnly) {
        symbols = _filterInstanceProperty2(symbols).call(symbols, function(sym) {
          return _Object$getOwnPropertyDescriptor2(object, sym).enumerable;
        });
      }
      keys4.push.apply(keys4, symbols);
    }
    return keys4;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        var _context3;
        _forEachInstanceProperty2(_context3 = ownKeys3(Object(source), true)).call(_context3, function(key) {
          (0, _defineProperty22.default)(target, key, source[key]);
        });
      } else if (_Object$getOwnPropertyDescriptors2) {
        _Object$defineProperties2(target, _Object$getOwnPropertyDescriptors2(source));
      } else {
        var _context4;
        _forEachInstanceProperty2(_context4 = ownKeys3(Object(source))).call(_context4, function(key) {
          _Object$defineProperty2(target, key, _Object$getOwnPropertyDescriptor2(source, key));
        });
      }
    }
    return target;
  }
  function _createForOfIteratorHelper2(o2, allowArrayLike) {
    var it = typeof _Symbol2 !== "undefined" && _getIteratorMethod2(o2) || o2["@@iterator"];
    if (!it) {
      if (_Array$isArray22(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
        if (it)
          o2 = it;
        var i2 = 0;
        var F = function() {
        };
        return {
          s: F,
          n: function() {
            if (i2 >= o2.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o2[i2++]
            };
          },
          e: function(_e) {
            throw _e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
      s: function() {
        it = it.call(o2);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      }
    };
  }
  function _unsupportedIterableToArray2(o2, minLen) {
    var _context2;
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray2(o2, minLen);
    var n2 = _sliceInstanceProperty22(_context2 = Object.prototype.toString.call(o2)).call(_context2, 8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return _Array$from3(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o2, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  var PUBLIC_KEY = "*";
  var VALID_PERMISSIONS = new _map2.default();
  VALID_PERMISSIONS.set("get", {});
  VALID_PERMISSIONS.set("find", {});
  VALID_PERMISSIONS.set("count", {});
  VALID_PERMISSIONS.set("create", {});
  VALID_PERMISSIONS.set("update", {});
  VALID_PERMISSIONS.set("delete", {});
  VALID_PERMISSIONS.set("addField", {});
  var VALID_PERMISSIONS_EXTENDED = new _map2.default();
  VALID_PERMISSIONS_EXTENDED.set("protectedFields", {});
  var ParseCLP2 = /* @__PURE__ */ function() {
    function ParseCLP3(userId) {
      var _this = this;
      (0, _classCallCheck22.default)(this, ParseCLP3);
      (0, _defineProperty22.default)(this, "permissionsMap", void 0);
      this.permissionsMap = {};
      var _iterator = _createForOfIteratorHelper2((0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)), _step;
      try {
        var _loop = function() {
          var _step$value = (0, _slicedToArray22.default)(_step.value, 2), operation2 = _step$value[0], group2 = _step$value[1];
          _this.permissionsMap[operation2] = (0, _assign.default)({}, group2);
          var action = operation2.charAt(0).toUpperCase() + (0, _slice2.default)(operation2).call(operation2, 1);
          _this["get".concat(action, "RequiresAuthentication")] = function() {
            return this._getAccess(operation2, "requiresAuthentication");
          };
          _this["set".concat(action, "RequiresAuthentication")] = function(allowed2) {
            this._setAccess(operation2, "requiresAuthentication", allowed2);
          };
          _this["get".concat(action, "PointerFields")] = function() {
            return this._getAccess(operation2, "pointerFields", false);
          };
          _this["set".concat(action, "PointerFields")] = function(pointerFields) {
            this._setArrayAccess(operation2, "pointerFields", pointerFields);
          };
          _this["get".concat(action, "Access")] = function(entity) {
            return this._getAccess(operation2, entity);
          };
          _this["set".concat(action, "Access")] = function(entity, allowed2) {
            this._setAccess(operation2, entity, allowed2);
          };
          _this["getPublic".concat(action, "Access")] = function() {
            return this["get".concat(action, "Access")](PUBLIC_KEY);
          };
          _this["setPublic".concat(action, "Access")] = function(allowed2) {
            this["set".concat(action, "Access")](PUBLIC_KEY, allowed2);
          };
          _this["getRole".concat(action, "Access")] = function(role) {
            return this["get".concat(action, "Access")](this._getRoleName(role));
          };
          _this["setRole".concat(action, "Access")] = function(role, allowed2) {
            this["set".concat(action, "Access")](this._getRoleName(role), allowed2);
          };
        };
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper2((0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = (0, _slicedToArray22.default)(_step2.value, 2), operation = _step2$value[0], group = _step2$value[1];
          this.permissionsMap[operation] = (0, _assign.default)({}, group);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (userId && (0, _typeof22.default)(userId) === "object") {
        if (userId instanceof _ParseUser.default) {
          this.setReadAccess(userId, true);
          this.setWriteAccess(userId, true);
        } else if (userId instanceof _ParseRole.default) {
          this.setRoleReadAccess(userId, true);
          this.setRoleWriteAccess(userId, true);
        } else {
          for (var _permission in userId) {
            var _context;
            var users = userId[_permission];
            var isValidPermission = !!VALID_PERMISSIONS.get(_permission);
            var isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(_permission);
            var isValidGroupPermission = (0, _includes2.default)(_context = ["readUserFields", "writeUserFields"]).call(_context, _permission);
            if (typeof _permission !== "string" || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {
              throw new TypeError("Tried to create an CLP with an invalid permission type.");
            }
            if (isValidGroupPermission) {
              if ((0, _every.default)(users).call(users, function(pointer) {
                return typeof pointer === "string";
              })) {
                this.permissionsMap[_permission] = users;
                continue;
              } else {
                throw new TypeError("Tried to create an CLP with an invalid permission value.");
              }
            }
            for (var user in users) {
              var allowed = users[user];
              if (typeof allowed !== "boolean" && !isValidPermissionExtended && user !== "pointerFields") {
                throw new TypeError("Tried to create an CLP with an invalid permission value.");
              }
              this.permissionsMap[_permission][user] = allowed;
            }
          }
        }
      } else if (typeof userId === "function") {
        throw new TypeError("ParseCLP constructed with a function. Did you forget ()?");
      }
    }
    (0, _createClass22.default)(ParseCLP3, [{
      key: "toJSON",
      value: function() {
        return _objectSpread2({}, this.permissionsMap);
      }
    }, {
      key: "equals",
      value: function(other) {
        if (!(other instanceof ParseCLP3)) {
          return false;
        }
        var permissions = (0, _keys4.default)(this.permissionsMap);
        var otherPermissions = (0, _keys4.default)(other.permissionsMap);
        if (permissions.length !== otherPermissions.length) {
          return false;
        }
        for (var _permission2 in this.permissionsMap) {
          if (!other.permissionsMap[_permission2]) {
            return false;
          }
          var users = (0, _keys4.default)(this.permissionsMap[_permission2]);
          var otherUsers = (0, _keys4.default)(other.permissionsMap[_permission2]);
          if (users.length !== otherUsers.length) {
            return false;
          }
          for (var user in this.permissionsMap[_permission2]) {
            if (!other.permissionsMap[_permission2][user]) {
              return false;
            }
            if (this.permissionsMap[_permission2][user] !== other.permissionsMap[_permission2][user]) {
              return false;
            }
          }
        }
        return true;
      }
    }, {
      key: "_getRoleName",
      value: function(role) {
        var name = role;
        if (role instanceof _ParseRole.default) {
          name = role.getName();
        }
        if (typeof name !== "string") {
          throw new TypeError("role must be a Parse.Role or a String");
        }
        return "role:".concat(name);
      }
    }, {
      key: "_parseEntity",
      value: function(entity) {
        var userId = entity;
        if (userId instanceof _ParseUser.default) {
          userId = userId.id;
          if (!userId) {
            throw new Error("Cannot get access for a Parse.User without an id.");
          }
        } else if (userId instanceof _ParseRole.default) {
          userId = this._getRoleName(userId);
        }
        if (typeof userId !== "string") {
          throw new TypeError("userId must be a string.");
        }
        return userId;
      }
    }, {
      key: "_setAccess",
      value: function(permission, userId, allowed) {
        userId = this._parseEntity(userId);
        if (typeof allowed !== "boolean") {
          throw new TypeError("allowed must be either true or false.");
        }
        var permissions = this.permissionsMap[permission][userId];
        if (!permissions) {
          if (!allowed) {
            return;
          } else {
            this.permissionsMap[permission][userId] = {};
          }
        }
        if (allowed) {
          this.permissionsMap[permission][userId] = true;
        } else {
          delete this.permissionsMap[permission][userId];
        }
      }
    }, {
      key: "_getAccess",
      value: function(permission, userId) {
        var returnBoolean = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        userId = this._parseEntity(userId);
        var permissions = this.permissionsMap[permission][userId];
        if (returnBoolean) {
          if (!permissions) {
            return false;
          }
          return !!this.permissionsMap[permission][userId];
        }
        return permissions;
      }
    }, {
      key: "_setArrayAccess",
      value: function(permission, userId, fields) {
        userId = this._parseEntity(userId);
        var permissions = this.permissionsMap[permission][userId];
        if (!permissions) {
          this.permissionsMap[permission][userId] = [];
        }
        if (!fields || (0, _isArray2.default)(fields) && fields.length === 0) {
          delete this.permissionsMap[permission][userId];
        } else if ((0, _isArray2.default)(fields) && (0, _every.default)(fields).call(fields, function(field) {
          return typeof field === "string";
        })) {
          this.permissionsMap[permission][userId] = fields;
        } else {
          throw new TypeError("fields must be an array of strings or undefined.");
        }
      }
    }, {
      key: "_setGroupPointerPermission",
      value: function(operation, pointerFields) {
        var fields = this.permissionsMap[operation];
        if (!fields) {
          this.permissionsMap[operation] = [];
        }
        if (!pointerFields || (0, _isArray2.default)(pointerFields) && pointerFields.length === 0) {
          delete this.permissionsMap[operation];
        } else if ((0, _isArray2.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, function(field) {
          return typeof field === "string";
        })) {
          this.permissionsMap[operation] = pointerFields;
        } else {
          throw new TypeError("".concat(operation, ".pointerFields must be an array of strings or undefined."));
        }
      }
    }, {
      key: "_getGroupPointerPermissions",
      value: function(operation) {
        return this.permissionsMap[operation];
      }
    }, {
      key: "setReadUserFields",
      value: function(pointerFields) {
        this._setGroupPointerPermission("readUserFields", pointerFields);
      }
    }, {
      key: "getReadUserFields",
      value: function() {
        return this._getGroupPointerPermissions("readUserFields");
      }
    }, {
      key: "setWriteUserFields",
      value: function(pointerFields) {
        this._setGroupPointerPermission("writeUserFields", pointerFields);
      }
    }, {
      key: "getWriteUserFields",
      value: function() {
        return this._getGroupPointerPermissions("writeUserFields");
      }
    }, {
      key: "setProtectedFields",
      value: function(userId, fields) {
        this._setArrayAccess("protectedFields", userId, fields);
      }
    }, {
      key: "getProtectedFields",
      value: function(userId) {
        return this._getAccess("protectedFields", userId, false);
      }
    }, {
      key: "setReadAccess",
      value: function(userId, allowed) {
        this._setAccess("find", userId, allowed);
        this._setAccess("get", userId, allowed);
        this._setAccess("count", userId, allowed);
      }
    }, {
      key: "getReadAccess",
      value: function(userId) {
        return this._getAccess("find", userId) && this._getAccess("get", userId) && this._getAccess("count", userId);
      }
    }, {
      key: "setWriteAccess",
      value: function(userId, allowed) {
        this._setAccess("create", userId, allowed);
        this._setAccess("update", userId, allowed);
        this._setAccess("delete", userId, allowed);
        this._setAccess("addField", userId, allowed);
      }
    }, {
      key: "getWriteAccess",
      value: function(userId) {
        return this._getAccess("create", userId) && this._getAccess("update", userId) && this._getAccess("delete", userId) && this._getAccess("addField", userId);
      }
    }, {
      key: "setPublicReadAccess",
      value: function(allowed) {
        this.setReadAccess(PUBLIC_KEY, allowed);
      }
    }, {
      key: "getPublicReadAccess",
      value: function() {
        return this.getReadAccess(PUBLIC_KEY);
      }
    }, {
      key: "setPublicWriteAccess",
      value: function(allowed) {
        this.setWriteAccess(PUBLIC_KEY, allowed);
      }
    }, {
      key: "getPublicWriteAccess",
      value: function() {
        return this.getWriteAccess(PUBLIC_KEY);
      }
    }, {
      key: "setPublicProtectedFields",
      value: function(fields) {
        this.setProtectedFields(PUBLIC_KEY, fields);
      }
    }, {
      key: "getPublicProtectedFields",
      value: function() {
        return this.getProtectedFields(PUBLIC_KEY);
      }
    }, {
      key: "getRoleReadAccess",
      value: function(role) {
        return this.getReadAccess(this._getRoleName(role));
      }
    }, {
      key: "getRoleWriteAccess",
      value: function(role) {
        return this.getWriteAccess(this._getRoleName(role));
      }
    }, {
      key: "setRoleReadAccess",
      value: function(role, allowed) {
        this.setReadAccess(this._getRoleName(role), allowed);
      }
    }, {
      key: "setRoleWriteAccess",
      value: function(role, allowed) {
        this.setWriteAccess(this._getRoleName(role), allowed);
      }
    }, {
      key: "getRoleProtectedFields",
      value: function(role) {
        return this.getProtectedFields(this._getRoleName(role));
      }
    }, {
      key: "setRoleProtectedFields",
      value: function(role, fields) {
        this.setProtectedFields(this._getRoleName(role), fields);
      }
    }]);
    return ParseCLP3;
  }();
  var _default = ParseCLP2;
  exports.default = _default;
})(ParseCLP);
var ParseConfig = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _stringify2 = _interopRequireDefault2(stringify2);
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _promise2 = _interopRequireDefault2(promise$3);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _decode2 = _interopRequireDefault2(decode$2);
  var _encode2 = _interopRequireDefault2(encode);
  var _escape2 = _interopRequireDefault2(_escape);
  var _ParseError2 = _interopRequireDefault2(ParseError$1);
  var _Storage2 = _interopRequireDefault2(Storage_1);
  var ParseConfig2 = /* @__PURE__ */ function() {
    function ParseConfig3() {
      (0, _classCallCheck22.default)(this, ParseConfig3);
      (0, _defineProperty22.default)(this, "attributes", void 0);
      (0, _defineProperty22.default)(this, "_escapedAttributes", void 0);
      this.attributes = {};
      this._escapedAttributes = {};
    }
    (0, _createClass22.default)(ParseConfig3, [{
      key: "get",
      value: function(attr) {
        return this.attributes[attr];
      }
    }, {
      key: "escape",
      value: function(attr) {
        var html2 = this._escapedAttributes[attr];
        if (html2) {
          return html2;
        }
        var val = this.attributes[attr];
        var escaped = "";
        if (val != null) {
          escaped = (0, _escape2.default)(val.toString());
        }
        this._escapedAttributes[attr] = escaped;
        return escaped;
      }
    }], [{
      key: "current",
      value: function() {
        var controller = _CoreManager2.default.getConfigController();
        return controller.current();
      }
    }, {
      key: "get",
      value: function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var controller = _CoreManager2.default.getConfigController();
        return controller.get(options);
      }
    }, {
      key: "save",
      value: function(attrs, masterKeyOnlyFlags) {
        var controller = _CoreManager2.default.getConfigController();
        return controller.save(attrs, masterKeyOnlyFlags).then(function() {
          return controller.get({
            useMasterKey: true
          });
        }, function(error) {
          return _promise2.default.reject(error);
        });
      }
    }, {
      key: "_clearCache",
      value: function() {
        currentConfig = null;
      }
    }]);
    return ParseConfig3;
  }();
  var currentConfig = null;
  var CURRENT_CONFIG_KEY = "currentConfig";
  function decodePayload(data2) {
    try {
      var json = JSON.parse(data2);
      if (json && (0, _typeof22.default)(json) === "object") {
        return (0, _decode2.default)(json);
      }
    } catch (e2) {
      return null;
    }
  }
  var DefaultController = {
    current: function() {
      if (currentConfig) {
        return currentConfig;
      }
      var config2 = new ParseConfig2();
      var storagePath = _Storage2.default.generatePath(CURRENT_CONFIG_KEY);
      if (!_Storage2.default.async()) {
        var configData = _Storage2.default.getItem(storagePath);
        if (configData) {
          var attributes = decodePayload(configData);
          if (attributes) {
            config2.attributes = attributes;
            currentConfig = config2;
          }
        }
        return config2;
      }
      return _Storage2.default.getItemAsync(storagePath).then(function(configData2) {
        if (configData2) {
          var _attributes = decodePayload(configData2);
          if (_attributes) {
            config2.attributes = _attributes;
            currentConfig = config2;
          }
        }
        return config2;
      });
    },
    get: function() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("GET", "config", {}, options).then(function(response) {
        if (!response || !response.params) {
          var error = new _ParseError2.default(_ParseError2.default.INVALID_JSON, "Config JSON response invalid.");
          return _promise2.default.reject(error);
        }
        var config2 = new ParseConfig2();
        config2.attributes = {};
        for (var attr in response.params) {
          config2.attributes[attr] = (0, _decode2.default)(response.params[attr]);
        }
        currentConfig = config2;
        return _Storage2.default.setItemAsync(_Storage2.default.generatePath(CURRENT_CONFIG_KEY), (0, _stringify2.default)(response.params)).then(function() {
          return config2;
        });
      });
    },
    save: function(attrs, masterKeyOnlyFlags) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      var encodedAttrs = {};
      for (var _key in attrs) {
        encodedAttrs[_key] = (0, _encode2.default)(attrs[_key]);
      }
      return RESTController2.request("PUT", "config", {
        params: encodedAttrs,
        masterKeyOnly: masterKeyOnlyFlags
      }, {
        useMasterKey: true
      }).then(function(response) {
        if (response && response.result) {
          return _promise2.default.resolve();
        } else {
          var error = new _ParseError2.default(_ParseError2.default.INTERNAL_SERVER_ERROR, "Error occured updating Config.");
          return _promise2.default.reject(error);
        }
      });
    }
  };
  _CoreManager2.default.setConfigController(DefaultController);
  var _default = ParseConfig2;
  exports.default = _default;
})(ParseConfig);
var FacebookUtils = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ParseUser = _interopRequireDefault2(ParseUser);
  var initialized = false;
  var requestedPermissions;
  var initOptions;
  var provider = {
    authenticate: function(options) {
      var _this = this;
      if (typeof FB === "undefined") {
        options.error(this, "Facebook SDK not found.");
      }
      FB.login(function(response) {
        if (response.authResponse) {
          if (options.success) {
            options.success(_this, {
              id: response.authResponse.userID,
              access_token: response.authResponse.accessToken,
              expiration_date: new Date(response.authResponse.expiresIn * 1e3 + new Date().getTime()).toJSON()
            });
          }
        } else {
          if (options.error) {
            options.error(_this, response);
          }
        }
      }, {
        scope: requestedPermissions
      });
    },
    restoreAuthentication: function(authData) {
      if (authData) {
        var newOptions = {};
        if (initOptions) {
          for (var key in initOptions) {
            newOptions[key] = initOptions[key];
          }
        }
        newOptions.status = false;
        var existingResponse = FB.getAuthResponse();
        if (existingResponse && existingResponse.userID !== authData.id) {
          FB.logout();
        }
        FB.init(newOptions);
      }
      return true;
    },
    getAuthType: function() {
      return "facebook";
    },
    deauthenticate: function() {
      this.restoreAuthentication(null);
    }
  };
  var FacebookUtils2 = {
    init: function(options) {
      if (typeof FB === "undefined") {
        throw new Error("The Facebook JavaScript SDK must be loaded before calling init.");
      }
      initOptions = {};
      if (options) {
        for (var key in options) {
          initOptions[key] = options[key];
        }
      }
      if (initOptions.status && typeof console !== "undefined") {
        var warn2 = console.warn || console.log || function() {
        };
        warn2.call(console, 'The "status" flag passed into FB.init, when set to true, can interfere with Parse Facebook integration, so it has been suppressed. Please call FB.getLoginStatus() explicitly if you require this behavior.');
      }
      initOptions.status = false;
      FB.init(initOptions);
      _ParseUser.default._registerAuthenticationProvider(provider);
      initialized = true;
    },
    isLinked: function(user) {
      return user._isLinked("facebook");
    },
    logIn: function(permissions, options) {
      if (!permissions || typeof permissions === "string") {
        if (!initialized) {
          throw new Error("You must initialize FacebookUtils before calling logIn.");
        }
        requestedPermissions = permissions;
        return _ParseUser.default.logInWith("facebook", options);
      }
      return _ParseUser.default.logInWith("facebook", {
        authData: permissions
      }, options);
    },
    link: function(user, permissions, options) {
      if (!permissions || typeof permissions === "string") {
        if (!initialized) {
          throw new Error("You must initialize FacebookUtils before calling link.");
        }
        requestedPermissions = permissions;
        return user.linkWith("facebook", options);
      }
      return user.linkWith("facebook", {
        authData: permissions
      }, options);
    },
    unlink: function(user, options) {
      if (!initialized) {
        throw new Error("You must initialize FacebookUtils before calling unlink.");
      }
      return user._unlinkFrom("facebook", options);
    },
    _getAuthProvider: function() {
      return provider;
    }
  };
  var _default = FacebookUtils2;
  exports.default = _default;
})(FacebookUtils);
var ParseInstallation = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var Installation = /* @__PURE__ */ function(_ParseObject3) {
    (0, _inherits2.default)(Installation2, _ParseObject3);
    var _super = _createSuper(Installation2);
    function Installation2(attributes) {
      var _this;
      (0, _classCallCheck22.default)(this, Installation2);
      _this = _super.call(this, "_Installation");
      if (attributes && (0, _typeof22.default)(attributes) === "object") {
        if (!_this.set(attributes || {})) {
          throw new Error("Can't create an invalid Installation");
        }
      }
      return _this;
    }
    return Installation2;
  }(_ParseObject2.default);
  exports.default = Installation;
  _ParseObject2.default.registerSubclass("_Installation", Installation);
})(ParseInstallation);
var collection = collection$3;
var collectionStrong = collectionStrong$2;
collection("Set", function(init) {
  return function Set2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong);
var path = path$u;
var set$3 = path.Set;
var parent$2 = set$3;
var set$2 = parent$2;
var set$1 = set$2;
var global$1 = global$V;
var aCallable = aCallable$m;
var toObject = toObject$c;
var IndexedObject = indexedObject;
var lengthOfArrayLike = lengthOfArrayLike$a;
var TypeError$1 = global$1.TypeError;
var createMethod = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O = toObject(that);
    var self2 = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i2 = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i2;
          break;
        }
        index += i2;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError$1("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index >= 0 : length > index; index += i2)
      if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
    return memo;
  };
};
var arrayReduce = {
  left: createMethod(false),
  right: createMethod(true)
};
var $ = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict = arrayMethodIsStrict$5;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var STRICT_METHOD = arrayMethodIsStrict("reduce");
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
$({ target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
  reduce: function reduce2(callbackfn) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var entryVirtual$1 = entryVirtual$j;
var reduce$3 = entryVirtual$1("Array").reduce;
var isPrototypeOf$1 = objectIsPrototypeOf;
var method$1 = reduce$3;
var ArrayPrototype$1 = Array.prototype;
var reduce$2 = function(it) {
  var own = it.reduce;
  return it === ArrayPrototype$1 || isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.reduce ? method$1 : own;
};
var parent$1 = reduce$2;
var reduce$1 = parent$1;
var reduce3 = reduce$1;
var _interopRequireDefault$2 = interopRequireDefault.exports;
var _Array$isArray = isArray$4;
var _getIteratorMethod$1 = getIteratorMethod$1;
var _Symbol$1 = symbol;
var _Array$from = from$3;
var _sliceInstanceProperty$1 = slice$3;
var _map$1 = _interopRequireDefault$2(map$1);
var _promise$2 = _interopRequireDefault$2(promise$3);
var _reduce = _interopRequireDefault$2(reduce3);
var _stringify = _interopRequireDefault$2(stringify2);
var _regenerator$1 = _interopRequireDefault$2(regenerator);
var _asyncToGenerator2$1 = _interopRequireDefault$2(asyncToGenerator.exports);
var _LocalDatastoreUtils$1 = LocalDatastoreUtils;
var _Storage = _interopRequireDefault$2(Storage_1);
function _createForOfIteratorHelper$1(o2, allowArrayLike) {
  var it = typeof _Symbol$1 !== "undefined" && _getIteratorMethod$1(o2) || o2["@@iterator"];
  if (!it) {
    if (_Array$isArray(o2) || (it = _unsupportedIterableToArray$1(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o2);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _unsupportedIterableToArray$1(o2, minLen) {
  var _context7;
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = _sliceInstanceProperty$1(_context7 = Object.prototype.toString.call(o2)).call(_context7, 8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return _Array$from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var LocalDatastoreController = {
  fromPinWithName: function(name) {
    return (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee() {
      var values2, objects;
      return _regenerator$1.default.wrap(function(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _Storage.default.getItemAsync(name);
            case 2:
              values2 = _context.sent;
              if (values2) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return", []);
            case 5:
              objects = JSON.parse(values2);
              return _context.abrupt("return", objects);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  pinWithName: function(name, value) {
    var values2 = (0, _stringify.default)(value);
    return _Storage.default.setItemAsync(name, values2);
  },
  unPinWithName: function(name) {
    return _Storage.default.removeItemAsync(name);
  },
  getAllContents: function() {
    return (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee3() {
      var keys4;
      return _regenerator$1.default.wrap(function(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return _Storage.default.getAllKeysAsync();
            case 2:
              keys4 = _context3.sent;
              return _context3.abrupt("return", (0, _reduce.default)(keys4).call(keys4, /* @__PURE__ */ function() {
                var _ref = (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee2(previousPromise, key) {
                  var LDS, value;
                  return _regenerator$1.default.wrap(function(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return previousPromise;
                        case 2:
                          LDS = _context2.sent;
                          if (!(0, _LocalDatastoreUtils$1.isLocalDatastoreKey)(key)) {
                            _context2.next = 8;
                            break;
                          }
                          _context2.next = 6;
                          return _Storage.default.getItemAsync(key);
                        case 6:
                          value = _context2.sent;
                          try {
                            LDS[key] = JSON.parse(value);
                          } catch (error) {
                            console.error("Error getAllContents: ", error);
                          }
                        case 8:
                          return _context2.abrupt("return", LDS);
                        case 9:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }));
                return function() {
                  return _ref.apply(this, arguments);
                };
              }(), _promise$2.default.resolve({})));
            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }))();
  },
  getRawStorage: function() {
    return (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee5() {
      var keys4;
      return _regenerator$1.default.wrap(function(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return _Storage.default.getAllKeysAsync();
            case 2:
              keys4 = _context5.sent;
              return _context5.abrupt("return", (0, _reduce.default)(keys4).call(keys4, /* @__PURE__ */ function() {
                var _ref2 = (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee4(previousPromise, key) {
                  var LDS, value;
                  return _regenerator$1.default.wrap(function(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return previousPromise;
                        case 2:
                          LDS = _context4.sent;
                          _context4.next = 5;
                          return _Storage.default.getItemAsync(key);
                        case 5:
                          value = _context4.sent;
                          LDS[key] = value;
                          return _context4.abrupt("return", LDS);
                        case 8:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                return function() {
                  return _ref2.apply(this, arguments);
                };
              }(), _promise$2.default.resolve({})));
            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }))();
  },
  clear: function() {
    var _this = this;
    return (0, _asyncToGenerator2$1.default)(/* @__PURE__ */ _regenerator$1.default.mark(function _callee6() {
      var keys4, toRemove, _iterator, _step, key, promises;
      return _regenerator$1.default.wrap(function(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return _Storage.default.getAllKeysAsync();
            case 2:
              keys4 = _context6.sent;
              toRemove = [];
              _iterator = _createForOfIteratorHelper$1(keys4);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  key = _step.value;
                  if ((0, _LocalDatastoreUtils$1.isLocalDatastoreKey)(key)) {
                    toRemove.push(key);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              promises = (0, _map$1.default)(toRemove).call(toRemove, _this.unPinWithName);
              return _context6.abrupt("return", _promise$2.default.all(promises));
            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }))();
  }
};
var LocalDatastoreController_1 = LocalDatastoreController;
var _interopRequireDefault$1 = interopRequireDefault.exports;
var _Array$isArray2 = isArray$4;
var _getIteratorMethod = getIteratorMethod$1;
var _Symbol = symbol;
var _Array$from2 = from$3;
var _sliceInstanceProperty = slice$3;
var _find = _interopRequireDefault$1(find3);
var _from = _interopRequireDefault$1(from$3);
var _map = _interopRequireDefault$1(map$1);
var _isArray = _interopRequireDefault$1(isArray$4);
var _keys2 = _interopRequireDefault$1(keys$1);
var _startsWith = _interopRequireDefault$1(startsWith2);
var _keys3 = _interopRequireDefault$1(keys$5);
var _includes = _interopRequireDefault$1(includes4);
var _filter = _interopRequireDefault$1(filter3);
var _regenerator = _interopRequireDefault$1(regenerator);
var _concat = _interopRequireDefault$1(concat$1);
var _set = _interopRequireDefault$1(set$1);
var _toConsumableArray2 = _interopRequireDefault$1(toConsumableArray.exports);
var _promise$1 = _interopRequireDefault$1(promise$3);
var _slicedToArray2 = _interopRequireDefault$1(slicedToArray.exports);
var _asyncToGenerator2 = _interopRequireDefault$1(asyncToGenerator.exports);
var _CoreManager$1 = _interopRequireDefault$1(CoreManager);
var _ParseQuery = _interopRequireDefault$1(ParseQuery);
var _LocalDatastoreUtils = LocalDatastoreUtils;
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o2) || o2["@@iterator"];
  if (!it) {
    if (_Array$isArray2(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o2);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o2, minLen) {
  var _context18;
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = _sliceInstanceProperty(_context18 = Object.prototype.toString.call(o2)).call(_context18, 8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return _Array$from2(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var LocalDatastore = {
  isEnabled: false,
  isSyncing: false,
  fromPinWithName: function(name) {
    var controller = _CoreManager$1.default.getLocalDatastoreController();
    return controller.fromPinWithName(name);
  },
  pinWithName: function(name, value) {
    var controller = _CoreManager$1.default.getLocalDatastoreController();
    return controller.pinWithName(name, value);
  },
  unPinWithName: function(name) {
    var controller = _CoreManager$1.default.getLocalDatastoreController();
    return controller.unPinWithName(name);
  },
  _getAllContents: function() {
    var controller = _CoreManager$1.default.getLocalDatastoreController();
    return controller.getAllContents();
  },
  _getRawStorage: function() {
    var controller = _CoreManager$1.default.getLocalDatastoreController();
    return controller.getRawStorage();
  },
  _clear: function() {
    var controller = _CoreManager$1.default.getLocalDatastoreController();
    return controller.clear();
  },
  _handlePinAllWithName: function(name, objects) {
    var _this = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee() {
      var _context;
      var pinName, toPinPromises, objectKeys2, _iterator, _step, parent2, children, parentKey, json, objectKey, fromPinPromise, _yield$Promise$all, _yield$Promise$all2, pinned, toPin;
      return _regenerator.default.wrap(function(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              pinName = _this.getPinName(name);
              toPinPromises = [];
              objectKeys2 = [];
              _iterator = _createForOfIteratorHelper(objects);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  parent2 = _step.value;
                  children = _this._getChildren(parent2);
                  parentKey = _this.getKeyForObject(parent2);
                  json = parent2._toFullJSON(void 0, true);
                  if (parent2._localId) {
                    json._localId = parent2._localId;
                  }
                  children[parentKey] = json;
                  for (objectKey in children) {
                    objectKeys2.push(objectKey);
                    toPinPromises.push(_this.pinWithName(objectKey, [children[objectKey]]));
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              fromPinPromise = _this.fromPinWithName(pinName);
              _context2.next = 8;
              return _promise$1.default.all([fromPinPromise, toPinPromises]);
            case 8:
              _yield$Promise$all = _context2.sent;
              _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 1);
              pinned = _yield$Promise$all2[0];
              toPin = (0, _toConsumableArray2.default)(new _set.default((0, _concat.default)(_context = []).call(_context, (0, _toConsumableArray2.default)(pinned || []), objectKeys2)));
              return _context2.abrupt("return", _this.pinWithName(pinName, toPin));
            case 13:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee);
    }))();
  },
  _handleUnPinAllWithName: function(name, objects) {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2() {
      var localDatastore, pinName, promises, objectKeys2, _iterator2, _step2, _objectKeys, _context3, parent2, children, parentKey, pinned, _iterator3, _step3, objectKey, hasReference, key, pinnedObjects;
      return _regenerator.default.wrap(function(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return _this2._getAllContents();
            case 2:
              localDatastore = _context4.sent;
              pinName = _this2.getPinName(name);
              promises = [];
              objectKeys2 = [];
              _iterator2 = _createForOfIteratorHelper(objects);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  parent2 = _step2.value;
                  children = _this2._getChildren(parent2);
                  parentKey = _this2.getKeyForObject(parent2);
                  (_objectKeys = objectKeys2).push.apply(_objectKeys, (0, _concat.default)(_context3 = [parentKey]).call(_context3, (0, _toConsumableArray2.default)((0, _keys3.default)(children))));
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              objectKeys2 = (0, _toConsumableArray2.default)(new _set.default(objectKeys2));
              pinned = localDatastore[pinName] || [];
              pinned = (0, _filter.default)(pinned).call(pinned, function(item) {
                return !(0, _includes.default)(objectKeys2).call(objectKeys2, item);
              });
              if (pinned.length == 0) {
                promises.push(_this2.unPinWithName(pinName));
                delete localDatastore[pinName];
              } else {
                promises.push(_this2.pinWithName(pinName, pinned));
                localDatastore[pinName] = pinned;
              }
              _iterator3 = _createForOfIteratorHelper(objectKeys2);
              _context4.prev = 13;
              _iterator3.s();
            case 15:
              if ((_step3 = _iterator3.n()).done) {
                _context4.next = 31;
                break;
              }
              objectKey = _step3.value;
              hasReference = false;
              _context4.t0 = (0, _keys2.default)(_regenerator.default).call(_regenerator.default, localDatastore);
            case 19:
              if ((_context4.t1 = _context4.t0()).done) {
                _context4.next = 28;
                break;
              }
              key = _context4.t1.value;
              if (!(key === _LocalDatastoreUtils.DEFAULT_PIN || (0, _startsWith.default)(key).call(key, _LocalDatastoreUtils.PIN_PREFIX))) {
                _context4.next = 26;
                break;
              }
              pinnedObjects = localDatastore[key] || [];
              if (!(0, _includes.default)(pinnedObjects).call(pinnedObjects, objectKey)) {
                _context4.next = 26;
                break;
              }
              hasReference = true;
              return _context4.abrupt("break", 28);
            case 26:
              _context4.next = 19;
              break;
            case 28:
              if (!hasReference) {
                promises.push(_this2.unPinWithName(objectKey));
              }
            case 29:
              _context4.next = 15;
              break;
            case 31:
              _context4.next = 36;
              break;
            case 33:
              _context4.prev = 33;
              _context4.t2 = _context4["catch"](13);
              _iterator3.e(_context4.t2);
            case 36:
              _context4.prev = 36;
              _iterator3.f();
              return _context4.finish(36);
            case 39:
              return _context4.abrupt("return", _promise$1.default.all(promises));
            case 40:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee2, null, [[13, 33, 36, 39]]);
    }))();
  },
  _getChildren: function(object) {
    var encountered = {};
    var json = object._toFullJSON(void 0, true);
    for (var key in json) {
      if (json[key] && json[key].__type && json[key].__type === "Object") {
        this._traverse(json[key], encountered);
      }
    }
    return encountered;
  },
  _traverse: function(object, encountered) {
    if (!object.objectId) {
      return;
    } else {
      var objectKey = this.getKeyForObject(object);
      if (encountered[objectKey]) {
        return;
      }
      encountered[objectKey] = object;
    }
    for (var key in object) {
      var json = object[key];
      if (!object[key]) {
        json = object;
      }
      if (json.__type && json.__type === "Object") {
        this._traverse(json, encountered);
      }
    }
  },
  _serializeObjectsFromPinName: function(name) {
    var _this3 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee3() {
      var _context5, _concatInstanceProper, _context6;
      var localDatastore, allObjects, key, pinName, pinned, promises, objects;
      return _regenerator.default.wrap(function(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return _this3._getAllContents();
            case 2:
              localDatastore = _context7.sent;
              allObjects = [];
              for (key in localDatastore) {
                if ((0, _startsWith.default)(key).call(key, _LocalDatastoreUtils.OBJECT_PREFIX)) {
                  allObjects.push(localDatastore[key][0]);
                }
              }
              if (name) {
                _context7.next = 7;
                break;
              }
              return _context7.abrupt("return", allObjects);
            case 7:
              pinName = _this3.getPinName(name);
              pinned = localDatastore[pinName];
              if ((0, _isArray.default)(pinned)) {
                _context7.next = 11;
                break;
              }
              return _context7.abrupt("return", []);
            case 11:
              promises = (0, _map.default)(pinned).call(pinned, function(objectKey) {
                return _this3.fromPinWithName(objectKey);
              });
              _context7.next = 14;
              return _promise$1.default.all(promises);
            case 14:
              objects = _context7.sent;
              objects = (_concatInstanceProper = (0, _concat.default)(_context5 = [])).call.apply(_concatInstanceProper, (0, _concat.default)(_context6 = [_context5]).call(_context6, (0, _toConsumableArray2.default)(objects)));
              return _context7.abrupt("return", (0, _filter.default)(objects).call(objects, function(object) {
                return object != null;
              }));
            case 17:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee3);
    }))();
  },
  _serializeObject: function(objectKey, localDatastore) {
    var _this4 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee4() {
      var LDS, root, queue2, meta2, uniqueId, nodeId, subTreeRoot, field, value, key, pointer;
      return _regenerator.default.wrap(function(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              LDS = localDatastore;
              if (LDS) {
                _context8.next = 5;
                break;
              }
              _context8.next = 4;
              return _this4._getAllContents();
            case 4:
              LDS = _context8.sent;
            case 5:
              if (!(!LDS[objectKey] || LDS[objectKey].length === 0)) {
                _context8.next = 7;
                break;
              }
              return _context8.abrupt("return", null);
            case 7:
              root = LDS[objectKey][0];
              queue2 = [];
              meta2 = {};
              uniqueId = 0;
              meta2[uniqueId] = root;
              queue2.push(uniqueId);
              while (queue2.length !== 0) {
                nodeId = queue2.shift();
                subTreeRoot = meta2[nodeId];
                for (field in subTreeRoot) {
                  value = subTreeRoot[field];
                  if (value.__type && value.__type === "Object") {
                    key = _this4.getKeyForObject(value);
                    if (LDS[key] && LDS[key].length > 0) {
                      pointer = LDS[key][0];
                      uniqueId++;
                      meta2[uniqueId] = pointer;
                      subTreeRoot[field] = pointer;
                      queue2.push(uniqueId);
                    }
                  }
                }
              }
              return _context8.abrupt("return", root);
            case 15:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee4);
    }))();
  },
  _updateObjectIfPinned: function(object) {
    var _this5 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee5() {
      var objectKey, pinned;
      return _regenerator.default.wrap(function(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (_this5.isEnabled) {
                _context9.next = 2;
                break;
              }
              return _context9.abrupt("return");
            case 2:
              objectKey = _this5.getKeyForObject(object);
              _context9.next = 5;
              return _this5.fromPinWithName(objectKey);
            case 5:
              pinned = _context9.sent;
              if (!(!pinned || pinned.length === 0)) {
                _context9.next = 8;
                break;
              }
              return _context9.abrupt("return");
            case 8:
              return _context9.abrupt("return", _this5.pinWithName(objectKey, [object._toFullJSON()]));
            case 9:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee5);
    }))();
  },
  _destroyObjectIfPinned: function(object) {
    var _this6 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee6() {
      var localDatastore, objectKey, pin, promises, key, pinned;
      return _regenerator.default.wrap(function(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (_this6.isEnabled) {
                _context10.next = 2;
                break;
              }
              return _context10.abrupt("return");
            case 2:
              _context10.next = 4;
              return _this6._getAllContents();
            case 4:
              localDatastore = _context10.sent;
              objectKey = _this6.getKeyForObject(object);
              pin = localDatastore[objectKey];
              if (pin) {
                _context10.next = 9;
                break;
              }
              return _context10.abrupt("return");
            case 9:
              promises = [_this6.unPinWithName(objectKey)];
              delete localDatastore[objectKey];
              for (key in localDatastore) {
                if (key === _LocalDatastoreUtils.DEFAULT_PIN || (0, _startsWith.default)(key).call(key, _LocalDatastoreUtils.PIN_PREFIX)) {
                  pinned = localDatastore[key] || [];
                  if ((0, _includes.default)(pinned).call(pinned, objectKey)) {
                    pinned = (0, _filter.default)(pinned).call(pinned, function(item) {
                      return item !== objectKey;
                    });
                    if (pinned.length == 0) {
                      promises.push(_this6.unPinWithName(key));
                      delete localDatastore[key];
                    } else {
                      promises.push(_this6.pinWithName(key, pinned));
                      localDatastore[key] = pinned;
                    }
                  }
                }
              }
              return _context10.abrupt("return", _promise$1.default.all(promises));
            case 13:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee6);
    }))();
  },
  _updateLocalIdForObject: function(localId, object) {
    var _this7 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee7() {
      var _context11, _context12;
      var localKey, objectKey, unsaved, promises, localDatastore, key, pinned;
      return _regenerator.default.wrap(function(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (_this7.isEnabled) {
                _context13.next = 2;
                break;
              }
              return _context13.abrupt("return");
            case 2:
              localKey = (0, _concat.default)(_context11 = (0, _concat.default)(_context12 = "".concat(_LocalDatastoreUtils.OBJECT_PREFIX)).call(_context12, object.className, "_")).call(_context11, localId);
              objectKey = _this7.getKeyForObject(object);
              _context13.next = 6;
              return _this7.fromPinWithName(localKey);
            case 6:
              unsaved = _context13.sent;
              if (!(!unsaved || unsaved.length === 0)) {
                _context13.next = 9;
                break;
              }
              return _context13.abrupt("return");
            case 9:
              promises = [_this7.unPinWithName(localKey), _this7.pinWithName(objectKey, unsaved)];
              _context13.next = 12;
              return _this7._getAllContents();
            case 12:
              localDatastore = _context13.sent;
              for (key in localDatastore) {
                if (key === _LocalDatastoreUtils.DEFAULT_PIN || (0, _startsWith.default)(key).call(key, _LocalDatastoreUtils.PIN_PREFIX)) {
                  pinned = localDatastore[key] || [];
                  if ((0, _includes.default)(pinned).call(pinned, localKey)) {
                    pinned = (0, _filter.default)(pinned).call(pinned, function(item) {
                      return item !== localKey;
                    });
                    pinned.push(objectKey);
                    promises.push(_this7.pinWithName(key, pinned));
                    localDatastore[key] = pinned;
                  }
                }
              }
              return _context13.abrupt("return", _promise$1.default.all(promises));
            case 15:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee7);
    }))();
  },
  updateFromServer: function() {
    var _this8 = this;
    return (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee8() {
      var _context14;
      var localDatastore, keys4, key, pointersHash, _i, _keys4, _key, _key$split, _key$split2, className, objectId, queryPromises, responses, objects, pinPromises;
      return _regenerator.default.wrap(function(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (!(!_this8.checkIfEnabled() || _this8.isSyncing)) {
                _context15.next = 2;
                break;
              }
              return _context15.abrupt("return");
            case 2:
              _context15.next = 4;
              return _this8._getAllContents();
            case 4:
              localDatastore = _context15.sent;
              keys4 = [];
              for (key in localDatastore) {
                if ((0, _startsWith.default)(key).call(key, _LocalDatastoreUtils.OBJECT_PREFIX)) {
                  keys4.push(key);
                }
              }
              if (!(keys4.length === 0)) {
                _context15.next = 9;
                break;
              }
              return _context15.abrupt("return");
            case 9:
              _this8.isSyncing = true;
              pointersHash = {};
              _i = 0, _keys4 = keys4;
            case 12:
              if (!(_i < _keys4.length)) {
                _context15.next = 23;
                break;
              }
              _key = _keys4[_i];
              _key$split = _key.split("_"), _key$split2 = (0, _slicedToArray2.default)(_key$split, 4), className = _key$split2[2], objectId = _key$split2[3];
              if (_key.split("_").length === 5 && _key.split("_")[3] === "User") {
                className = "_User";
                objectId = _key.split("_")[4];
              }
              if (!(0, _startsWith.default)(objectId).call(objectId, "local")) {
                _context15.next = 18;
                break;
              }
              return _context15.abrupt("continue", 20);
            case 18:
              if (!(className in pointersHash)) {
                pointersHash[className] = new _set.default();
              }
              pointersHash[className].add(objectId);
            case 20:
              _i++;
              _context15.next = 12;
              break;
            case 23:
              queryPromises = (0, _map.default)(_context14 = (0, _keys3.default)(pointersHash)).call(_context14, function(className2) {
                var objectIds = (0, _from.default)(pointersHash[className2]);
                var query = new _ParseQuery.default(className2);
                query.limit(objectIds.length);
                if (objectIds.length === 1) {
                  query.equalTo("objectId", objectIds[0]);
                } else {
                  query.containedIn("objectId", objectIds);
                }
                return (0, _find.default)(query).call(query);
              });
              _context15.prev = 24;
              _context15.next = 27;
              return _promise$1.default.all(queryPromises);
            case 27:
              responses = _context15.sent;
              objects = (0, _concat.default)([]).apply([], responses);
              pinPromises = (0, _map.default)(objects).call(objects, function(object) {
                var objectKey = _this8.getKeyForObject(object);
                return _this8.pinWithName(objectKey, object._toFullJSON());
              });
              _context15.next = 32;
              return _promise$1.default.all(pinPromises);
            case 32:
              _this8.isSyncing = false;
              _context15.next = 39;
              break;
            case 35:
              _context15.prev = 35;
              _context15.t0 = _context15["catch"](24);
              console.error("Error syncing LocalDatastore: ", _context15.t0);
              _this8.isSyncing = false;
            case 39:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee8, null, [[24, 35]]);
    }))();
  },
  getKeyForObject: function(object) {
    var _context16, _context17;
    var objectId = object.objectId || object._getId();
    return (0, _concat.default)(_context16 = (0, _concat.default)(_context17 = "".concat(_LocalDatastoreUtils.OBJECT_PREFIX)).call(_context17, object.className, "_")).call(_context16, objectId);
  },
  getPinName: function(pinName) {
    if (!pinName || pinName === _LocalDatastoreUtils.DEFAULT_PIN) {
      return _LocalDatastoreUtils.DEFAULT_PIN;
    }
    return _LocalDatastoreUtils.PIN_PREFIX + pinName;
  },
  checkIfEnabled: function() {
    if (!this.isEnabled) {
      console.error("Parse.enableLocalDatastore() must be called first");
    }
    return this.isEnabled;
  }
};
var LocalDatastore_1 = LocalDatastore;
_CoreManager$1.default.setLocalDatastoreController(LocalDatastoreController_1);
_CoreManager$1.default.setLocalDatastore(LocalDatastore);
var Push = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.getPushStatus = getPushStatus;
  exports.send = send;
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _ParseQuery2 = _interopRequireDefault2(ParseQuery);
  function send(data2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (data2.where && data2.where instanceof _ParseQuery2.default) {
      data2.where = data2.where.toJSON().where;
    }
    if (data2.push_time && (0, _typeof22.default)(data2.push_time) === "object") {
      data2.push_time = data2.push_time.toJSON();
    }
    if (data2.expiration_time && (0, _typeof22.default)(data2.expiration_time) === "object") {
      data2.expiration_time = data2.expiration_time.toJSON();
    }
    if (data2.expiration_time && data2.expiration_interval) {
      throw new Error("expiration_time and expiration_interval cannot both be set.");
    }
    var pushOptions = {
      useMasterKey: true
    };
    if (options.hasOwnProperty("useMasterKey")) {
      pushOptions.useMasterKey = options.useMasterKey;
    }
    return _CoreManager2.default.getPushController().send(data2, pushOptions);
  }
  function getPushStatus(pushStatusId) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var pushOptions = {
      useMasterKey: true
    };
    if (options.hasOwnProperty("useMasterKey")) {
      pushOptions.useMasterKey = options.useMasterKey;
    }
    var query = new _ParseQuery2.default("_PushStatus");
    return query.get(pushStatusId, pushOptions);
  }
  var DefaultController = {
    send: function(data2, options) {
      return _CoreManager2.default.getRESTController().request("POST", "push", data2, options);
    }
  };
  _CoreManager2.default.setPushController(DefaultController);
})(Push);
var ParseSchema = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _ParseCLP = _interopRequireDefault2(ParseCLP);
  var FIELD_TYPES = ["String", "Number", "Boolean", "Date", "File", "GeoPoint", "Polygon", "Array", "Object", "Pointer", "Relation"];
  var ParseSchema2 = /* @__PURE__ */ function() {
    function ParseSchema3(className) {
      (0, _classCallCheck22.default)(this, ParseSchema3);
      (0, _defineProperty22.default)(this, "className", void 0);
      (0, _defineProperty22.default)(this, "_fields", void 0);
      (0, _defineProperty22.default)(this, "_indexes", void 0);
      (0, _defineProperty22.default)(this, "_clp", void 0);
      if (typeof className === "string") {
        if (className === "User" && _CoreManager2.default.get("PERFORM_USER_REWRITE")) {
          this.className = "_User";
        } else {
          this.className = className;
        }
      }
      this._fields = {};
      this._indexes = {};
    }
    (0, _createClass22.default)(ParseSchema3, [{
      key: "get",
      value: function() {
        this.assertClassName();
        var controller = _CoreManager2.default.getSchemaController();
        return controller.get(this.className).then(function(response) {
          if (!response) {
            throw new Error("Schema not found.");
          }
          return response;
        });
      }
    }, {
      key: "save",
      value: function() {
        this.assertClassName();
        var controller = _CoreManager2.default.getSchemaController();
        var params = {
          className: this.className,
          fields: this._fields,
          indexes: this._indexes,
          classLevelPermissions: this._clp
        };
        return controller.create(this.className, params);
      }
    }, {
      key: "update",
      value: function() {
        this.assertClassName();
        var controller = _CoreManager2.default.getSchemaController();
        var params = {
          className: this.className,
          fields: this._fields,
          indexes: this._indexes,
          classLevelPermissions: this._clp
        };
        this._fields = {};
        this._indexes = {};
        return controller.update(this.className, params);
      }
    }, {
      key: "delete",
      value: function() {
        this.assertClassName();
        var controller = _CoreManager2.default.getSchemaController();
        return controller.delete(this.className);
      }
    }, {
      key: "purge",
      value: function() {
        this.assertClassName();
        var controller = _CoreManager2.default.getSchemaController();
        return controller.purge(this.className);
      }
    }, {
      key: "assertClassName",
      value: function() {
        if (!this.className) {
          throw new Error("You must set a Class Name before making any request.");
        }
      }
    }, {
      key: "setCLP",
      value: function(clp) {
        if (clp instanceof _ParseCLP.default) {
          this._clp = clp.toJSON();
        } else {
          this._clp = clp;
        }
        return this;
      }
    }, {
      key: "addField",
      value: function(name, type) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        type = type || "String";
        if (!name) {
          throw new Error("field name may not be null.");
        }
        if ((0, _indexOf2.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {
          throw new Error("".concat(type, " is not a valid type."));
        }
        if (type === "Pointer") {
          return this.addPointer(name, options.targetClass, options);
        }
        if (type === "Relation") {
          return this.addRelation(name, options.targetClass, options);
        }
        var fieldOptions = {
          type
        };
        if (typeof options.required === "boolean") {
          fieldOptions.required = options.required;
        }
        if (options.defaultValue !== void 0) {
          fieldOptions.defaultValue = options.defaultValue;
        }
        this._fields[name] = fieldOptions;
        return this;
      }
    }, {
      key: "addIndex",
      value: function(name, index) {
        if (!name) {
          throw new Error("index name may not be null.");
        }
        if (!index) {
          throw new Error("index may not be null.");
        }
        this._indexes[name] = index;
        return this;
      }
    }, {
      key: "addString",
      value: function(name, options) {
        return this.addField(name, "String", options);
      }
    }, {
      key: "addNumber",
      value: function(name, options) {
        return this.addField(name, "Number", options);
      }
    }, {
      key: "addBoolean",
      value: function(name, options) {
        return this.addField(name, "Boolean", options);
      }
    }, {
      key: "addDate",
      value: function(name, options) {
        if (options && options.defaultValue) {
          options.defaultValue = {
            __type: "Date",
            iso: new Date(options.defaultValue)
          };
        }
        return this.addField(name, "Date", options);
      }
    }, {
      key: "addFile",
      value: function(name, options) {
        return this.addField(name, "File", options);
      }
    }, {
      key: "addGeoPoint",
      value: function(name, options) {
        return this.addField(name, "GeoPoint", options);
      }
    }, {
      key: "addPolygon",
      value: function(name, options) {
        return this.addField(name, "Polygon", options);
      }
    }, {
      key: "addArray",
      value: function(name, options) {
        return this.addField(name, "Array", options);
      }
    }, {
      key: "addObject",
      value: function(name, options) {
        return this.addField(name, "Object", options);
      }
    }, {
      key: "addPointer",
      value: function(name, targetClass) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (!name) {
          throw new Error("field name may not be null.");
        }
        if (!targetClass) {
          throw new Error("You need to set the targetClass of the Pointer.");
        }
        var fieldOptions = {
          type: "Pointer",
          targetClass
        };
        if (typeof options.required === "boolean") {
          fieldOptions.required = options.required;
        }
        if (options.defaultValue !== void 0) {
          fieldOptions.defaultValue = options.defaultValue;
          if (options.defaultValue instanceof _ParseObject2.default) {
            fieldOptions.defaultValue = options.defaultValue.toPointer();
          }
        }
        this._fields[name] = fieldOptions;
        return this;
      }
    }, {
      key: "addRelation",
      value: function(name, targetClass) {
        if (!name) {
          throw new Error("field name may not be null.");
        }
        if (!targetClass) {
          throw new Error("You need to set the targetClass of the Relation.");
        }
        this._fields[name] = {
          type: "Relation",
          targetClass
        };
        return this;
      }
    }, {
      key: "deleteField",
      value: function(name) {
        this._fields[name] = {
          __op: "Delete"
        };
        return this;
      }
    }, {
      key: "deleteIndex",
      value: function(name) {
        this._indexes[name] = {
          __op: "Delete"
        };
        return this;
      }
    }], [{
      key: "all",
      value: function() {
        var controller = _CoreManager2.default.getSchemaController();
        return controller.get("").then(function(response) {
          if (response.results.length === 0) {
            throw new Error("Schema not found.");
          }
          return response.results;
        });
      }
    }]);
    return ParseSchema3;
  }();
  var DefaultController = {
    send: function(className, method2) {
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request(method2, "schemas/".concat(className), params, {
        useMasterKey: true
      });
    },
    get: function(className) {
      return this.send(className, "GET");
    },
    create: function(className, params) {
      return this.send(className, "POST", params);
    },
    update: function(className, params) {
      return this.send(className, "PUT", params);
    },
    delete: function(className) {
      return this.send(className, "DELETE");
    },
    purge: function(className) {
      var RESTController2 = _CoreManager2.default.getRESTController();
      return RESTController2.request("DELETE", "purge/".concat(className), {}, {
        useMasterKey: true
      });
    }
  };
  _CoreManager2.default.setSchemaController(DefaultController);
  var _default = ParseSchema2;
  exports.default = _default;
})(ParseSchema);
var ParseLiveQuery = {};
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener2) {
  if (typeof listener2 !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener2);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener2, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener2);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener2.listener ? listener2.listener : listener2);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener2;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener2, existing] : [existing, listener2];
    } else if (prepend) {
      existing.unshift(listener2);
    } else {
      existing.push(listener2);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener2) {
  return _addListener(this, type, listener2, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener2) {
  return _addListener(this, type, listener2, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener2) {
  var state = { fired: false, wrapFn: void 0, target, type, listener: listener2 };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener2;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener2) {
  checkListener(listener2);
  this.on(type, _onceWrap(this, type, listener2));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener2) {
  checkListener(listener2);
  this.prependListener(type, _onceWrap(this, type, listener2));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener2) {
  var list, events2, position, i2, originalListener;
  checkListener(listener2);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener2 || list.listener === listener2) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener2);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener2 || list[i2].listener === listener2) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener2);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys4 = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys4.length; ++i2) {
      key = keys4[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n2) {
  var copy = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy[i2] = arr[i2];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve3, reject2) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject2(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve3([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener2, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener2);
    } else {
      emitter.on(name, listener2);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener2(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var EventEmitter_1 = events.exports.EventEmitter;
var LiveQueryClient = {};
var bind2 = bind$5;
var entryVirtual = entryVirtual$j;
var values$4 = entryVirtual("Array").values;
var parent = values$4;
var values$3 = parent;
var classof = classof$d;
var hasOwn2 = hasOwnProperty_1;
var isPrototypeOf = objectIsPrototypeOf;
var method = values$3;
var ArrayPrototype = Array.prototype;
var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};
var values$2 = function(it) {
  var own = it.values;
  return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.values || hasOwn2(DOMIterables, classof(it)) ? method : own;
};
var values$1 = values$2;
var LiveQuerySubscription = {};
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _EventEmitter2 = _interopRequireDefault2(EventEmitter_1);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _promiseUtils2 = promiseUtils;
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var Subscription = /* @__PURE__ */ function(_EventEmitter) {
    (0, _inherits2.default)(Subscription2, _EventEmitter);
    var _super = _createSuper(Subscription2);
    function Subscription2(id2, query, sessionToken) {
      var _this;
      (0, _classCallCheck22.default)(this, Subscription2);
      _this = _super.call(this);
      _this.id = id2;
      _this.query = query;
      _this.sessionToken = sessionToken;
      _this.subscribePromise = (0, _promiseUtils2.resolvingPromise)();
      _this.subscribed = false;
      _this.on("error", function() {
      });
      return _this;
    }
    (0, _createClass22.default)(Subscription2, [{
      key: "unsubscribe",
      value: function() {
        var _this2 = this;
        return _CoreManager2.default.getLiveQueryController().getDefaultLiveQueryClient().then(function(liveQueryClient) {
          liveQueryClient.unsubscribe(_this2);
          _this2.emit("close");
        });
      }
    }]);
    return Subscription2;
  }(_EventEmitter2.default);
  var _default = Subscription;
  exports.default = _default;
})(LiveQuerySubscription);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  var _Array$isArray3 = isArray$4;
  var _getIteratorMethod2 = getIteratorMethod$1;
  var _Symbol2 = symbol;
  var _Array$from3 = from$3;
  var _sliceInstanceProperty3 = slice$3;
  var _Reflect$construct = construct$4;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _typeof22 = _interopRequireDefault2(_typeof$1.exports);
  var _bind = _interopRequireDefault2(bind2);
  var _setTimeout22 = _interopRequireDefault2(setTimeout$1);
  var _values = _interopRequireDefault2(values$1);
  var _forEach2 = _interopRequireDefault2(forEach2);
  var _stringify2 = _interopRequireDefault2(stringify2);
  var _keys4 = _interopRequireDefault2(keys$1);
  var _map2 = _interopRequireDefault2(map2);
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _classCallCheck22 = _interopRequireDefault2(classCallCheck.exports);
  var _createClass22 = _interopRequireDefault2(createClass.exports);
  var _assertThisInitialized2 = _interopRequireDefault2(assertThisInitialized.exports);
  var _inherits2 = _interopRequireDefault2(inherits.exports);
  var _possibleConstructorReturn2 = _interopRequireDefault2(possibleConstructorReturn.exports);
  var _getPrototypeOf2 = _interopRequireDefault2(getPrototypeOf$6.exports);
  var _defineProperty22 = _interopRequireDefault2(defineProperty$2.exports);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  var _EventEmitter2 = _interopRequireDefault2(EventEmitter_1);
  var _ParseObject2 = _interopRequireDefault2(ParseObject);
  var _LiveQuerySubscription = _interopRequireDefault2(LiveQuerySubscription);
  var _promiseUtils2 = promiseUtils;
  function _createForOfIteratorHelper2(o2, allowArrayLike) {
    var it = typeof _Symbol2 !== "undefined" && _getIteratorMethod2(o2) || o2["@@iterator"];
    if (!it) {
      if (_Array$isArray3(o2) || (it = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
        if (it)
          o2 = it;
        var i2 = 0;
        var F = function() {
        };
        return {
          s: F,
          n: function() {
            if (i2 >= o2.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o2[i2++]
            };
          },
          e: function(_e) {
            throw _e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
      s: function() {
        it = it.call(o2);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      }
    };
  }
  function _unsupportedIterableToArray2(o2, minLen) {
    var _context6;
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray2(o2, minLen);
    var n2 = _sliceInstanceProperty3(_context6 = Object.prototype.toString.call(o2)).call(_context6, 8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return _Array$from3(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o2, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function() {
      var Super = (0, _getPrototypeOf2.default)(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
        result = _Reflect$construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2.default)(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !_Reflect$construct)
      return false;
    if (_Reflect$construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  var CLIENT_STATE = {
    INITIALIZED: "initialized",
    CONNECTING: "connecting",
    CONNECTED: "connected",
    CLOSED: "closed",
    RECONNECTING: "reconnecting",
    DISCONNECTED: "disconnected"
  };
  var OP_TYPES = {
    CONNECT: "connect",
    SUBSCRIBE: "subscribe",
    UNSUBSCRIBE: "unsubscribe",
    ERROR: "error"
  };
  var OP_EVENTS = {
    CONNECTED: "connected",
    SUBSCRIBED: "subscribed",
    UNSUBSCRIBED: "unsubscribed",
    ERROR: "error",
    CREATE: "create",
    UPDATE: "update",
    ENTER: "enter",
    LEAVE: "leave",
    DELETE: "delete"
  };
  var CLIENT_EMMITER_TYPES = {
    CLOSE: "close",
    ERROR: "error",
    OPEN: "open"
  };
  var SUBSCRIPTION_EMMITER_TYPES = {
    OPEN: "open",
    CLOSE: "close",
    ERROR: "error",
    CREATE: "create",
    UPDATE: "update",
    ENTER: "enter",
    LEAVE: "leave",
    DELETE: "delete"
  };
  var generateInterval = function(k) {
    return Math.random() * Math.min(30, Math.pow(2, k) - 1) * 1e3;
  };
  var LiveQueryClient2 = /* @__PURE__ */ function(_EventEmitter) {
    (0, _inherits2.default)(LiveQueryClient3, _EventEmitter);
    var _super = _createSuper(LiveQueryClient3);
    function LiveQueryClient3(_ref) {
      var _this;
      var applicationId = _ref.applicationId, serverURL = _ref.serverURL, javascriptKey = _ref.javascriptKey, masterKey = _ref.masterKey, sessionToken = _ref.sessionToken, installationId = _ref.installationId;
      (0, _classCallCheck22.default)(this, LiveQueryClient3);
      _this = _super.call(this);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "attempts", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "id", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "requestId", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "applicationId", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "serverURL", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "javascriptKey", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "masterKey", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "sessionToken", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "installationId", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "additionalProperties", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "connectPromise", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "subscriptions", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "socket", void 0);
      (0, _defineProperty22.default)((0, _assertThisInitialized2.default)(_this), "state", void 0);
      if (!serverURL || (0, _indexOf2.default)(serverURL).call(serverURL, "ws") !== 0) {
        throw new Error("You need to set a proper Parse LiveQuery server url before using LiveQueryClient");
      }
      _this.reconnectHandle = null;
      _this.attempts = 1;
      _this.id = 0;
      _this.requestId = 1;
      _this.serverURL = serverURL;
      _this.applicationId = applicationId;
      _this.javascriptKey = javascriptKey || void 0;
      _this.masterKey = masterKey || void 0;
      _this.sessionToken = sessionToken || void 0;
      _this.installationId = installationId || void 0;
      _this.additionalProperties = true;
      _this.connectPromise = (0, _promiseUtils2.resolvingPromise)();
      _this.subscriptions = new _map2.default();
      _this.state = CLIENT_STATE.INITIALIZED;
      _this.on("error", function() {
      });
      return _this;
    }
    (0, _createClass22.default)(LiveQueryClient3, [{
      key: "shouldOpen",
      value: function() {
        return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;
      }
    }, {
      key: "subscribe",
      value: function(query, sessionToken) {
        var _this2 = this;
        if (!query) {
          return;
        }
        var className = query.className;
        var queryJSON = query.toJSON();
        var where = queryJSON.where;
        var fields = (0, _keys4.default)(queryJSON) ? (0, _keys4.default)(queryJSON).split(",") : void 0;
        var subscribeRequest = {
          op: OP_TYPES.SUBSCRIBE,
          requestId: this.requestId,
          query: {
            className,
            where,
            fields
          }
        };
        if (sessionToken) {
          subscribeRequest.sessionToken = sessionToken;
        }
        var subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken);
        this.subscriptions.set(this.requestId, subscription);
        this.requestId += 1;
        this.connectPromise.then(function() {
          _this2.socket.send((0, _stringify2.default)(subscribeRequest));
        });
        return subscription;
      }
    }, {
      key: "unsubscribe",
      value: function(subscription) {
        var _this3 = this;
        if (!subscription) {
          return;
        }
        this.subscriptions.delete(subscription.id);
        var unsubscribeRequest = {
          op: OP_TYPES.UNSUBSCRIBE,
          requestId: subscription.id
        };
        this.connectPromise.then(function() {
          _this3.socket.send((0, _stringify2.default)(unsubscribeRequest));
        });
      }
    }, {
      key: "open",
      value: function() {
        var _this4 = this;
        var WebSocketImplementation = _CoreManager2.default.getWebSocketController();
        if (!WebSocketImplementation) {
          this.emit(CLIENT_EMMITER_TYPES.ERROR, "Can not find WebSocket implementation");
          return;
        }
        if (this.state !== CLIENT_STATE.RECONNECTING) {
          this.state = CLIENT_STATE.CONNECTING;
        }
        this.socket = new WebSocketImplementation(this.serverURL);
        this.socket.onopen = function() {
          _this4._handleWebSocketOpen();
        };
        this.socket.onmessage = function(event) {
          _this4._handleWebSocketMessage(event);
        };
        this.socket.onclose = function() {
          _this4._handleWebSocketClose();
        };
        this.socket.onerror = function(error) {
          _this4._handleWebSocketError(error);
        };
      }
    }, {
      key: "resubscribe",
      value: function() {
        var _context, _this5 = this;
        (0, _forEach2.default)(_context = this.subscriptions).call(_context, function(subscription, requestId) {
          var query = subscription.query;
          var queryJSON = query.toJSON();
          var where = queryJSON.where;
          var fields = (0, _keys4.default)(queryJSON) ? (0, _keys4.default)(queryJSON).split(",") : void 0;
          var className = query.className;
          var sessionToken = subscription.sessionToken;
          var subscribeRequest = {
            op: OP_TYPES.SUBSCRIBE,
            requestId,
            query: {
              className,
              where,
              fields
            }
          };
          if (sessionToken) {
            subscribeRequest.sessionToken = sessionToken;
          }
          _this5.connectPromise.then(function() {
            _this5.socket.send((0, _stringify2.default)(subscribeRequest));
          });
        });
      }
    }, {
      key: "close",
      value: function() {
        var _context2;
        if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {
          return;
        }
        this.state = CLIENT_STATE.DISCONNECTED;
        this.socket.close();
        var _iterator = _createForOfIteratorHelper2((0, _values.default)(_context2 = this.subscriptions).call(_context2)), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var subscription = _step.value;
            subscription.subscribed = false;
            subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this._handleReset();
        this.emit(CLIENT_EMMITER_TYPES.CLOSE);
      }
    }, {
      key: "_handleReset",
      value: function() {
        this.attempts = 1;
        this.id = 0;
        this.requestId = 1;
        this.connectPromise = (0, _promiseUtils2.resolvingPromise)();
        this.subscriptions = new _map2.default();
      }
    }, {
      key: "_handleWebSocketOpen",
      value: function() {
        this.attempts = 1;
        var connectRequest = {
          op: OP_TYPES.CONNECT,
          applicationId: this.applicationId,
          javascriptKey: this.javascriptKey,
          masterKey: this.masterKey,
          sessionToken: this.sessionToken
        };
        if (this.additionalProperties) {
          connectRequest.installationId = this.installationId;
        }
        this.socket.send((0, _stringify2.default)(connectRequest));
      }
    }, {
      key: "_handleWebSocketMessage",
      value: function(event) {
        var data2 = event.data;
        if (typeof data2 === "string") {
          data2 = JSON.parse(data2);
        }
        var subscription = null;
        if (data2.requestId) {
          subscription = this.subscriptions.get(data2.requestId);
        }
        var response = {
          clientId: data2.clientId,
          installationId: data2.installationId
        };
        switch (data2.op) {
          case OP_EVENTS.CONNECTED:
            if (this.state === CLIENT_STATE.RECONNECTING) {
              this.resubscribe();
            }
            this.emit(CLIENT_EMMITER_TYPES.OPEN);
            this.id = data2.clientId;
            this.connectPromise.resolve();
            this.state = CLIENT_STATE.CONNECTED;
            break;
          case OP_EVENTS.SUBSCRIBED:
            if (subscription) {
              subscription.subscribed = true;
              subscription.subscribePromise.resolve();
              (0, _setTimeout22.default)(function() {
                return subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN, response);
              }, 200);
            }
            break;
          case OP_EVENTS.ERROR:
            if (data2.requestId) {
              if (subscription) {
                subscription.subscribePromise.resolve();
                (0, _setTimeout22.default)(function() {
                  return subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data2.error);
                }, 200);
              }
            } else {
              this.emit(CLIENT_EMMITER_TYPES.ERROR, data2.error);
            }
            if (data2.error === "Additional properties not allowed") {
              this.additionalProperties = false;
            }
            if (data2.reconnect) {
              this._handleReconnect();
            }
            break;
          case OP_EVENTS.UNSUBSCRIBED:
            break;
          default: {
            if (!subscription) {
              break;
            }
            var override = false;
            if (data2.original) {
              override = true;
              delete data2.original.__type;
              for (var field in data2.original) {
                if (!(field in data2.object)) {
                  data2.object[field] = void 0;
                }
              }
              data2.original = _ParseObject2.default.fromJSON(data2.original, false);
            }
            delete data2.object.__type;
            var parseObject = _ParseObject2.default.fromJSON(data2.object, override);
            if (data2.original) {
              subscription.emit(data2.op, parseObject, data2.original, response);
            } else {
              subscription.emit(data2.op, parseObject, response);
            }
            var localDatastore = _CoreManager2.default.getLocalDatastore();
            if (override && localDatastore.isEnabled) {
              localDatastore._updateObjectIfPinned(parseObject).then(function() {
              });
            }
          }
        }
      }
    }, {
      key: "_handleWebSocketClose",
      value: function() {
        var _context3;
        if (this.state === CLIENT_STATE.DISCONNECTED) {
          return;
        }
        this.state = CLIENT_STATE.CLOSED;
        this.emit(CLIENT_EMMITER_TYPES.CLOSE);
        var _iterator2 = _createForOfIteratorHelper2((0, _values.default)(_context3 = this.subscriptions).call(_context3)), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var subscription = _step2.value;
            subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this._handleReconnect();
      }
    }, {
      key: "_handleWebSocketError",
      value: function(error) {
        var _context4;
        this.emit(CLIENT_EMMITER_TYPES.ERROR, error);
        var _iterator3 = _createForOfIteratorHelper2((0, _values.default)(_context4 = this.subscriptions).call(_context4)), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var subscription = _step3.value;
            subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        this._handleReconnect();
      }
    }, {
      key: "_handleReconnect",
      value: function() {
        var _context5, _this6 = this;
        if (this.state === CLIENT_STATE.DISCONNECTED) {
          return;
        }
        this.state = CLIENT_STATE.RECONNECTING;
        var time = generateInterval(this.attempts);
        if (this.reconnectHandle) {
          clearTimeout(this.reconnectHandle);
        }
        this.reconnectHandle = (0, _setTimeout22.default)((0, _bind.default)(_context5 = function() {
          _this6.attempts++;
          _this6.connectPromise = (0, _promiseUtils2.resolvingPromise)();
          _this6.open();
        }).call(_context5, this), time);
      }
    }]);
    return LiveQueryClient3;
  }(_EventEmitter2.default);
  _CoreManager2.default.setWebSocketController(typeof WebSocket === "function" || (typeof WebSocket === "undefined" ? "undefined" : (0, _typeof22.default)(WebSocket)) === "object" ? WebSocket : null);
  var _default = LiveQueryClient2;
  exports.default = _default;
})(LiveQueryClient);
(function(exports) {
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _Object$defineProperty2 = defineProperty$a;
  _Object$defineProperty2(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _indexOf2 = _interopRequireDefault2(indexOf2);
  var _promise2 = _interopRequireDefault2(promise$3);
  var _slicedToArray22 = _interopRequireDefault2(slicedToArray.exports);
  var _regenerator2 = _interopRequireDefault2(regenerator);
  var _asyncToGenerator22 = _interopRequireDefault2(asyncToGenerator.exports);
  var _EventEmitter = _interopRequireDefault2(EventEmitter_1);
  var _LiveQueryClient = _interopRequireDefault2(LiveQueryClient);
  var _CoreManager2 = _interopRequireDefault2(CoreManager);
  function getLiveQueryClient() {
    return _CoreManager2.default.getLiveQueryController().getDefaultLiveQueryClient();
  }
  var LiveQuery = new _EventEmitter.default();
  LiveQuery.open = /* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee() {
    var liveQueryClient;
    return _regenerator2.default.wrap(function(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return getLiveQueryClient();
          case 2:
            liveQueryClient = _context.sent;
            liveQueryClient.open();
          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  LiveQuery.close = /* @__PURE__ */ (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee2() {
    var liveQueryClient;
    return _regenerator2.default.wrap(function(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getLiveQueryClient();
          case 2:
            liveQueryClient = _context2.sent;
            liveQueryClient.close();
          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  LiveQuery.on("error", function() {
  });
  var _default = LiveQuery;
  exports.default = _default;
  var defaultLiveQueryClient;
  var DefaultLiveQueryController = {
    setDefaultLiveQueryClient: function(liveQueryClient) {
      defaultLiveQueryClient = liveQueryClient;
    },
    getDefaultLiveQueryClient: function() {
      return (0, _asyncToGenerator22.default)(/* @__PURE__ */ _regenerator2.default.mark(function _callee3() {
        var _yield$Promise$all, _yield$Promise$all2, currentUser, installationId, sessionToken, liveQueryServerURL, serverURL, protocol, host, applicationId, javascriptKey, masterKey;
        return _regenerator2.default.wrap(function(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!defaultLiveQueryClient) {
                  _context3.next = 2;
                  break;
                }
                return _context3.abrupt("return", defaultLiveQueryClient);
              case 2:
                _context3.next = 4;
                return _promise2.default.all([_CoreManager2.default.getUserController().currentUserAsync(), _CoreManager2.default.getInstallationController().currentInstallationId()]);
              case 4:
                _yield$Promise$all = _context3.sent;
                _yield$Promise$all2 = (0, _slicedToArray22.default)(_yield$Promise$all, 2);
                currentUser = _yield$Promise$all2[0];
                installationId = _yield$Promise$all2[1];
                sessionToken = currentUser ? currentUser.getSessionToken() : void 0;
                liveQueryServerURL = _CoreManager2.default.get("LIVEQUERY_SERVER_URL");
                if (!(liveQueryServerURL && (0, _indexOf2.default)(liveQueryServerURL).call(liveQueryServerURL, "ws") !== 0)) {
                  _context3.next = 12;
                  break;
                }
                throw new Error("You need to set a proper Parse LiveQuery server url before using LiveQueryClient");
              case 12:
                if (!liveQueryServerURL) {
                  serverURL = _CoreManager2.default.get("SERVER_URL");
                  protocol = (0, _indexOf2.default)(serverURL).call(serverURL, "https") === 0 ? "wss://" : "ws://";
                  host = serverURL.replace(/^https?:\/\//, "");
                  liveQueryServerURL = protocol + host;
                  _CoreManager2.default.set("LIVEQUERY_SERVER_URL", liveQueryServerURL);
                }
                applicationId = _CoreManager2.default.get("APPLICATION_ID");
                javascriptKey = _CoreManager2.default.get("JAVASCRIPT_KEY");
                masterKey = _CoreManager2.default.get("MASTER_KEY");
                defaultLiveQueryClient = new _LiveQueryClient.default({
                  applicationId,
                  serverURL: liveQueryServerURL,
                  javascriptKey,
                  masterKey,
                  sessionToken,
                  installationId
                });
                defaultLiveQueryClient.on("error", function(error) {
                  LiveQuery.emit("error", error);
                });
                defaultLiveQueryClient.on("open", function() {
                  LiveQuery.emit("open");
                });
                defaultLiveQueryClient.on("close", function() {
                  LiveQuery.emit("close");
                });
                return _context3.abrupt("return", defaultLiveQueryClient);
              case 21:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    _clearCachedDefaultClient: function() {
      defaultLiveQueryClient = null;
    }
  };
  _CoreManager2.default.setLiveQueryController(DefaultLiveQueryController);
})(ParseLiveQuery);
var IndexedDBStorageController$1 = { exports: {} };
var dist$2 = {};
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve3) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve3);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
var dist$1 = idbReady;
Object.defineProperty(dist$2, "__esModule", { value: true });
var safariFix = dist$1;
function _interopDefaultLegacy(e2) {
  return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
}
var safariFix__default = /* @__PURE__ */ _interopDefaultLegacy(safariFix);
function promisifyRequest(request) {
  return new Promise((resolve3, reject2) => {
    request.oncomplete = request.onsuccess = () => resolve3(request.result);
    request.onabort = request.onerror = () => reject2(request.error);
  });
}
function createStore$1(dbName, storeName) {
  const dbp = safariFix__default["default"]().then(() => {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    return promisifyRequest(request);
  });
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore$1("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function setMany(entries3, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    entries3.forEach((entry) => store.put(entry[1], entry[0]));
    return promisifyRequest(store.transaction);
  });
}
function getMany(keys4, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => Promise.all(keys4.map((key) => promisifyRequest(store.get(key)))));
}
function update$1(key, updater, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => new Promise((resolve3, reject2) => {
    store.get(key).onsuccess = function() {
      try {
        store.put(updater(this.result), key);
        resolve3(promisifyRequest(store.transaction));
      } catch (err) {
        reject2(err);
      }
    };
  }));
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function delMany(keys4, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    keys4.forEach((key) => store.delete(key));
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(customStore, callback) {
  return customStore("readonly", (store) => {
    store.openCursor().onsuccess = function() {
      if (!this.result)
        return;
      callback(this.result);
      this.result.continue();
    };
    return promisifyRequest(store.transaction);
  });
}
function keys3(customStore = defaultGetStore()) {
  const items = [];
  return eachCursor(customStore, (cursor) => items.push(cursor.key)).then(() => items);
}
function values(customStore = defaultGetStore()) {
  const items = [];
  return eachCursor(customStore, (cursor) => items.push(cursor.value)).then(() => items);
}
function entries2(customStore = defaultGetStore()) {
  const items = [];
  return eachCursor(customStore, (cursor) => items.push([cursor.key, cursor.value])).then(() => items);
}
dist$2.clear = clear;
dist$2.createStore = createStore$1;
dist$2.del = del;
dist$2.delMany = delMany;
dist$2.entries = entries2;
dist$2.get = get;
dist$2.getMany = getMany;
dist$2.keys = keys3;
dist$2.promisifyRequest = promisifyRequest;
dist$2.set = set;
dist$2.setMany = setMany;
dist$2.update = update$1;
dist$2.values = values;
var _keysInstanceProperty = keys$1;
var _idbKeyval = dist$2;
try {
  var ParseStore = (0, _idbKeyval.createStore)("parseDB", "parseStore");
  var IndexedDBStorageController = {
    async: 1,
    getItemAsync: function(path2) {
      return (0, _idbKeyval.get)(path2, ParseStore);
    },
    setItemAsync: function(path2, value) {
      return (0, _idbKeyval.set)(path2, value, ParseStore);
    },
    removeItemAsync: function(path2) {
      return (0, _idbKeyval.del)(path2, ParseStore);
    },
    getAllKeysAsync: function() {
      return (0, _keysInstanceProperty(_idbKeyval))(ParseStore);
    },
    clear: function() {
      return (0, _idbKeyval.clear)(ParseStore);
    }
  };
  IndexedDBStorageController$1.exports = IndexedDBStorageController;
} catch (e2) {
}
var _interopRequireDefault = interopRequireDefault.exports;
var _Object$getOwnPropertyDescriptor = getOwnPropertyDescriptor$4;
var _Object$defineProperty = defineProperty$a;
var _typeof = _typeof$1.exports;
var _WeakMap = weakMap;
var _promise = _interopRequireDefault(promise$3);
var _decode = _interopRequireDefault(decode$2);
var _encode = _interopRequireDefault(encode);
var _CoreManager = _interopRequireDefault(CoreManager);
var _CryptoController = _interopRequireDefault(CryptoController_1);
var _EventuallyQueue = _interopRequireDefault(EventuallyQueue_1);
var _InstallationController = _interopRequireDefault(InstallationController_1);
var ParseOp = _interopRequireWildcard(ParseOp$1);
var _RESTController = _interopRequireDefault(RESTController_1);
function _getRequireWildcardCache(nodeInterop) {
  if (typeof _WeakMap !== "function")
    return null;
  var cacheBabelInterop = new _WeakMap();
  var cacheNodeInterop = new _WeakMap();
  return (_getRequireWildcardCache = function(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = _Object$defineProperty && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        _Object$defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
var Parse = {
  initialize: function(applicationId, javaScriptKey) {
    if (_CoreManager.default.get("IS_NODE") && !{}.SERVER_RENDERING) {
      console.log("It looks like you're using the browser version of the SDK in a node.js environment. You should require('parse/node') instead.");
    }
    Parse._initialize(applicationId, javaScriptKey);
  },
  _initialize: function(applicationId, javaScriptKey, masterKey) {
    _CoreManager.default.set("APPLICATION_ID", applicationId);
    _CoreManager.default.set("JAVASCRIPT_KEY", javaScriptKey);
    _CoreManager.default.set("MASTER_KEY", masterKey);
    _CoreManager.default.set("USE_MASTER_KEY", false);
  },
  setAsyncStorage: function(storage) {
    _CoreManager.default.setAsyncStorage(storage);
  },
  setLocalDatastoreController: function(controller) {
    _CoreManager.default.setLocalDatastoreController(controller);
  },
  getServerHealth: function() {
    return _CoreManager.default.getRESTController().request("GET", "health");
  },
  set applicationId(value) {
    _CoreManager.default.set("APPLICATION_ID", value);
  },
  get applicationId() {
    return _CoreManager.default.get("APPLICATION_ID");
  },
  set javaScriptKey(value) {
    _CoreManager.default.set("JAVASCRIPT_KEY", value);
  },
  get javaScriptKey() {
    return _CoreManager.default.get("JAVASCRIPT_KEY");
  },
  set masterKey(value) {
    _CoreManager.default.set("MASTER_KEY", value);
  },
  get masterKey() {
    return _CoreManager.default.get("MASTER_KEY");
  },
  set serverURL(value) {
    _CoreManager.default.set("SERVER_URL", value);
  },
  get serverURL() {
    return _CoreManager.default.get("SERVER_URL");
  },
  set serverAuthToken(value) {
    _CoreManager.default.set("SERVER_AUTH_TOKEN", value);
  },
  get serverAuthToken() {
    return _CoreManager.default.get("SERVER_AUTH_TOKEN");
  },
  set serverAuthType(value) {
    _CoreManager.default.set("SERVER_AUTH_TYPE", value);
  },
  get serverAuthType() {
    return _CoreManager.default.get("SERVER_AUTH_TYPE");
  },
  set liveQueryServerURL(value) {
    _CoreManager.default.set("LIVEQUERY_SERVER_URL", value);
  },
  get liveQueryServerURL() {
    return _CoreManager.default.get("LIVEQUERY_SERVER_URL");
  },
  set encryptedUser(value) {
    _CoreManager.default.set("ENCRYPTED_USER", value);
  },
  get encryptedUser() {
    return _CoreManager.default.get("ENCRYPTED_USER");
  },
  set secret(value) {
    _CoreManager.default.set("ENCRYPTED_KEY", value);
  },
  get secret() {
    return _CoreManager.default.get("ENCRYPTED_KEY");
  },
  set idempotency(value) {
    _CoreManager.default.set("IDEMPOTENCY", value);
  },
  get idempotency() {
    return _CoreManager.default.get("IDEMPOTENCY");
  },
  set allowCustomObjectId(value) {
    _CoreManager.default.set("ALLOW_CUSTOM_OBJECT_ID", value);
  },
  get allowCustomObjectId() {
    return _CoreManager.default.get("ALLOW_CUSTOM_OBJECT_ID");
  }
};
Parse.ACL = ParseACL.default;
Parse.Analytics = Analytics;
Parse.AnonymousUtils = AnonymousUtils.default;
Parse.Cloud = Cloud;
Parse.CLP = ParseCLP.default;
Parse.CoreManager = CoreManager;
Parse.Config = ParseConfig.default;
Parse.Error = ParseError$1.default;
Parse.EventuallyQueue = _EventuallyQueue.default;
Parse.FacebookUtils = FacebookUtils.default;
Parse.File = ParseFile.default;
Parse.GeoPoint = ParseGeoPoint$1.default;
Parse.Polygon = ParsePolygon$1.default;
Parse.Installation = ParseInstallation.default;
Parse.LocalDatastore = LocalDatastore_1;
Parse.Object = ParseObject.default;
Parse.Op = {
  Set: ParseOp.SetOp,
  Unset: ParseOp.UnsetOp,
  Increment: ParseOp.IncrementOp,
  Add: ParseOp.AddOp,
  Remove: ParseOp.RemoveOp,
  AddUnique: ParseOp.AddUniqueOp,
  Relation: ParseOp.RelationOp
};
Parse.Push = Push;
Parse.Query = ParseQuery.default;
Parse.Relation = ParseRelation.default;
Parse.Role = ParseRole.default;
Parse.Schema = ParseSchema.default;
Parse.Session = ParseSession.default;
Parse.Storage = Storage_1;
Parse.User = ParseUser.default;
Parse.LiveQuery = ParseLiveQuery.default;
Parse.LiveQueryClient = LiveQueryClient.default;
Parse.IndexedDB = IndexedDBStorageController$1.exports;
Parse._request = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return _CoreManager.default.getRESTController().request.apply(null, args);
};
Parse._ajax = function() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  return _CoreManager.default.getRESTController().ajax.apply(null, args);
};
Parse._decode = function(_, value) {
  return (0, _decode.default)(value);
};
Parse._encode = function(value, _, disallowObjects) {
  return (0, _encode.default)(value, disallowObjects);
};
Parse._getInstallationId = function() {
  return _CoreManager.default.getInstallationController().currentInstallationId();
};
Parse.enableLocalDatastore = function() {
  var polling2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  var ms = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2e3;
  if (!Parse.applicationId) {
    console.log("'enableLocalDataStore' must be called after 'initialize'");
    return;
  }
  if (!Parse.LocalDatastore.isEnabled) {
    Parse.LocalDatastore.isEnabled = true;
    if (polling2) {
      _EventuallyQueue.default.poll(ms);
    }
  }
};
Parse.isLocalDatastoreEnabled = function() {
  return Parse.LocalDatastore.isEnabled;
};
Parse.dumpLocalDatastore = function() {
  if (!Parse.LocalDatastore.isEnabled) {
    console.log("Parse.enableLocalDatastore() must be called first");
    return _promise.default.resolve({});
  } else {
    return Parse.LocalDatastore._getAllContents();
  }
};
Parse.enableEncryptedUser = function() {
  Parse.encryptedUser = true;
};
Parse.isEncryptedUserEnabled = function() {
  return Parse.encryptedUser;
};
_CoreManager.default.setCryptoController(_CryptoController.default);
_CoreManager.default.setInstallationController(_InstallationController.default);
_CoreManager.default.setRESTController(_RESTController.default);
Parse.Parse = Parse;
var Parse_1 = Parse;
var parse = Parse_1;
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id2 in plugin.settings) {
        const item = plugin.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data2 = JSON.parse(raw);
      Object.assign(currentSettings, data2);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {
        }
        currentSettings = value;
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve3) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve3
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
  * vue-router v4.0.12
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const PolySymbol = (name) => hasSymbol ? Symbol("[vue-router]: " + name) : "[vue-router]: " + name;
const matchedRouteKey = /* @__PURE__ */ PolySymbol("router view location matched");
const viewDepthKey = /* @__PURE__ */ PolySymbol("router view depth");
const routerKey = /* @__PURE__ */ PolySymbol("router");
const routeLocationKey = /* @__PURE__ */ PolySymbol("route location");
const routerViewLocationKey = /* @__PURE__ */ PolySymbol("router view location");
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
}
const assign2 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
function warn(msg) {
  const args = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
}
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path2) => path2.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path2, query = {}, searchString = "", hash = "";
  const searchPos = location2.indexOf("?");
  const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
  if (searchPos > -1) {
    path2 = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path2 = path2 || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path2 = resolveRelativePath(path2 != null ? path2 : location2, currentLocation);
  return {
    fullPath: path2 + (searchString && "?") + searchString + hash,
    path: path2,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return Array.isArray(b) ? a.length === b.length && a.every((value, i2) => value === b[i2]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from4) {
  if (to.startsWith("/"))
    return to;
  if (!from4.startsWith("/")) {
    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from4}". It should look like "/${from4}".`);
    return to;
  }
  if (!to)
    return from4;
  const fromSegments = from4.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (position === 1 || segment === ".")
      continue;
    if (segment === "..")
      position--;
    else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    if (typeof position.el === "string") {
      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
        try {
          const foundEl = document.querySelector(position.el);
          if (isIdSelector && foundEl) {
            warn(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`);
            return;
          }
        } catch (err) {
          warn(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
          return;
        }
      }
    }
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      warn(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path2, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path2;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path2 = stripBase(pathname, base);
  return path2 + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace2) {
  let listeners2 = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from4 = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from4) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace2(to);
    }
    listeners2.forEach((listener2) => {
      listener2(currentLocation.value, from4, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners2.push(callback);
    const teardown = () => {
      const index = listeners2.indexOf(callback);
      if (index > -1)
        listeners2.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign2({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace3) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace3 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        warn("Error with push/replace State", err);
      }
      location2[replace3 ? "replace" : "assign"](url);
    }
  }
  function replace2(to, data2) {
    const state = assign2({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data2, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push2(to, data2) {
    const currentState = assign2({}, historyState.value, history2.state, {
      forward: to,
      scroll: computeScrollPosition()
    });
    if (!history2.state) {
      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
    }
    changeLocation(currentState.current, currentState, true);
    const state = assign2({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data2);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push: push2,
    replace: replace2
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign2({
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  if (!base.endsWith("#/") && !base.endsWith("#")) {
    warn(`A hash base must end with a "#":
"${base}" should be "${base.replace(/#.*$/, "#")}".`);
  }
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("navigation failure");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
const ErrorTypeMessages = {
  [1]({ location: location2, currentLocation }) {
    return `No match for
 ${JSON.stringify(location2)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
  },
  [2]({ from: from4, to }) {
    return `Redirected from "${from4.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
  },
  [4]({ from: from4, to }) {
    return `Navigation aborted from "${from4.fullPath}" to "${to.fullPath}" via a navigation guard.`;
  },
  [8]({ from: from4, to }) {
    return `Navigation cancelled from "${from4.fullPath}" to "${to.fullPath}" with a new navigation.`;
  },
  [16]({ from: from4, to }) {
    return `Avoided redundant navigation to current location: "${from4.fullPath}".`;
  }
};
function createRouterError(type, params) {
  {
    return assign2(new Error(ErrorTypeMessages[type](params)), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const propertiesToLog = ["params", "query", "hash"];
function stringifyRoute(to) {
  if (typeof to === "string")
    return to;
  if ("path" in to)
    return to.path;
  const location2 = {};
  for (const key of propertiesToLog) {
    if (key in to)
      location2[key] = to[key];
  }
  return JSON.stringify(location2, null, 2);
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign2({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys4 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys4.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path2) {
    const match2 = path2.match(re);
    const params = {};
    if (!match2)
      return null;
    for (let i2 = 1; i2 < match2.length; i2++) {
      const value = match2[i2] || "";
      const key = keys4[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify3(params) {
    let path2 = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path2.endsWith("/"))
        path2 += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path2 += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (Array.isArray(param) && !repeatable)
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          const text = Array.isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path2.endsWith("/"))
                  path2 = path2.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path2 += text;
        }
      }
    }
    return path2;
  }
  return {
    re,
    score,
    keys: keys4,
    parse: parse2,
    stringify: stringify3
  };
}
function compareScoreArray(a, b) {
  let i2 = 0;
  while (i2 < a.length && i2 < b.length) {
    const diff = b[i2] - a[i2];
    if (diff)
      return diff;
    i2++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i2 = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  return bScore.length - aScore.length;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path2) {
  if (!path2)
    return [[]];
  if (path2 === "/")
    return [[ROOT_TOKEN]];
  if (!path2.startsWith("/")) {
    throw new Error(`Route paths should start with a "/": "${path2}" should be "/${path2}".`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i2 < path2.length) {
    char = path2[i2++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent2, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  {
    const existingKeys = /* @__PURE__ */ new Set();
    for (const key of parser.keys) {
      if (existingKeys.has(key.name))
        warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
      existingKeys.add(key.name);
    }
  }
  const matcher = assign2(parser, {
    record,
    parent: parent2,
    children: [],
    alias: []
  });
  if (parent2) {
    if (!matcher.record.aliasOf === !parent2.record.aliasOf)
      parent2.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent2, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign2({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path: path2 } = normalizedRecord;
      if (parent2 && path2[0] !== "/") {
        const parentPath = parent2.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent2.record.path + (path2 && connectingSlash + path2);
      }
      if (normalizedRecord.path === "*") {
        throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent2, options);
      if (parent2 && path2[0] === "/")
        checkMissingParamsInAbsolutePath(matcher, parent2);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
        {
          checkSameParams(originalRecord, matcher);
        }
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if ("children" in mainNormalizedRecord) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0)
      i2++;
    matchers.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve3(location2, currentLocation) {
    let matcher;
    let params = {};
    let path2;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign2(paramsFromLocation(currentLocation.params, matcher.keys.filter((k) => !k.optional).map((k) => k.name)), location2.params);
      path2 = matcher.stringify(params);
    } else if ("path" in location2) {
      path2 = location2.path;
      if (!path2.startsWith("/")) {
        warn(`The Matcher cannot resolve relative paths but received "${path2}". Unless you directly called \`matcher.resolve("${path2}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);
      }
      matcher = matchers.find((m) => m.re.test(path2));
      if (matcher) {
        params = matcher.parse(path2);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign2({}, currentLocation.params, location2.params);
      path2 = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path: path2,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve3, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys4) {
  const newParams = {};
  for (const key of keys4) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || {} : { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "boolean" ? props : props[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta2, record) => assign2(meta2, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isSameParam(a, b) {
  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;
}
function checkSameParams(a, b) {
  for (const key of a.keys) {
    if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
      return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
  }
  for (const key of b.keys) {
    if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
      return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
  }
}
function checkMissingParamsInAbsolutePath(record, parent2) {
  for (const key of parent2.keys) {
    if (!record.keys.find(isSameParam.bind(null, key)))
      return warn(`Absolute path "${record.record.path}" should have the exact same param named "${key.name}" as its parent "${parent2.record.path}".`);
  }
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
    warn(`Error decoding "${text}". Using original value`);
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!Array.isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values2 = Array.isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values2.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = Array.isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
function useCallbacks() {
  let handlers = [];
  function add2(handler) {
    handlers.push(handler);
    return () => {
      const i2 = handlers.indexOf(handler);
      if (i2 > -1)
        handlers.splice(i2, 1);
    };
  }
  function reset2() {
    handlers = [];
  }
  return {
    add: add2,
    list: () => handlers,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to, from4, record, name) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve3, reject2) => {
    const next2 = (valid) => {
      if (valid === false)
        reject2(createRouterError(4, {
          from: from4,
          to
        }));
      else if (valid instanceof Error) {
        reject2(valid);
      } else if (isRouteLocation(valid)) {
        reject2(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve3();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from4, canOnlyBeCalledOnce(next2, to, from4));
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next2);
    if (guard.length > 2) {
      const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ""}:
${guard.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof guardReturn === "object" && "then" in guardReturn) {
        guardCall = guardCall.then((resolvedValue) => {
          if (!next2._called) {
            warn(message);
            return Promise.reject(new Error("Invalid navigation guard"));
          }
          return resolvedValue;
        });
      } else if (guardReturn !== void 0) {
        if (!next2._called) {
          warn(message);
          reject2(new Error("Invalid navigation guard"));
          return;
        }
      }
    }
    guardCall.catch((err) => reject2(err));
  });
}
function canOnlyBeCalledOnce(next2, to, from4) {
  let called = 0;
  return function() {
    if (called++ === 1)
      warn(`The "next" callback was called more than once in one navigation guard when going from "${from4.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
    next2._called = true;
    if (called === 1)
      next2.apply(null, arguments);
  };
}
function extractComponentsGuards(matched, guardType, to, from4) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      {
        if (!rawComponent || typeof rawComponent !== "object" && typeof rawComponent !== "function") {
          warn(`Component "${name}" in record with path "${record.path}" is not a valid component. Received "${String(rawComponent)}".`);
          throw new Error("Invalid route component");
        } else if ("then" in rawComponent) {
          warn(`Component "${name}" in record with path "${record.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const promise2 = rawComponent;
          rawComponent = () => promise2;
        } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {
          rawComponent.__warnedDefineAsync = true;
          warn(`Component "${name}" in record with path "${record.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`);
        }
      }
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from4, record, name));
      } else {
        let componentPromise = rawComponent();
        if (!("catch" in componentPromise)) {
          warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
          componentPromise = Promise.resolve(componentPromise);
        }
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from4, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop);
    }
    return Promise.resolve();
  }
  if (isBrowser) {
    const instance = getCurrentInstance();
    if (instance) {
      const linkContextDevtools = {
        route: route.value,
        isActive: isActive.value,
        isExactActive: isExactActive.value
      };
      instance.__vrl_devtools = instance.__vrl_devtools || [];
      instance.__vrl_devtools.push(linkContextDevtools);
      watchEffect(() => {
        linkContextDevtools.route = route.value;
        linkContextDevtools.isActive = isActive.value;
        linkContextDevtools.isExactActive = isExactActive.value;
      }, { flush: "post" });
    }
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  setup(props, { attrs, slots }) {
    warnDeprecatedUsage();
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from4, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from4 && from4 !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from4.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from4.updateGuards;
          }
        }
      }
      if (instance && to && (!from4 || !isSameRouteRecord(to, from4) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign2({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      if (isBrowser && component.ref) {
        const info = {
          depth,
          name: matchedRoute.name,
          path: matchedRoute.path,
          meta: matchedRoute.meta
        };
        const internalInstances = Array.isArray(component.ref) ? component.ref.map((r2) => r2.i) : [component.ref.i];
        internalInstances.forEach((instance) => {
          instance.__vrv_devtools = info;
        });
      }
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data2) {
  if (!slot)
    return null;
  const slotContent = slot(data2);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function warnDeprecatedUsage() {
  const instance = getCurrentInstance();
  const parentName = instance.parent && instance.parent.type.name;
  if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition"))) {
    const comp = parentName === "KeepAlive" ? "keep-alive" : "transition";
    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${comp}>
    <component :is="Component" />
  </${comp}>
</router-view>`);
  }
}
function formatRouteLocation(routeLocation, tooltip) {
  const copy = assign2({}, routeLocation, {
    matched: routeLocation.matched.map((matched) => omit(matched, ["instances", "children", "aliasOf"]))
  });
  return {
    _custom: {
      type: null,
      readOnly: true,
      display: routeLocation.fullPath,
      tooltip,
      value: copy
    }
  };
}
function formatDisplay(display) {
  return {
    _custom: {
      display
    }
  };
}
let routerId = 0;
function addDevtools$1(app, router, matcher) {
  if (router.__hasDevtools)
    return;
  router.__hasDevtools = true;
  const id2 = routerId++;
  setupDevtoolsPlugin({
    id: "org.vuejs.router" + (id2 ? "." + id2 : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://next.router.vuejs.org/",
    logo: "https://vuejs.org/images/icons/favicon-96x96.png",
    componentStateTypes: ["Routing"],
    app
  }, (api) => {
    api.on.inspectComponent((payload, ctx) => {
      if (payload.instanceData) {
        payload.instanceData.state.push({
          type: "Routing",
          key: "$route",
          editable: false,
          value: formatRouteLocation(router.currentRoute.value, "Current Route")
        });
      }
    });
    api.on.visitComponentTree(({ treeNode: node2, componentInstance }) => {
      if (componentInstance.__vrv_devtools) {
        const info = componentInstance.__vrv_devtools;
        node2.tags.push({
          label: (info.name ? `${info.name.toString()}: ` : "") + info.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: PINK_500
        });
      }
      if (Array.isArray(componentInstance.__vrl_devtools)) {
        componentInstance.__devtoolsApi = api;
        componentInstance.__vrl_devtools.forEach((devtoolsData) => {
          let backgroundColor = ORANGE_400;
          let tooltip = "";
          if (devtoolsData.isExactActive) {
            backgroundColor = LIME_500;
            tooltip = "This is exactly active";
          } else if (devtoolsData.isActive) {
            backgroundColor = BLUE_600;
            tooltip = "This link is active";
          }
          node2.tags.push({
            label: devtoolsData.route.path,
            textColor: 0,
            tooltip,
            backgroundColor
          });
        });
      }
    });
    watch(router.currentRoute, () => {
      refreshRoutesView();
      api.notifyComponentUpdate();
      api.sendInspectorTree(routerInspectorId);
      api.sendInspectorState(routerInspectorId);
    });
    const navigationsLayerId = "router:navigations:" + id2;
    api.addTimelineLayer({
      id: navigationsLayerId,
      label: `Router${id2 ? " " + id2 : ""} Navigations`,
      color: 4237508
    });
    router.onError((error, to) => {
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: "Error during Navigation",
          subtitle: to.fullPath,
          logType: "error",
          time: Date.now(),
          data: { error },
          groupId: to.meta.__navigationId
        }
      });
    });
    let navigationId = 0;
    router.beforeEach((to, from4) => {
      const data2 = {
        guard: formatDisplay("beforeEach"),
        from: formatRouteLocation(from4, "Current Location during this navigation"),
        to: formatRouteLocation(to, "Target location")
      };
      Object.defineProperty(to.meta, "__navigationId", {
        value: navigationId++
      });
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          time: Date.now(),
          title: "Start of navigation",
          subtitle: to.fullPath,
          data: data2,
          groupId: to.meta.__navigationId
        }
      });
    });
    router.afterEach((to, from4, failure) => {
      const data2 = {
        guard: formatDisplay("afterEach")
      };
      if (failure) {
        data2.failure = {
          _custom: {
            type: Error,
            readOnly: true,
            display: failure ? failure.message : "",
            tooltip: "Navigation Failure",
            value: failure
          }
        };
        data2.status = formatDisplay("\u274C");
      } else {
        data2.status = formatDisplay("\u2705");
      }
      data2.from = formatRouteLocation(from4, "Current Location during this navigation");
      data2.to = formatRouteLocation(to, "Target location");
      api.addTimelineEvent({
        layerId: navigationsLayerId,
        event: {
          title: "End of navigation",
          subtitle: to.fullPath,
          time: Date.now(),
          data: data2,
          logType: failure ? "warning" : "default",
          groupId: to.meta.__navigationId
        }
      });
    });
    const routerInspectorId = "router-inspector:" + id2;
    api.addInspector({
      id: routerInspectorId,
      label: "Routes" + (id2 ? " " + id2 : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function refreshRoutesView() {
      if (!activeRoutesPayload)
        return;
      const payload = activeRoutesPayload;
      let routes = matcher.getRoutes().filter((route) => !route.parent);
      routes.forEach(resetMatchStateOnRouteRecord);
      if (payload.filter) {
        routes = routes.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));
      }
      routes.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));
      payload.rootNodes = routes.map(formatRouteRecordForInspector);
    }
    let activeRoutesPayload;
    api.on.getInspectorTree((payload) => {
      activeRoutesPayload = payload;
      if (payload.app === app && payload.inspectorId === routerInspectorId) {
        refreshRoutesView();
      }
    });
    api.on.getInspectorState((payload) => {
      if (payload.app === app && payload.inspectorId === routerInspectorId) {
        const routes = matcher.getRoutes();
        const route = routes.find((route2) => route2.record.__vd_id === payload.nodeId);
        if (route) {
          payload.state = {
            options: formatRouteRecordMatcherForStateInspector(route)
          };
        }
      }
    });
    api.sendInspectorTree(routerInspectorId);
    api.sendInspectorState(routerInspectorId);
  });
}
function modifierForKey(key) {
  if (key.optional) {
    return key.repeatable ? "*" : "?";
  } else {
    return key.repeatable ? "+" : "";
  }
}
function formatRouteRecordMatcherForStateInspector(route) {
  const { record } = route;
  const fields = [
    { editable: false, key: "path", value: record.path }
  ];
  if (record.name != null) {
    fields.push({
      editable: false,
      key: "name",
      value: record.name
    });
  }
  fields.push({ editable: false, key: "regexp", value: route.re });
  if (route.keys.length) {
    fields.push({
      editable: false,
      key: "keys",
      value: {
        _custom: {
          type: null,
          readOnly: true,
          display: route.keys.map((key) => `${key.name}${modifierForKey(key)}`).join(" "),
          tooltip: "Param keys",
          value: route.keys
        }
      }
    });
  }
  if (record.redirect != null) {
    fields.push({
      editable: false,
      key: "redirect",
      value: record.redirect
    });
  }
  if (route.alias.length) {
    fields.push({
      editable: false,
      key: "aliases",
      value: route.alias.map((alias) => alias.record.path)
    });
  }
  fields.push({
    key: "score",
    editable: false,
    value: {
      _custom: {
        type: null,
        readOnly: true,
        display: route.score.map((score) => score.join(", ")).join(" | "),
        tooltip: "Score used to sort routes",
        value: route.score
      }
    }
  });
  return fields;
}
const PINK_500 = 15485081;
const BLUE_600 = 2450411;
const LIME_500 = 8702998;
const CYAN_400 = 2282478;
const ORANGE_400 = 16486972;
const DARK = 6710886;
function formatRouteRecordForInspector(route) {
  const tags = [];
  const { record } = route;
  if (record.name != null) {
    tags.push({
      label: String(record.name),
      textColor: 0,
      backgroundColor: CYAN_400
    });
  }
  if (record.aliasOf) {
    tags.push({
      label: "alias",
      textColor: 0,
      backgroundColor: ORANGE_400
    });
  }
  if (route.__vd_match) {
    tags.push({
      label: "matches",
      textColor: 0,
      backgroundColor: PINK_500
    });
  }
  if (route.__vd_exactActive) {
    tags.push({
      label: "exact",
      textColor: 0,
      backgroundColor: LIME_500
    });
  }
  if (route.__vd_active) {
    tags.push({
      label: "active",
      textColor: 0,
      backgroundColor: BLUE_600
    });
  }
  if (record.redirect) {
    tags.push({
      label: "redirect: " + (typeof record.redirect === "string" ? record.redirect : "Object"),
      textColor: 16777215,
      backgroundColor: DARK
    });
  }
  let id2 = record.__vd_id;
  if (id2 == null) {
    id2 = String(routeRecordId++);
    record.__vd_id = id2;
  }
  return {
    id: id2,
    label: record.path,
    tags,
    children: route.children.map(formatRouteRecordForInspector)
  };
}
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
  route.__vd_exactActive = route.__vd_active = isExactActive;
  if (!isExactActive) {
    route.__vd_active = currentRoute.matched.some((match2) => isSameRouteRecord(match2, route.record));
  }
  route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));
}
function resetMatchStateOnRouteRecord(route) {
  route.__vd_match = false;
  route.children.forEach(resetMatchStateOnRouteRecord);
}
function isRouteMatching(route, filter4) {
  const found = String(route.re).match(EXTRACT_REGEXP_RE);
  route.__vd_match = false;
  if (!found || found.length < 3) {
    return false;
  }
  const nonEndingRE = new RegExp(found[1].replace(/\$$/, ""), found[2]);
  if (nonEndingRE.test(filter4)) {
    route.children.forEach((child) => isRouteMatching(child, filter4));
    if (route.record.path !== "/" || filter4 === "/") {
      route.__vd_match = route.re.test(filter4);
      return true;
    }
    return false;
  }
  const path2 = route.record.path.toLowerCase();
  const decodedPath = decode(path2);
  if (!filter4.startsWith("/") && (decodedPath.includes(filter4) || path2.includes(filter4)))
    return true;
  if (decodedPath.startsWith(filter4) || path2.startsWith(filter4))
    return true;
  if (route.record.name && String(route.record.name).includes(filter4))
    return true;
  return route.children.some((child) => isRouteMatching(child, filter4));
}
function omit(obj, keys4) {
  const ret = {};
  for (const key in obj) {
    if (!keys4.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  if (!routerHistory)
    throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent2;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent2 = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent2);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    } else {
      warn(`Cannot remove non-existent route "${String(name)}"`);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve3(rawLocation, currentLocation) {
    currentLocation = assign2({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      {
        if (href2.startsWith("//"))
          warn(`Location "${rawLocation}" resolved to "${href2}". A resolved location cannot start with multiple slashes.`);
        else if (!matchedRoute2.matched.length) {
          warn(`No match found for location with path "${rawLocation}"`);
        }
      }
      return assign2(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      if ("params" in rawLocation && !("name" in rawLocation) && Object.keys(rawLocation.params).length) {
        warn(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
      }
      matcherLocation = assign2({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign2({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign2({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    if (hash && !hash.startsWith("#")) {
      warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
    }
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign2({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    {
      if (href.startsWith("//")) {
        warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
      } else if (!matchedRoute.matched.length) {
        warn(`No match found for location with path "${"path" in rawLocation ? rawLocation.path : rawLocation}"`);
      }
    }
    return assign2({
      fullPath,
      hash,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign2({}, to);
  }
  function checkCanceledNavigation(to, from4) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from: from4,
        to
      });
    }
  }
  function push2(to) {
    return pushWithRedirect(to);
  }
  function replace2(to) {
    return push2(assign2(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      if (!("path" in newTargetLocation) && !("name" in newTargetLocation)) {
        warn(`Invalid redirect found:
${JSON.stringify(newTargetLocation, null, 2)}
 when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
        throw new Error("Invalid redirect");
      }
      return assign2({
        query: to.query,
        hash: to.hash,
        params: to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve3(to);
    const from4 = currentRoute.value;
    const data2 = to.state;
    const force = to.force;
    const replace3 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(assign2(locationAsObject(shouldRedirect), {
        state: data2,
        force,
        replace: replace3
      }), redirectedFrom || targetLocation);
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from4, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from: from4 });
      handleScroll(from4, from4, true, false);
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from4)).catch((error) => isNavigationFailure(error) ? error : triggerError(error, toLocation, from4)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          if (isSameRouteLocation(stringifyQuery$1, resolve3(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 10) {
            warn(`Detected an infinite redirection in a navigation guard when going from "${from4.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
            return Promise.reject(new Error("Infinite redirect in navigation guard"));
          }
          return pushWithRedirect(assign2(locationAsObject(failure2.to), {
            state: data2,
            force,
            replace: replace3
          }), redirectedFrom || toLocation);
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from4, true, replace3, data2);
      }
      triggerAfterEach(toLocation, from4, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from4) {
    const error = checkCanceledNavigation(to, from4);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to, from4) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from4);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from4);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from4));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from4);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from4));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from4);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from4));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from4.matched.includes(record)) {
          if (Array.isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from4));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from4));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from4);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from4));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from4, failure) {
    for (const guard of afterGuards.list())
      guard(to, from4, failure);
  }
  function finalizeNavigation(toLocation, from4, isPush, replace3, data2) {
    const error = checkCanceledNavigation(toLocation, from4);
    if (error)
      return error;
    const isFirstNavigation = from4 === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace3 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign2({
          scroll: isFirstNavigation && state && state.scroll
        }, data2));
      else
        routerHistory.push(toLocation.fullPath, data2);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from4, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    removeHistoryListener = routerHistory.listen((to, _from2, info) => {
      const toLocation = resolve3(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign2(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from4 = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from4.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from4).catch((error) => {
        if (isNavigationFailure(error, 4 | 8)) {
          return error;
        }
        if (isNavigationFailure(error, 2)) {
          pushWithRedirect(error.to, toLocation).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error, toLocation, from4);
      }).then((failure) => {
        failure = failure || finalizeNavigation(toLocation, from4, false);
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from4, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from4) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from4));
    } else {
      {
        warn("uncaught error during route navigation:");
      }
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve4, reject2) => {
      readyHandlers.add([resolve4, reject2]);
    });
  }
  function markAsReady(err) {
    if (ready)
      return;
    ready = true;
    setupListeners();
    readyHandlers.list().forEach(([resolve4, reject2]) => err ? reject2(err) : resolve4());
    readyHandlers.reset();
  }
  function handleScroll(to, from4, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from4, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from4));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve3,
    options,
    push: push2,
    replace: replace2,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push2(routerHistory.location).catch((err) => {
          warn("Unexpected error when starting the router:", err);
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
      if (isBrowser) {
        addDevtools$1(app, router2, matcher);
      }
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise2, guard) => promise2.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from4) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from4.matched.length, to.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from4.matched[i2];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i2];
    if (recordTo) {
      if (!from4.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute() {
  return inject(routeLocationKey);
}
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function useStore(key) {
  if (key === void 0)
    key = null;
  return inject(key !== null ? key : storeKey);
}
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function(key) {
    return fn(obj[key], key);
  });
}
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}
function partial(fn, arg) {
  return function() {
    return fn(arg);
  };
}
function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }
  return function() {
    var i2 = subs.indexOf(fn);
    if (i2 > -1) {
      subs.splice(i2, 1);
    }
  };
}
function resetStore(store, hot) {
  store._actions = /* @__PURE__ */ Object.create(null);
  store._mutations = /* @__PURE__ */ Object.create(null);
  store._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state = store.state;
  installModule(store, state, [], store._modules.root, true);
  resetStoreState(store, state, hot);
}
function resetStoreState(store, state, hot) {
  var oldState = store._state;
  store.getters = {};
  store._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn, key) {
    computedObj[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function() {
        return computedObj[key]();
      },
      enumerable: true
    });
  });
  store._state = reactive({
    data: state
  });
  if (store.strict) {
    enableStrictMode(store);
  }
  if (oldState) {
    if (hot) {
      store._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
function installModule(store, rootState, path2, module, hot) {
  var isRoot = !path2.length;
  var namespace = store._modules.getNamespace(path2);
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && true) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path2.join("/"));
    }
    store._modulesNamespaceMap[namespace] = module;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path2.slice(0, -1));
    var moduleName = path2[path2.length - 1];
    store._withCommit(function() {
      {
        if (moduleName in parentState) {
          console.warn('[vuex] state field "' + moduleName + '" was overridden by a module with the same name at "' + path2.join(".") + '"');
        }
      }
      parentState[moduleName] = module.state;
    });
  }
  var local = module.context = makeLocalContext(store, namespace, path2);
  module.forEachMutation(function(mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function(action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function(getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function(child, key) {
    installModule(store, rootState, path2.concat(key), child, hot);
  });
}
function makeLocalContext(store, namespace, path2) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }
      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }
      store.commit(type, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store.getters;
      } : function() {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store.state, path2);
      }
    }
  });
  return local;
}
function makeLocalGetters(store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store.getters[type];
        },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store._makeLocalGettersCache[namespace];
}
function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}
function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function(err) {
        store._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store2) {
    return rawGetter(local.state, local.getters, store2.state, store2.getters);
  };
}
function enableStrictMode(store) {
  watch(function() {
    return store._state.data;
  }, function() {
    {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, flush: "sync" });
}
function getNestedState(state, path2) {
  return path2.reduce(function(state2, key) {
    return state2[key];
  }, state);
}
function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }
  {
    assert(typeof type === "string", "expects string as the type, but found " + typeof type + ".");
  }
  return { type, payload, options };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app, store) {
  setupDevtoolsPlugin({
    id: "org.vuejs.vuex",
    app,
    label: "Vuex",
    homepage: "https://next.vuex.vuejs.org/",
    logo: "https://vuejs.org/images/icons/favicon-96x96.png",
    packageName: "vuex",
    componentStateTypes: [LABEL_VUEX_BINDINGS]
  }, function(api) {
    api.addTimelineLayer({
      id: MUTATIONS_LAYER_ID,
      label: "Vuex Mutations",
      color: COLOR_LIME_500
    });
    api.addTimelineLayer({
      id: ACTIONS_LAYER_ID,
      label: "Vuex Actions",
      color: COLOR_LIME_500
    });
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Vuex",
      icon: "storage",
      treeFilterPlaceholder: "Filter stores..."
    });
    api.on.getInspectorTree(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        if (payload.filter) {
          var nodes = [];
          flattenStoreForInspectorTree(nodes, store._modules.root, payload.filter, "");
          payload.rootNodes = nodes;
        } else {
          payload.rootNodes = [
            formatStoreForInspectorTree(store._modules.root, "")
          ];
        }
      }
    });
    api.on.getInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        makeLocalGetters(store, modulePath);
        payload.state = formatStoreForInspectorState(getStoreModule(store._modules, modulePath), modulePath === "root" ? store.getters : store._makeLocalGettersCache, modulePath);
      }
    });
    api.on.editInspectorState(function(payload) {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        var modulePath = payload.nodeId;
        var path2 = payload.path;
        if (modulePath !== "root") {
          path2 = modulePath.split("/").filter(Boolean).concat(path2);
        }
        store._withCommit(function() {
          payload.set(store._state.data, path2, payload.state.value);
        });
      }
    });
    store.subscribe(function(mutation, state) {
      var data2 = {};
      if (mutation.payload) {
        data2.payload = mutation.payload;
      }
      data2.state = state;
      api.notifyComponentUpdate();
      api.sendInspectorTree(INSPECTOR_ID);
      api.sendInspectorState(INSPECTOR_ID);
      api.addTimelineEvent({
        layerId: MUTATIONS_LAYER_ID,
        event: {
          time: Date.now(),
          title: mutation.type,
          data: data2
        }
      });
    });
    store.subscribeAction({
      before: function(action, state) {
        var data2 = {};
        if (action.payload) {
          data2.payload = action.payload;
        }
        action._id = actionId++;
        action._time = Date.now();
        data2.state = state;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: action._time,
            title: action.type,
            groupId: action._id,
            subtitle: "start",
            data: data2
          }
        });
      },
      after: function(action, state) {
        var data2 = {};
        var duration = Date.now() - action._time;
        data2.duration = {
          _custom: {
            type: "duration",
            display: duration + "ms",
            tooltip: "Action duration",
            value: duration
          }
        };
        if (action.payload) {
          data2.payload = action.payload;
        }
        data2.state = state;
        api.addTimelineEvent({
          layerId: ACTIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: action.type,
            groupId: action._id,
            subtitle: "end",
            data: data2
          }
        });
      }
    });
  });
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path2) {
  return path2 && path2 !== "root" ? path2.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module, path2) {
  return {
    id: path2 || "root",
    label: extractNameFromPath(path2),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function(moduleName) {
      return formatStoreForInspectorTree(module._children[moduleName], path2 + moduleName + "/");
    })
  };
}
function flattenStoreForInspectorTree(result, module, filter4, path2) {
  if (path2.includes(filter4)) {
    result.push({
      id: path2 || "root",
      label: path2.endsWith("/") ? path2.slice(0, path2.length - 1) : path2 || "Root",
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter4, path2 + moduleName + "/");
  });
}
function formatStoreForInspectorState(module, getters, path2) {
  getters = path2 === "root" ? getters : getters[path2];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function(key) {
      return {
        key,
        editable: true,
        value: module.state[key]
      };
    })
  };
  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function(key) {
      return {
        key: key.endsWith("/") ? extractNameFromPath(key) : key,
        editable: false,
        value: canThrow(function() {
          return tree[key];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters) {
  var result = {};
  Object.keys(getters).forEach(function(key) {
    var path2 = key.split("/");
    if (path2.length > 1) {
      var target = result;
      var leafKey = path2.pop();
      path2.forEach(function(p2) {
        if (!target[p2]) {
          target[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target = target[p2]._custom.value;
      });
      target[leafKey] = canThrow(function() {
        return getters[key];
      });
    } else {
      result[key] = canThrow(function() {
        return getters[key];
      });
    }
  });
  return result;
}
function getStoreModule(moduleMap, path2) {
  var names = path2.split("/").filter(function(n2) {
    return n2;
  });
  return names.reduce(function(module, moduleName, i2) {
    var child = module[moduleName];
    if (!child) {
      throw new Error('Missing module "' + moduleName + '" for path "' + path2 + '".');
    }
    return i2 === names.length - 1 ? child : child._children;
  }, path2 === "root" ? moduleMap : moduleMap.root._children);
}
function canThrow(cb) {
  try {
    return cb();
  } catch (e2) {
    return e2;
  }
}
var Module = function Module2(rawModule, runtime2) {
  this.runtime = runtime2;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};
Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};
Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};
Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};
Module.prototype.update = function update2(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};
Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};
Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path2) {
  return path2.reduce(function(module, key) {
    return module.getChild(key);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path2) {
  var module = this.root;
  return path2.reduce(function(namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$12(rawRootModule) {
  update3([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register(path2, rawModule, runtime2) {
  var this$1$1 = this;
  if (runtime2 === void 0)
    runtime2 = true;
  {
    assertRawModule(path2, rawModule);
  }
  var newModule = new Module(rawModule, runtime2);
  if (path2.length === 0) {
    this.root = newModule;
  } else {
    var parent2 = this.get(path2.slice(0, -1));
    parent2.addChild(path2[path2.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1$1.register(path2.concat(key), rawChildModule, runtime2);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path2) {
  var parent2 = this.get(path2.slice(0, -1));
  var key = path2[path2.length - 1];
  var child = parent2.getChild(key);
  if (!child) {
    {
      console.warn("[vuex] trying to unregister module '" + key + "', which is not registered");
    }
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent2.removeChild(key);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path2) {
  var parent2 = this.get(path2.slice(0, -1));
  var key = path2[path2.length - 1];
  if (parent2) {
    return parent2.hasChild(key);
  }
  return false;
};
function update3(path2, targetModule, newModule) {
  {
    assertRawModule(path2, newModule);
  }
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, manual reload is needed");
        }
        return;
      }
      update3(path2.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}
var functionAssert = {
  assert: function(value) {
    return typeof value === "function";
  },
  expected: "function"
};
var objectAssert = {
  assert: function(value) {
    return typeof value === "function" || typeof value === "object" && typeof value.handler === "function";
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};
function assertRawModule(path2, rawModule) {
  Object.keys(assertTypes).forEach(function(key) {
    if (!rawModule[key]) {
      return;
    }
    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function(value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path2, key, type, value, assertOptions.expected));
    });
  });
}
function makeAssertionMessage(path2, key, type, value, expected) {
  var buf = key + " should be " + expected + ' but "' + key + "." + type + '"';
  if (path2.length > 0) {
    buf += ' in module "' + path2.join(".") + '"';
  }
  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}
function createStore(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  {
    assert(typeof Promise !== "undefined", "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store2, "store must be called with the new operator.");
  }
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools2 = options.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._devtools = devtools2;
  var store = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch2.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options2) {
    return commit2.call(store, type, payload, options2);
  };
  this.strict = strict;
  var state = this._modules.root.state;
  installModule(this, state, [], this._modules.root);
  resetStoreState(this, state);
  plugins.forEach(function(plugin) {
    return plugin(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : true;
  if (useDevtools) {
    addDevtools(app, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v) {
  {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type = ref2.type;
  var payload = ref2.payload;
  var options = ref2.options;
  var mutation = { type, payload };
  var entry = this._mutations[type];
  if (!entry) {
    {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
  if (options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. Use the filter functionality in the vue-devtools");
  }
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type = ref2.type;
  var payload = ref2.payload;
  var action = { type, payload };
  var entry = this._actions[type];
  if (!entry) {
    {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e2) {
    {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e2);
    }
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve3, reject2) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e2) {
        {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e2);
        }
      }
      resolve3(res);
    }, function(error) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error);
        });
      } catch (e2) {
        {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e2);
        }
      }
      reject2(error);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn, options) {
  var subs = typeof fn === "function" ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1(getter, cb, options) {
  var this$1$1 = this;
  {
    assert(typeof getter === "function", "store.watch only accepts a function.");
  }
  return watch(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state;
  });
};
Store.prototype.registerModule = function registerModule(path2, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path2 === "string") {
    path2 = [path2];
  }
  {
    assert(Array.isArray(path2), "module path must be a string or an Array.");
    assert(path2.length > 0, "cannot register the root module by using registerModule.");
  }
  this._modules.register(path2, rawModule);
  installModule(this, this.state, path2, this._modules.get(path2), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path2) {
  var this$1$1 = this;
  if (typeof path2 === "string") {
    path2 = [path2];
  }
  {
    assert(Array.isArray(path2), "module path must be a string or an Array.");
  }
  this._modules.unregister(path2);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path2.slice(0, -1));
    delete parentState[path2[path2.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path2) {
  if (typeof path2 === "string") {
    path2 = [path2];
  }
  {
    assert(Array.isArray(path2), "module path must be a string or an Array.");
  }
  return this._modules.isRegistered(path2);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
var dist = {};
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
var index_common = {};
Object.defineProperty(index_common, "__esModule", { value: true });
var e$1 = function() {
  function e2(e3) {
    this._observers = /* @__PURE__ */ new Map(), this._subscribed = false;
    var t2 = (e3 != null ? e3 : {}).delay, i2 = t2 === void 0 ? 33 : t2;
    this._delay = i2, this._handler = this._handleResize.bind(this);
  }
  return e2.prototype.addObserver = function(e3, t2) {
    return this._observers.set(e3, t2), t2(this._getEvent()), this;
  }, e2.prototype.deleteObserver = function(e3) {
    return this._observers.delete(e3), this;
  }, e2.prototype.deleteObservers = function() {
    return this._observers.clear(), this;
  }, e2.prototype.notifyObservers = function(e3) {
    return this._observers.forEach(function(t2) {
      t2(e3);
    }), this;
  }, e2.prototype.subscribe = function() {
    return typeof window == "undefined" || this._subscribed || (window.addEventListener("resize", this._handler), window.addEventListener("orientationchange", this._handler), this._subscribed = true), this;
  }, e2.prototype.unsubscribe = function() {
    return this._subscribed ? (window.removeEventListener("resize", this._handler), window.removeEventListener("orientationchange", this._handler), this._subscribed = false, this) : this;
  }, e2.prototype.setDelay = function(e3) {
    return this._delay = e3, this;
  }, e2.prototype.hasObserver = function() {
    return this._observers.size > 0;
  }, e2.prototype.dispatch = function() {
    return this._dispatch(), this;
  }, e2.prototype._getEvent = function() {
    return typeof window == "undefined" ? { width: 0, height: 0 } : { width: window.innerWidth, height: window.innerHeight };
  }, e2.prototype._dispatch = function() {
    var e3 = this._getEvent();
    this.notifyObservers(e3);
  }, e2.prototype._handleResize = function() {
    var e3 = this;
    clearTimeout(this._timer), this._timer = setTimeout(function() {
      e3._dispatch();
    }, this._delay);
  }, e2;
}();
index_common.WindowResizeSubject = e$1;
Object.defineProperty(dist, "__esModule", { value: true });
var e, i = require$$0, n = index_common, t = typeof window != "undefined", u = function(e2) {
  return e2 != null ? e2 : t ? window.innerWidth : 0;
}, r = function(e2) {
  return e2 != null ? e2 : t ? window.innerHeight : 0;
}, o = function(e2) {
  var t2 = 0, o2 = e2(), d = i.reactive({ width: u(void 0), height: r(void 0) });
  o2.addObserver("composition-api", function(e3) {
    var i2 = e3.width, n2 = e3.height;
    d.width = i2, d.height = n2;
  });
  return function() {
    return t2 === 0 && o2.subscribe().dispatch(), ++t2, i.onUnmounted(function() {
      (t2 = Math.max(t2 - 1, 0)) === 0 && o2.unsubscribe();
    }), { width: i.computed(function() {
      return d.width;
    }), height: i.computed(function() {
      return d.height;
    }) };
  };
}(function() {
  return e || (e = new n.WindowResizeSubject()), e;
});
var useWindowSize = dist.useWindowSize = o;
export { createBlock as A, createRouter as B, createWebHashHistory as C, createApp as D, Fragment as F, Suspense as S, createVNode as a, ref as b, createElementBlock as c, useRouter as d, createBaseVNode as e, vShow as f, computed as g, withCtx as h, createTextVNode as i, renderList as j, renderSlot as k, createCommentVNode as l, useWindowSize as m, normalizeClass as n, openBlock as o, parse as p, withKeys as q, resolveComponent as r, pushScopeId as s, toDisplayString as t, useStore as u, vModelText as v, withDirectives as w, popScopeId as x, createStore as y, useRoute as z };
